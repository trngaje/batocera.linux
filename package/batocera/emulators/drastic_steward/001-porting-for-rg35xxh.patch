diff --git a/Makefile.mk b/Makefile.mk
index d58d504..a8a1e4f 100644
--- a/Makefile.mk
+++ b/Makefile.mk
@@ -23,18 +23,18 @@ REL_VER  = $(shell git rev-parse HEAD | cut -c 1-8)
 
 .PHONY: all
 all:
-	make -C loader MOD=$(MOD)
+#	make -C loader MOD=$(MOD)
 	make -C detour MOD=$(MOD)
 	cp detour/libdtr.so drastic/libs/
-	make -C alsa MOD=$(MOD)
-	cp alsa/libasound.so.2 drastic/libs/
+#	make -C alsa MOD=$(MOD)
+#	cp alsa/libasound.so.2 drastic/libs/
 	make -C sdl2 -j4
 	cp sdl2/build/.libs/libSDL2-2.0.so.0 drastic/libs/
-	make -C unittest $(MOD)
+#	make -C unittest $(MOD)
 
 .PHONY: cfg
 cfg:
-	cp -a assets/$(MOD)/* drastic/
+#	cp -a assets/$(MOD)/* drastic/
 	cd sdl2 && ./autogen.sh && MOD=$(MOD) ./configure $(SDL2_CFG) --host=$(HOST)
 
 .PHONY: rel
@@ -47,7 +47,6 @@ clean:
 	rm -rf drastic/cpuclock
 	rm -rf drastic/launch.sh
 	rm -rf drastic/config.json
-	rm -rf drastic/show_hotkeys
 	rm -rf drastic/libs/libdtr.so
 	rm -rf drastic/libs/libasound.so.2
 	rm -rf drastic/libs/libSDL2-2.0.so.0
diff --git a/detour/Makefile b/detour/Makefile
index 7d5bc20..fadccb5 100644
--- a/detour/Makefile
+++ b/detour/Makefile
@@ -16,6 +16,12 @@ ifeq ($(MOD),mmiyoo)
     LDFLAGS+= -L../mmiyoo/lib -lmi_common -lmi_sys -lmi_gfx -lmi_ao
 endif
 
+ifeq ($(MOD),rg35xxh)
+    CFLAGS += -DRG35XXH -I../mmiyoo/inc
+    CFLAGS += -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3 -Wl,--no-undefined
+    LDFLAGS+= -ljson-c
+endif
+
 ifeq ($(MOD),trimui)
     CFLAGS += -DTRIMUI -I../trimui/inc
     CFLAGS += -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3 -Wl,--no-undefined
diff --git a/detour/detour.h b/detour/detour.h
index c3a5bf7..4cb9b9a 100644
--- a/detour/detour.h
+++ b/detour/detour.h
@@ -24,6 +24,8 @@
     #define VAR_SDL_SCREEN1_X           0x0aee9550
     #define VAR_SDL_SCREEN1_Y           0x0aee9554
 
+    #define VAR_SDL_SWAP_SCREENS        0x0aee9598
+
     #define VAR_ADPCM_STEP_TABLE        0x0815a600
     #define VAR_ADPCM_INDEX_STEP_TABLE  0x0815a6b8
     #define VAR_DESMUME_FOOTER_STR      0x0815a740
diff --git a/detour/main.c b/detour/main.c
index 877e36f..fad768e 100644
--- a/detour/main.c
+++ b/detour/main.c
@@ -33,7 +33,7 @@ static int32_t dtr_load_state_index(void *system, uint32_t index, uint16_t *snap
     char buf[255] = {0};
     nds_load_state _func = (nds_load_state)FUN_LOAD_STATE;
 
-    sprintf(buf, "%s/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, index);
+    sprintf(buf, "%s/savestates/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, index);
     _func((void*)VAR_SYSTEM, buf, snapshot_top, snapshot_bottom, snapshot_only);
 }
 
@@ -42,7 +42,7 @@ static int32_t dtr_save_state_index(void *system, uint32_t index, uint16_t *snap
     char buf[255] = {0};
     nds_save_state _func1 = (nds_save_state)FUN_SAVE_STATE;
 
-    sprintf(buf, "%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, index);
+    sprintf(buf, "savestates/%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, index);
     _func1((void*)VAR_SYSTEM, states_path, buf, snapshot_top, snapshot_bottom);
 }
 
@@ -66,7 +66,7 @@ static void dtr_initialize_backup(backup_struct *backup, backup_type_enum backup
     if (path != NULL) {
         data_file_name = malloc(255);
         memset(data_file_name, 0, 255);
-        sprintf(data_file_name, "%s/%s.dsv", states_path, VAR_SYSTEM_GAMECARD_NAME);
+        sprintf(data_file_name, "%s/backup/%s.dsv", states_path, VAR_SYSTEM_GAMECARD_NAME);
     }
     backup->type = backup_type;
     backup->address_mask = size - 1;
@@ -152,7 +152,7 @@ LAB_08092f94:
 
 int dtr_savestate(int slot)
 {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
     char buf[255] = {0};
     nds_screen_copy16 _func0 = (nds_screen_copy16)FUN_SCREEN_COPY16;
 
@@ -171,7 +171,7 @@ int dtr_savestate(int slot)
         else {
             nds_save_state _func1 = (nds_save_state)FUN_SAVE_STATE;
 
-            sprintf(buf, "%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, slot);
+            sprintf(buf, "savestates/%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, slot);
             _func1((void*)VAR_SYSTEM, states_path, buf, d0, d1);
         }
     }
@@ -206,7 +206,7 @@ int dtr_savestate(int slot)
 
 int dtr_loadstate(int slot)
 {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
     char buf[255] = {0};
 
     if (is_hooked == 0) {
@@ -217,7 +217,7 @@ int dtr_loadstate(int slot)
     else {
         nds_load_state _func = (nds_load_state)FUN_LOAD_STATE;
 
-        sprintf(buf, "%s/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, slot);
+        sprintf(buf, "%s/savestates/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, slot);
         _func((void*)VAR_SYSTEM, buf, 0, 0, 0);
     }
 #endif
diff --git a/drastic/resources/lang/korean_kr b/drastic/resources/lang/korean_kr
new file mode 100644
index 0000000..9dc31c9
--- /dev/null
+++ b/drastic/resources/lang/korean_kr
@@ -0,0 +1,108 @@
+CPU=CPU
+Overlay=오버레이
+Display=화면
+Alpha=알파값 
+Border=테두리
+Position=위치
+Alt. Display=대체 화면
+Volume=소리 크기
+Disabled=비활성화
+Touchpad=터치패드
+Wallpaper=바탕화면
+Quick Save=빠른 저장하기
+Quick Load=빠른 불러오기
+Fast Forward=빠르게 플레이
+Top-Right=우측 상단
+Top-Left=좌측 상단
+Bottom-Left=좌측 하단
+Bottom-Right=우측 하단
+White=흰색
+Red=붉은색
+Green=녹색
+Blue=파란색
+Black=검정색
+Yellow=노란색
+Cyan=하늘색
+Version=버젼
+Change Options=옵션 변경
+Configure Controls=입력 설정
+Configure Firmware=펌웨어 설정
+Configure Cheats=치트 설정
+Load state=상태 불러오기
+Save state=상태 저장하기
+Load new game=새로운 게임 불러오기
+Restart game=게임 재 시작하기
+Return to game=게임으로 돌아가기
+Exit DraStic=DraStic 끝내기
+Keys=키
+Frame skip type=프레임 스킵 타입
+automatic=자동
+manual=수동
+yes=네
+no=아니오
+Yes=네
+No=아니오
+none=없음
+None=없음
+Frame skip value=프레임 스킵 값
+Screen orientation=화면 회전
+vertical=수직
+horizontal=수평
+single=단일
+Screen swap=화면 교환
+Show speed=표시 속도
+Enable sound=소리 활성화
+Fast forward=빠른 진행
+Mirror touchscreen=터치스크린 반전
+Compress savestates=savestates 압축하기
+Snapshot in savestates=Snapshot in savestates
+Enable cheats=치트 활성화
+Uncompress ROMs=ROMs 압축 풀기
+Backup in savestates=savestates 백업하기
+Speed override=Speed override
+Fix main 2D screen=Fix main 2D screen
+Disable edge marking=edge marking 비활성화
+High-resolution 3D=고해상도 3D
+Threaded 3D=Threaded 3D
+Delete game-specific config=게임 지정 설정 값 제거
+Exit: save for all games=끝내기: 모든게임을 위한 설정 값 저장
+Exit: save for this game=끝내기: 에 게임에만 설정 값 저장
+Exit without saving=저장 없이 끝내기
+Username=사용자 이름
+Language=언어
+Favorite Color=좋아하는 색
+Birthday Month=태어난 달
+Birthday Day=태어난 날
+English=영어
+French=프랑스어
+German=독일어
+Italian=이탈리아어
+Spanish=스페인어
+Chinese=중국어
+Japanese=일본어
+January=1월
+February=2월
+March=3월
+April=4월
+May=5월
+June=6월
+July=7월
+August=8월
+September=9월
+October=10월
+November=11월
+December=12월
+Extra Controls=기타 제어
+Restore default controls=기본 설정값으로 복구
+Unmapped=설정 안함
+Hotkey=핫키
+Swap L1-L2=L1과 L2 교환
+Swap R1-R2=R1과 R2 교환
+Mode=모드
+Pen X Speed=펜 X축 속도
+Pen Y Speed=펜 Y축 속도
+Pixel=펙셀
+Blur=블러
+Cursor=커서
+Show=표시
+Hide=감추기
diff --git a/drastic/resources/settings.json b/drastic/resources/settings.json
index f1e30fd..6b5ba93 100644
--- a/drastic/resources/settings.json
+++ b/drastic/resources/settings.json
@@ -26,7 +26,7 @@
   "half_vol":0,
   "splash":3,
   "hotkey":0,
-  "states":"",
+  "states":"\/userdata\/saves\/nds\/drastic",
   "menu_bg":0,
   "menu_cursor":1,
   "fast_forward":6,
diff --git a/sdl2/configure.ac b/sdl2/configure.ac
index d99f07e..9a55b4f 100644
--- a/sdl2/configure.ac
+++ b/sdl2/configure.ac
@@ -2424,6 +2424,21 @@ CheckMMiyooVideo()
     fi
 }
 
+CheckRG35XXHVideo()
+{
+    if test x$enable_video = xyes; then
+        AC_DEFINE(SDL_VIDEO_DRIVER_MMIYOO, 1, [ ])
+        AC_DEFINE(SDL_VIDEO_RENDER_MMIYOO, 1, [ ])
+        SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c $srcdir/src/video/mmiyoo/*.S"
+        have_video=yes
+        
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -DRG35XXH -DRG35XXH_GL -fPIC -mcpu=cortex-a7 -mfpu=neon-vfpv4  -O3 -I../mmiyoo/inc -I../detour -I/%SDL2%"
+        EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L. -lEGL -lGLESv2 -lrt -lSDL2_image -lSDL2_ttf -ljson-c -L../detour -ldtr"
+        SUMMARY_video="${SUMMARY_video} mmiyoo"
+    fi
+}
+
+
 CheckTrimuiVideo()
 {
     if test x$enable_video = xyes; then
@@ -2504,6 +2519,20 @@ CheckMMiyooAudio()
     fi
 }
 
+CheckRG35XXHAudio()
+{
+    if test x$enable_audio = xyes; then
+        AC_DEFINE(SDL_AUDIO_DRIVER_MMIYOO, 1, [ ])
+        SOURCES="$SOURCES $srcdir/src/audio/mmiyoo/*.c"
+        have_audio=yes
+        if test x$HOST = xarm-linux; then
+            EXTRA_CFLAGS="$EXTRA_CFLAGS -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L../mmiyoo/lib  -l:libasound.so.2"
+        fi
+        SUMMARY_audio="${SUMMARY_audio} mmiyoo"
+    fi
+}
+
 CheckTrimuiAudio()
 {
     if test x$enable_audio = xyes; then
@@ -3847,6 +3876,9 @@ case "$host" in
             *mmiyoo*)           ARCH=mmiyoo
                 CheckMMiyooVideo
                 ;;
+            *rg35xxh*)           ARCH=rg35xxh
+                CheckRG35XXHVideo
+                ;;
             *trimui*)           ARCH=trimui
                 CheckTrimuiVideo
                 ;;
@@ -3978,6 +4010,9 @@ case "$host" in
             mmiyoo)
                 CheckMMiyooAudio
             ;;
+            rg35xxh)
+                CheckRG35XXHAudio
+            ;;
             trimui)
                 CheckTrimuiAudio
             ;;
@@ -4015,7 +4050,7 @@ case "$host" in
                 SOURCES="$SOURCES $srcdir/src/joystick/steam/*.c"
                 have_joystick=yes
             ;;
-            a30|mmiyoo|trimui|pandora|unittest)
+            a30|mmiyoo|rg35xxh|trimui|pandora|unittest)
                 AC_DEFINE(SDL_JOYSTICK_MMIYOO, 1, [ ])
                 SOURCES="$SOURCES $srcdir/src/joystick/mmiyoo/*.c"
                 have_joystick=yes
diff --git a/sdl2/src/video/SDL_stretch.c b/sdl2/src/video/SDL_stretch.c
index dad3eb5..d608a2e 100644
--- a/sdl2/src/video/SDL_stretch.c
+++ b/sdl2/src/video/SDL_stretch.c
@@ -296,7 +296,7 @@ INTERPOL_BILINEAR(const Uint32 *s0, const Uint32 *s1, int frac_w0, int frac_h0,
     INTERPOL(tmp,   tmp + 1, frac_w0, frac_w1, dst);
 }
 
-static int
+int
 scale_mat(const Uint32 *src, int src_w, int src_h, int src_pitch,
           Uint32 *dst, int dst_w, int dst_h, int dst_pitch)
 {
@@ -595,7 +595,7 @@ INTERPOL_BILINEAR_NEON(const Uint32 *s0, const Uint32 *s1, int frac_w, uint8x8_t
     *dst = vget_lane_u32(CAST_uint32x2_t e0, 0);
 }
 
-static int
+int
 scale_mat_NEON(const Uint32 *src, int src_w, int src_h, int src_pitch, Uint32 *dst, int dst_w, int dst_h, int dst_pitch)
 {
     BILINEAR___START
diff --git a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c
index b298ab0..4a403c9 100644
--- a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c
+++ b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c
@@ -42,10 +42,57 @@
     #define INPUT_DEV "/dev/input/event4"
 #elif defined(QX1000) || defined(A30)
     #define INPUT_DEV "/dev/input/event3"
+#elif defined(RG35XXH)
+    #define INPUT_DEV "/dev/input/event1" /* RG35XXH */
+//    #define INPUT_DEV "/dev/input/event2" /* RG35XXH evmapy*/
 #else
     #define INPUT_DEV "/dev/input/event0"
 #endif
 
+#ifdef RG35XXH
+/*
+// for evmapy 
+    #define UP      103
+    #define DOWN    108
+    #define LEFT    105
+    #define RIGHT   106
+    #define A       57
+    #define B       29
+    #define X       42
+    #define Y       56
+    #define L1      18
+    #define L2      15
+    #define R1      20
+    #define R2      14
+    #define START   28
+    #define SELECT  97
+    #define MENU    1
+    #define POWER   116
+    #define VOLUP   115
+    #define VOLDOWN 114
+	*/
+    #define UP      -1	/* not defined */
+    #define DOWN    -1 /* not defined */
+    #define LEFT    -1 /* not defined */
+    #define RIGHT   -1 /* not defined */
+    #define A       BTN_SOUTH
+    #define B       BTN_EAST
+    #define X       BTN_NORTH
+    #define Y       BTN_C
+    #define L1      BTN_WEST
+    #define L2      BTN_SELECT
+    #define R1      BTN_Z
+    #define R2      BTN_START
+    #define START   BTN_TR
+    #define SELECT  BTN_TL
+    #define MENU    BTN_TL2
+    #define POWER   116 /* not defined */
+    #define VOLUP   115 /* not defined */
+    #define VOLDOWN 114	/* not defined */
+	#define L3		BTN_TR2
+	#define R3		BTN_MODE
+#endif
+
 #ifdef A30
     #define UP      103
     #define DOWN    108
@@ -189,6 +236,8 @@ const SDL_Scancode code[]={
     SDLK_t,             // R1
     SDLK_TAB,           // L2
     SDLK_BACKSPACE,     // R2
+	SDLK_4,	// L3
+	SDLK_5, 	// R3
     SDLK_RCTRL,         // SELECT
     SDLK_RETURN,        // START
     SDLK_HOME,          // MENU
@@ -197,6 +246,7 @@ const SDL_Scancode code[]={
     SDLK_2,             // FAST FORWARD
     SDLK_3,             // EXIT
     SDLK_HOME,          // MENU (Onion system)
+
 };
 
 int volume_inc(void);
@@ -256,7 +306,7 @@ static void release_all_keys(void)
 
 static int hit_hotkey(uint32_t bit)
 {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     uint32_t mask = (1 << bit) | (1 << ((nds.hotkey == HOTKEY_BIND_SELECT) ? MYKEY_SELECT : MYKEY_MENU));
 #endif
 
@@ -283,7 +333,7 @@ static void set_key(uint32_t bit, int val)
         }
 #endif
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
         if (nds.hotkey == HOTKEY_BIND_SELECT) {
             if (bit == MYKEY_SELECT) {
                 cur_keypad_bitmaps = (1 << MYKEY_SELECT);
@@ -507,7 +557,7 @@ static int handle_hotkey(void)
     }
 
     if (hotkey_mask && hit_hotkey(MYKEY_UP)) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         if (evt.mode == MMIYOO_MOUSE_MODE) {
             switch (nds.dis_mode) {
             case NDS_DIS_MODE_VH_T0:
@@ -530,7 +580,7 @@ static int handle_hotkey(void)
     }
 
     if (hotkey_mask && hit_hotkey(MYKEY_DOWN)) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         if (evt.mode == MMIYOO_MOUSE_MODE) {
             switch (nds.dis_mode) {
             case NDS_DIS_MODE_VH_T0:
@@ -553,7 +603,7 @@ static int handle_hotkey(void)
     }
 
     if (hotkey_mask && hit_hotkey(MYKEY_LEFT)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
         if (nds.hres_mode == 0) {
             if (nds.dis_mode > 0) {
                 nds.dis_mode -= 1;
@@ -578,7 +628,7 @@ static int handle_hotkey(void)
     }
 
     if (hotkey_mask && hit_hotkey(MYKEY_RIGHT)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
         if (nds.hres_mode == 0) {
             if (nds.dis_mode < NDS_DIS_MODE_LAST) {
                 nds.dis_mode += 1;
@@ -596,7 +646,7 @@ static int handle_hotkey(void)
     }
 
     if (hotkey_mask && hit_hotkey(MYKEY_A)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
         if ((evt.mode == MMIYOO_KEYPAD_MODE) && (nds.hres_mode == 0)) {
             uint32_t tmp = nds.alt_mode;
             nds.alt_mode = nds.dis_mode;
@@ -612,7 +662,7 @@ static int handle_hotkey(void)
     }
 
     if (hotkey_mask && hit_hotkey(MYKEY_B)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
         pixel_filter = pixel_filter ? 0 : 1;
 #endif
         set_key(MYKEY_B, 0);
@@ -696,7 +746,7 @@ static int handle_hotkey(void)
     }
 
     if (hotkey_mask && hit_hotkey(MYKEY_START)) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         if (nds.menu.enable == 0) {
 #ifdef QX1000
             update_wayland_res(640, 480);
@@ -715,7 +765,7 @@ static int handle_hotkey(void)
         set_key(MYKEY_START, 0);
     }
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     if (nds.hotkey == HOTKEY_BIND_MENU) {
         if (hotkey_mask && hit_hotkey(MYKEY_SELECT)) {
             set_key(MYKEY_MENU_ONION, 1);
@@ -732,7 +782,7 @@ static int handle_hotkey(void)
 #endif
 
     if (hotkey_mask && hit_hotkey(MYKEY_R1)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
         static int pre_ff = 0;
 
         if (pre_ff != nds.fast_forward) {
@@ -749,7 +799,7 @@ static int handle_hotkey(void)
     }
 
     if (hotkey_mask && hit_hotkey(MYKEY_L1)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
         set_key(MYKEY_EXIT, 1);
 #endif
 
@@ -759,7 +809,7 @@ static int handle_hotkey(void)
         set_key(MYKEY_L1, 0);
     }
 
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
     if (hotkey_mask && hit_hotkey(MYKEY_R2)) {
 #if defined(MMIYOO) || defined(A30)
         set_key(MYKEY_QLOAD, 1);
@@ -770,7 +820,7 @@ static int handle_hotkey(void)
     }
 
     if (hotkey_mask && hit_hotkey(MYKEY_L2)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
         set_key(MYKEY_QSAVE, 1);
 #else
         set_key(MYKEY_QLOAD, 1);
@@ -803,7 +853,7 @@ int EventUpdate(void *data)
 
     uint32_t l1 = L1;
     uint32_t r1 = R1;
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
     uint32_t l2 = L2;
     uint32_t r2 = R2;
 #endif
@@ -818,9 +868,59 @@ int EventUpdate(void *data)
     uint32_t left = LEFT;
     uint32_t right = RIGHT;
 
+#ifdef RG35XXH
+	int i;
+	int input[NUM_OF_MYKEY] = {UP, DOWN, LEFT, RIGHT, A, B, X, Y, L1, R1, L2, R2, L3, R3,SELECT, START, MENU,-1, -1, -1, -1};
+
+	for (i=0; i < NUM_OF_MYKEY; i++) {
+		if (nds.input.key[i] != -1) {
+			printf(PREFIX"nds.input.key[%d]=%d\n", i, nds.input.key[i] );
+			input[i] = nds.input.key[i];
+		}
+	}
+	
+#endif
+
     while (running) {
         SDL_SemWait(event_sem);
 
+#ifdef RG35XXH
+        if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0) && nds.keys_rotate) {
+            if (nds.keys_rotate == 1) {
+                up = input[MYKEY_LEFT];
+                down = input[MYKEY_RIGHT];
+                left = input[MYKEY_DOWN];
+                right = input[MYKEY_UP];
+
+                a = input[MYKEY_X];
+                b = input[MYKEY_A];
+                x = input[MYKEY_Y];
+                y = input[MYKEY_B];
+            }
+            else {
+                up = input[MYKEY_RIGHT];
+                down = input[MYKEY_LEFT];
+                left = input[MYKEY_UP];
+                right = input[MYKEY_DOWN];
+
+                a = input[MYKEY_B];
+                b = input[MYKEY_Y];
+                x = input[MYKEY_A];
+                y = input[MYKEY_X];
+            }
+        }
+        else {
+            up = input[MYKEY_UP];
+            down = input[MYKEY_DOWN];
+            left = input[MYKEY_LEFT];
+            right = input[MYKEY_RIGHT];
+
+            a = input[MYKEY_A];
+            b = input[MYKEY_B];
+            x = input[MYKEY_X];
+            y = input[MYKEY_Y];
+        }
+#else
         if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0) && nds.keys_rotate) {
             if (nds.keys_rotate == 1) {
                 up = LEFT;
@@ -856,8 +956,27 @@ int EventUpdate(void *data)
             x = X;
             y = Y;
         }
+#endif
 
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(RG35XXH)
+        if (nds.swap_l1l2) {
+            l1 = input[MYKEY_L2];
+            l2 = input[MYKEY_L1];
+        }
+        else {
+            l1 = input[MYKEY_L1];
+            l2 = input[MYKEY_L2];
+        }
+
+        if (nds.swap_r1r2) {
+            r1 = input[MYKEY_R2];
+            r2 = input[MYKEY_R1];
+        }
+        else {
+            r1 = input[MYKEY_R1];
+            r2 = input[MYKEY_R2];
+        }
+#elif defined(MMIYOO) || defined(QX1000) || defined(A30)
         if (nds.swap_l1l2) {
             l1 = L2;
             l2 = L1;
@@ -893,20 +1012,322 @@ int EventUpdate(void *data)
             int r = 0;
 
             if (read(event_fd, &ev, sizeof(struct input_event))) {
-                if ((ev.type == EV_KEY) && (ev.value != 2)) {
+				if (ev.type == EV_ABS) {
+					if (ev.code == ABS_HAT0X) {
+						 if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0) && nds.keys_rotate) {
+							if (nds.keys_rotate == 1) {
+								// degree 270
+								if (ev.value < 0) { 
+									// up 
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+									set_key(MYKEY_UP,    1); 
+								}  
+								else if (ev.value > 0) { 
+									// down 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+										set_key(MYKEY_UP, 0); 
+									} 
+									set_key(MYKEY_DOWN,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+										set_key(MYKEY_UP, 0); 
+									} 
+
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+								}
+							}
+							else {
+								// degree 90
+								if (ev.value > 0) { 
+									// up 
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+									set_key(MYKEY_UP,    1); 
+								}  
+								else if (ev.value < 0) { 
+									// down 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+										set_key(MYKEY_UP, 0); 
+									} 
+									set_key(MYKEY_DOWN,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+										set_key(MYKEY_UP, 0); 
+									} 
+
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+								} 
+							}
+						 }
+						else {
+							// degree 0
+				
+							if (ev.value < 0) {
+								// left
+								if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+									set_key(MYKEY_RIGHT, 0);
+								}
+								set_key(MYKEY_LEFT,    1); 
+							} 
+							else if (ev.value > 0) {
+								// right
+								if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+									set_key(MYKEY_LEFT, 0);
+								} 
+								set_key(MYKEY_RIGHT,    1); 
+							} 
+							else { 
+								// center 
+								if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+									set_key(MYKEY_LEFT, 0); 
+								} 
+								if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+									set_key(MYKEY_RIGHT, 0); 
+								} 
+							} 
+						}
+					} 
+					else if (ev.code == ABS_HAT0Y) { 
+						if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0) && nds.keys_rotate) {
+							if (nds.keys_rotate == 1) {
+								// degree 270
+								if (ev.value > 0) {
+									// left
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+										set_key(MYKEY_RIGHT, 0);
+									}
+									set_key(MYKEY_LEFT,    1); 
+								} 
+								else if (ev.value < 0) {
+									// right
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+										set_key(MYKEY_LEFT, 0);
+									} 
+									set_key(MYKEY_RIGHT,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+										set_key(MYKEY_LEFT, 0); 
+									} 
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+										set_key(MYKEY_RIGHT, 0); 
+									} 
+								} 
+							}
+							else {
+								// degree 90
+								if (ev.value < 0) {
+									// left
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+										set_key(MYKEY_RIGHT, 0);
+									}
+									set_key(MYKEY_LEFT,    1); 
+								} 
+								else if (ev.value > 0) {
+									// right
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+										set_key(MYKEY_LEFT, 0);
+									} 
+									set_key(MYKEY_RIGHT,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+										set_key(MYKEY_LEFT, 0); 
+									} 
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+										set_key(MYKEY_RIGHT, 0); 
+									} 
+								} 
+							}
+						}
+						else {
+							// degree 0
+							
+							if (ev.value < 0) { 
+								// up 
+								if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+									set_key(MYKEY_DOWN, 0); 
+								} 
+								set_key(MYKEY_UP,    1); 
+							}  
+							else if (ev.value > 0) { 
+								// down 
+								if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+									set_key(MYKEY_UP, 0); 
+								} 
+								set_key(MYKEY_DOWN,    1); 
+							} 
+							else { 
+								// center 
+								if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+									set_key(MYKEY_UP, 0); 
+								} 
+
+								if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+									set_key(MYKEY_DOWN, 0); 
+								} 
+							} 
+						}
+					} 
+					else if (ev.code == ABS_Z) {
+						// left analog x
+						if (ev.value < -100) {
+							// left
+							evt.analogstick_left_x = ev.value / 1024;;
+						}
+						else if (ev.value > 100) {
+							// right
+							evt.analogstick_left_x = ev.value / 1024;;
+						}
+						else {
+							// center 
+							evt.analogstick_left_x = 0;
+						}						
+					}
+					else if (ev.code == ABS_RX) {
+						// left analog y
+						if (ev.value < -100) {
+							// up
+							evt.analogstick_left_y = ev.value / 1024;
+						}
+						else if (ev.value > 100) {
+							// down
+							evt.analogstick_left_y = ev.value / 1024;
+						}
+						else {
+							// center 
+							evt.analogstick_left_y = 0;
+						}		
+					}					
+					else if (ev.code == ABS_RY) {
+						if (nds.dis_mode == NDS_DIS_MODE_HH1) {
+							if (evt.mode == MMIYOO_KEYPAD_MODE) {
+								// right analog x -> dpad
+								// left -> up
+								// right -> down
+								if (ev.value < -100) {
+									// up 
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+									set_key(MYKEY_UP,    1); 							
+								}
+								else if (ev.value > 100) {
+									// down 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+										set_key(MYKEY_UP, 0); 
+									} 
+									set_key(MYKEY_DOWN,    1); 							
+								}
+								else {
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+										set_key(MYKEY_UP, 0); 
+									} 
+
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 							
+								}
+							}
+							else {
+								// right analog x -> touch
+								// left -> up
+								// right -> down
+								if (ev.value < -100) {
+									// up 
+									evt.analogstick_right_y = ev.value / 1024;
+								}
+								else if (ev.value > 100) {
+									// down 
+									evt.analogstick_right_y= ev.value / 1024;
+								}
+								else {
+									// center 
+									evt.analogstick_right_y = 0;
+								}								
+							}
+						}
+					}
+					else if (ev.code ==  ABS_RZ) {
+						if (nds.dis_mode == NDS_DIS_MODE_HH1) {
+							if (evt.mode == MMIYOO_KEYPAD_MODE) {
+								// right analog y to dpad
+								// down ->left
+								// up -> right
+								if (ev.value < -100) {
+									// right
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+										set_key(MYKEY_LEFT, 0);
+									} 
+									set_key(MYKEY_RIGHT,    1); 					
+								}
+								else if (ev.value > 100) {
+									// left
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+										set_key(MYKEY_RIGHT, 0);
+									}
+									set_key(MYKEY_LEFT,    1); 									
+								}
+								else {
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+										set_key(MYKEY_LEFT, 0); 
+									} 
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+										set_key(MYKEY_RIGHT, 0); 
+									} 							
+								}
+							}
+							else {
+								// right analog y to touch
+								// down ->left
+								// up -> right
+								if (ev.value < -100) {
+									// up 
+									evt.analogstick_right_x= ev.value  *  (-1) / 1024;
+								}
+								else if (ev.value > 100) {
+									// down 
+									evt.analogstick_right_x= ev.value  * (-1) / 1024;
+								}
+								else {
+									// center 
+									evt.analogstick_right_x  = 0;
+								}										
+							}
+						}
+					}
+				}
+                else if ((ev.type == EV_KEY) && (ev.value != 2)) {
                     r = 1;
                     //printf(PREFIX"code:%d, value:%d\n", ev.code, ev.value);
                     if (ev.code == l1)      { set_key(MYKEY_L1,    ev.value); }
                     if (ev.code == r1)      { set_key(MYKEY_R1,    ev.value); }
-                    if (ev.code == up)      { set_key(MYKEY_UP,    ev.value); }
-                    if (ev.code == down)    { set_key(MYKEY_DOWN,  ev.value); }
-                    if (ev.code == left)    { set_key(MYKEY_LEFT,  ev.value); }
-                    if (ev.code == right)   { set_key(MYKEY_RIGHT, ev.value); }
+
+                    if (up != -1 && ev.code == up)      { set_key(MYKEY_UP,    ev.value); }
+                    if (down != -1 && ev.code == down)    { set_key(MYKEY_DOWN,  ev.value); }
+                    if (left != -1 && ev.code == left)    { set_key(MYKEY_LEFT,  ev.value); }
+                    if (right != -1 && ev.code == right)   { set_key(MYKEY_RIGHT, ev.value); }
+
                     if (ev.code == a)       { set_key(MYKEY_A,     ev.value); }
                     if (ev.code == b)       { set_key(MYKEY_B,     ev.value); }
                     if (ev.code == x)       { set_key(MYKEY_X,     ev.value); }
                     if (ev.code == y)       { set_key(MYKEY_Y,     ev.value); }
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
 #ifdef A30
                     if (ev.code == r2) {
                         if (nds.joy.mode == MYJOY_MODE_MOUSE) {
@@ -929,16 +1350,34 @@ int EventUpdate(void *data)
                         }
                     }
                     if (ev.code == l2)      { set_key(MYKEY_R2,    ev.value); }
+#elif defined(RG35XXH)
+                    if (ev.code == r2)      { set_key(MYKEY_R2,    ev.value); }
+                    if (ev.code == l2)      { set_key(MYKEY_L2,    ev.value); }
 #else
                     if (ev.code == r2)      { set_key(MYKEY_L2,    ev.value); }
                     if (ev.code == l2)      { set_key(MYKEY_R2,    ev.value); }
 #endif
 #endif
 
+#if defined(RG35XXH)
+                    if (ev.code == input[MYKEY_L3])      { set_key(MYKEY_L3,    ev.value);}
+                    if (ev.code == input[MYKEY_R3])      { set_key(MYKEY_R3,    ev.value);}
+					if (input[MYKEY_QSAVE] != -1 && ev.code == input[MYKEY_QSAVE])      { set_key(MYKEY_QSAVE,    ev.value); }
+					if (input[MYKEY_QLOAD] != -1 && ev.code == input[MYKEY_QLOAD])      { set_key(MYKEY_QLOAD,    ev.value); }
+					if (input[MYKEY_EXIT] != -1 && ev.code == input[MYKEY_EXIT])      { set_key(MYKEY_EXIT,    ev.value); }
+	
+                    if (ev.code == input[MYKEY_START])      { set_key(MYKEY_START,    ev.value); }
+                    if (ev.code == input[MYKEY_SELECT])      { set_key(MYKEY_SELECT,    ev.value); }
+                    if (ev.code == input[MYKEY_MENU])      { set_key(MYKEY_MENU,    ev.value); }					
+					
+#endif
+
 #ifdef QX1000
                     if (ev.code == L10)     { set_key(MYKEY_L1,    ev.value); }
                     if (ev.code == R10)     { set_key(MYKEY_R1,    ev.value); }
 #endif
+
+#ifndef RG35XXH
                     switch (ev.code) {
                     case START:  set_key(MYKEY_START, ev.value);  break;
                     case SELECT: set_key(MYKEY_SELECT, ev.value); break;
@@ -989,14 +1428,21 @@ int EventUpdate(void *data)
                         break;
 #endif
                     }
+#endif
                 }
             }
 #if defined(A30) && USE_MYJOY
             r |= update_joystick();
 #endif
+
+#ifndef RG35XXH
             if (r > 0) {
                 handle_hotkey();
-            }
+#endif
+            
+#ifdef RG35XXH
+            handle_hotkey();
+#endif
         }
         SDL_SemPost(event_sem);
         usleep(1000000 / 60);
@@ -1007,7 +1453,7 @@ int EventUpdate(void *data)
 
 void MMIYOO_EventInit(void)
 {
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(RG35XXH)
     DIR *dir = NULL;
 #endif
 
@@ -1039,7 +1485,14 @@ void MMIYOO_EventInit(void)
 #endif
     evt.mode = MMIYOO_KEYPAD_MODE;
 
-    event_fd = open(INPUT_DEV, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
+	if (strlen(nds.input.dev) > 0) {
+		printf(PREFIX"nds.input.dev=%s\n", nds.input.dev);
+		event_fd = open(nds.input.dev, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
+	}
+	else {
+		event_fd = open(INPUT_DEV, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
+	}
+	
     if(event_fd < 0){
         printf(PREFIX"Failed to open event0\n");
     }
@@ -1094,9 +1547,11 @@ void MMIYOO_EventDeinit(void)
 
 void MMIYOO_PumpEvents(_THIS)
 {
+	//SDL_EVDEV_Poll();
+
     SDL_SemWait(event_sem);
     if (nds.menu.enable) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         int cc = 0;
         uint32_t bit = 0;
         uint32_t changed = pre_keypad_bitmaps ^ evt.keypad.bitmaps;
@@ -1122,7 +1577,7 @@ void MMIYOO_PumpEvents(_THIS)
                 for (cc=0; cc<=MYKEY_LAST_BITS; cc++) {
                     bit = 1 << cc;
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                     if ((nds.hotkey == HOTKEY_BIND_MENU) && (cc == MYKEY_MENU)) {
                         continue;
                     }
@@ -1138,6 +1593,12 @@ void MMIYOO_PumpEvents(_THIS)
                         SDL_SendKeyboardKey((evt.keypad.bitmaps & bit) ? SDL_PRESSED : SDL_RELEASED, SDL_GetScancodeFromKey(code[cc]));
                     }
                 }
+				
+#ifdef RG35XXH
+				if (changed & (1 << MYKEY_R3)) {
+                    SDL_SendMouseButton(vid.window, 0, (evt.keypad.bitmaps & (1 << MYKEY_R3)) ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_LEFT);
+                }
+#endif
 
 #if defined(TRIMUI) || defined(PANDORA)
                 if (pre_keypad_bitmaps & (1 << MYKEY_R2)) {
@@ -1180,6 +1641,12 @@ void MMIYOO_PumpEvents(_THIS)
                     SDL_SendMouseButton(vid.window, 0, (evt.keypad.bitmaps & (1 << MYKEY_A)) ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_LEFT);
                 }
 
+#ifdef RG35XXH
+				if (changed & (1 << MYKEY_R3)) {
+                    SDL_SendMouseButton(vid.window, 0, (evt.keypad.bitmaps & (1 << MYKEY_R3)) ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_LEFT);
+                }
+#endif
+
                 for (cc=0; cc<=MYKEY_LAST_BITS; cc++) {
                     bit = 1 << cc;
                     if ((cc == MYKEY_FF) || (cc == MYKEY_QSAVE) || (cc == MYKEY_QLOAD) || (cc == MYKEY_EXIT) || (cc == MYKEY_R2)) {
@@ -1236,10 +1703,15 @@ void MMIYOO_PumpEvents(_THIS)
             if(updated){
                 int x = 0;
                 int y = 0;
-
+#ifdef RG35XXH
+                x = (evt.mouse.x * 320) / evt.mouse.maxx;
+                y = (evt.mouse.y * 240) / evt.mouse.maxy;
+               SDL_SendMouseMotion(vid.window, 0, 0, x + 160, y + (nds.pen.pos ? 240 : 0));
+#else
                 x = (evt.mouse.x * 160) / evt.mouse.maxx;
                 y = (evt.mouse.y * 120) / evt.mouse.maxy;
                 SDL_SendMouseMotion(vid.window, 0, 0, x + 80, y + (nds.pen.pos ? 120 : 0));
+#endif
             }
 
 #if defined(TRIMUI) || defined(PANDORA)
@@ -1265,6 +1737,48 @@ void MMIYOO_PumpEvents(_THIS)
             pre_keypad_bitmaps = evt.keypad.bitmaps;
         }
     }
+
+#ifdef RG35XXH
+	{
+		// check left analog stick	
+		 int updated = 0;
+		 if (evt.analogstick_left_y != 0) {
+			updated = 1;
+			evt.mouse.y+= evt.analogstick_left_y;
+			evt.pen_display_cnt = 180;
+		}
+
+		if (evt.analogstick_left_x != 0) {
+			updated = 1;
+			evt.mouse.x+= evt.analogstick_left_x;
+			evt.pen_display_cnt = 180;
+		}
+
+		// check right analog stick	
+		 if (evt.analogstick_right_y != 0) {
+			updated = 1;
+			evt.mouse.y+= evt.analogstick_right_y;
+			evt.pen_display_cnt = 180;
+		}
+
+		if (evt.analogstick_right_x != 0) {
+			updated = 1;
+			evt.mouse.x+= evt.analogstick_right_x;
+			evt.pen_display_cnt = 180;
+		}
+		
+		check_mouse_pos();
+
+		if(updated){
+			int x = 0;
+			int y = 0;
+
+			x = (evt.mouse.x * 320) / evt.mouse.maxx;
+			y = (evt.mouse.y * 240) / evt.mouse.maxy;
+		   SDL_SendMouseMotion(vid.window, 0, 0, x + 160, y + (nds.pen.pos ? 240 : 0));
+		}	
+	}
+#endif
     SDL_SemPost(event_sem);
 }
 
diff --git a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h
index 86a7c03..d8a22c7 100644
--- a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h
+++ b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h
@@ -26,8 +26,38 @@
 #define __SDL_EVENT_MMIYOO_H__
 
 #include "../../SDL_internal.h"
-#include "SDL_event_mmiyoo.h"
+//#include "SDL_event_mmiyoo.h"
+#ifdef RG35XXH
+enum {
+    MYKEY_UP = 0,
+	MYKEY_DOWN,
+    MYKEY_LEFT,
+    MYKEY_RIGHT,
+    MYKEY_A,
+    MYKEY_B,
+    MYKEY_X,
+    MYKEY_Y,
+    MYKEY_L1,
+    MYKEY_R1,
+    MYKEY_L2,
+    MYKEY_R2,
+    MYKEY_L3,
+    MYKEY_R3,	
+    MYKEY_SELECT,
+    MYKEY_START,
+    MYKEY_MENU,
+    MYKEY_QSAVE,
+    MYKEY_QLOAD,
+    MYKEY_FF,
+    MYKEY_EXIT,
+    MYKEY_MENU_ONION,
 
+	NUM_OF_MYKEY
+};
+
+#define MYKEY_LAST_BITS     21 // ignore POWER, VOL-, VOL+ keys
+
+#else
 #define MYKEY_UP            0
 #define MYKEY_DOWN          1
 #define MYKEY_LEFT          2
@@ -40,19 +70,23 @@
 #define MYKEY_R1            9
 #define MYKEY_L2            10
 #define MYKEY_R2            11
-#define MYKEY_SELECT        12
-#define MYKEY_START         13
-#define MYKEY_MENU          14
-#define MYKEY_QSAVE         15
-#define MYKEY_QLOAD         16
-#define MYKEY_FF            17
-#define MYKEY_EXIT          18
-#define MYKEY_MENU_ONION    19
-#define MYKEY_POWER         20
-#define MYKEY_VOLUP         21
-#define MYKEY_VOLDOWN       22
-
-#define MYKEY_LAST_BITS     19 // ignore POWER, VOL-, VOL+ keys
+#define MYKEY_L3       12
+#define MYKEY_R3       13
+#define MYKEY_SELECT        14
+#define MYKEY_START         15
+#define MYKEY_MENU          16
+#define MYKEY_QSAVE         17
+#define MYKEY_QLOAD         18
+#define MYKEY_FF            19
+#define MYKEY_EXIT          20
+#define MYKEY_MENU_ONION    21
+#define MYKEY_POWER         22
+#define MYKEY_VOLUP         23
+#define MYKEY_VOLDOWN       24
+
+
+#define MYKEY_LAST_BITS     21// ignore POWER, VOL-, VOL+ keys
+#endif
 
 #define MMIYOO_KEYPAD_MODE 0
 #define MMIYOO_MOUSE_MODE  1
@@ -70,6 +104,13 @@ typedef struct _MMIYOO_EventInfo {
     } mouse;
 
     int mode;
+    
+    // by trngaje
+    int analogstick_left_x;
+    int analogstick_left_y;
+    int analogstick_right_x;
+    int analogstick_right_y;
+	int pen_display_cnt;
 } MMIYOO_EventInfo;
 
 extern void MMIYOO_EventInit(void);
diff --git a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c
index 9a9967d..39d112d 100644
--- a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c
+++ b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c
@@ -85,6 +85,10 @@ static volatile int is_running = 0;
 static int need_reload_bg = RELOAD_BG_COUNT;
 static SDL_Surface *cvt = NULL;
 
+//extern scale_mat_NEON(const Uint32 *src, int src_w, int src_h, int src_pitch, Uint32 *dst, int dst_w, int dst_h, int dst_pitch);
+extern scale_mat(const Uint32 *src, int src_w, int src_h, int src_pitch,
+          Uint32 *dst, int dst_w, int dst_h, int dst_pitch);
+		  
 extern MMIYOO_EventInfo evt;
 
 static int MMIYOO_VideoInit(_THIS);
@@ -104,7 +108,7 @@ int need_restore = 0;
 int pre_dismode = 0;
 #endif
 
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
 GLfloat bgVertices[] = {
    -1.0f,  1.0f,  0.0f,  0.0f,  0.0f,
    -1.0f, -1.0f,  0.0f,  0.0f,  1.0f,
@@ -120,6 +124,56 @@ GLfloat vVertices[] = {
 };
 GLushort indices[] = {0, 1, 2, 0, 2, 3};
 
+#ifdef RG35XXH_GL
+const char *vShaderSrc =
+    "attribute vec4 a_position;   \n"
+    "attribute vec2 a_texCoord;   \n"
+    "varying vec2 v_texCoord;     \n"
+    "void main()                  \n"
+    "{                            \n"
+    "   gl_Position = a_position; \n"
+    "   v_texCoord = a_texCoord;  \n"
+    "}                            \n";
+	
+const char *vShaderDegree90Src =
+    "attribute vec4 a_position;   \n"
+    "attribute vec2 a_texCoord;   \n"
+    "attribute float a_alpha;     \n"
+    "varying vec2 v_texCoord;     \n"
+    "void main()                  \n"
+    "{                            \n"
+    "    const float angle = 90.0 * (3.1415 * 2.0) / 360.0;                                                                            \n"
+    "    mat4 rot = mat4(cos(angle), -sin(angle), 0.0, 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0); \n"
+    "    gl_Position = a_position * rot; \n"
+    "    v_texCoord = a_texCoord;        \n"
+    "}                                   \n";
+	
+const char *vShaderDegree180Src =
+    "attribute vec4 a_position;   \n"
+    "attribute vec2 a_texCoord;   \n"
+    "attribute float a_alpha;     \n"
+    "varying vec2 v_texCoord;     \n"
+    "void main()                  \n"
+    "{                            \n"
+    "    const float angle = 180.0 * (3.1415 * 2.0) / 360.0;                                                                            \n"
+    "    mat4 rot = mat4(cos(angle), -sin(angle), 0.0, 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0); \n"
+    "    gl_Position = a_position * rot; \n"
+    "    v_texCoord = a_texCoord;        \n"
+    "}                                   \n";
+	
+const char *vShaderDegree270Src =
+    "attribute vec4 a_position;   \n"
+    "attribute vec2 a_texCoord;   \n"
+    "attribute float a_alpha;     \n"
+    "varying vec2 v_texCoord;     \n"
+    "void main()                  \n"
+    "{                            \n"
+    "    const float angle = 270.0 * (3.1415 * 2.0) / 360.0;                                                                            \n"
+    "    mat4 rot = mat4(cos(angle), -sin(angle), 0.0, 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0); \n"
+    "    gl_Position = a_position * rot; \n"
+    "    v_texCoord = a_texCoord;        \n"
+    "}                                   \n";
+#else
 const char *vShaderSrc =
     "attribute vec4 a_position;   \n"
     "attribute vec2 a_texCoord;   \n"
@@ -132,6 +186,7 @@ const char *vShaderSrc =
     "    gl_Position = a_position * rot; \n"
     "    v_texCoord = a_texCoord;        \n"
     "}                                   \n";
+#endif
     
 const char *fShaderSrc =
     "precision mediump float;                                  \n"
@@ -153,6 +208,7 @@ const char *fShaderSrc =
     "    }                                                     \n"
     "}                                                         \n";
 
+#ifndef RG35XXH_GL
 static struct _cpu_clock cpu_clock[] = {
     {96, 0x80000110},
     {144, 0x80000120},
@@ -224,6 +280,7 @@ static struct _cpu_clock cpu_clock[] = {
 
 static int max_cpu_item = sizeof(cpu_clock) / sizeof(struct _cpu_clock);
 #endif
+#endif
 
 #ifdef QX1000
 static struct _wayland wl = {0};
@@ -685,7 +742,7 @@ static int draw_drastic_menu_main(void)
         p = &drastic_menu.item[cc];
         if (p->y == 201) {
             draw = 1;
-#if defined(MMIYOO) || defined(TRIMUI) || defined(A30)
+#if defined(MMIYOO) || defined(TRIMUI) || defined(A30) || defined(RG35XXH)
             sprintf(buf, "NDS %s", &p->msg[8]);
 #else
             sprintf(buf, "%s", &p->msg[8]);
@@ -769,7 +826,7 @@ static int draw_drastic_menu_main(void)
     }
 
     y = 10;
-#ifdef A30
+#if defined(A30) || defined(RG35XXH)
     sprintf(buf, "Rel "NDS_VER" Res %s", "640*480");
 #endif
 
@@ -818,7 +875,7 @@ static int draw_drastic_menu_main(void)
             _func((void*)VAR_SYSTEM, slot, top, bottom, 1);
             t = SDL_CreateRGBSurfaceFrom(top, NDS_W, NDS_H, 16, NDS_W * 2, 0, 0, 0, 0);
             if (t) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                 rt.x = FB_W - (NDS_W + (nds.enable_752x560 ? 30 : 10));
                 rt.y = nds.enable_752x560 ? h - 20 : 50;
                 rt.w = NDS_W;
@@ -830,7 +887,7 @@ static int draw_drastic_menu_main(void)
 
             t = SDL_CreateRGBSurfaceFrom(bottom, NDS_W, NDS_H, 16, NDS_W * 2, 0, 0, 0, 0);
             if (t) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                 rt.x = FB_W - (NDS_W + (nds.enable_752x560 ? 30 : 10));
                 rt.y = nds.enable_752x560 ? (h + NDS_H) - 20 : 50 + NDS_H;
                 rt.w = NDS_W;
@@ -1501,7 +1558,7 @@ int process_drastic_menu(void)
         memset(&drastic_menu, 0, sizeof(drastic_menu));
         return 0;
     }
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
     nds.update_menu = 1;
 #else
     GFX_Copy(-1, nds.menu.drastic.main->pixels, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->pitch, 0, E_MI_GFX_ROTATE_180);
@@ -1526,21 +1583,30 @@ static int process_screen(void)
     static int pre_dis_mode = NDS_DIS_MODE_VH_S0;
     static int pre_hres_mode = NDS_DIS_MODE_HRES0;
     static char show_info_buf[MAX_PATH << 1] = {0};
-
+    int swap_screens;
+    
     int idx = 0;
     int screen_cnt = 0;
     char buf[MAX_PATH] = {0};
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
     int cur_sel = gfx.lcd.cur_sel ^ 1;
 #endif
 
-#if defined(MMIYOO) || defined(PANDORA) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(PANDORA) || defined(QX1000) || defined(A30) || defined(RG35XXH)
     screen_cnt = 2;
 #else
     screen_cnt = 1;
 #endif
 
+#ifdef RG35XXH
+    vid.window = (SDL_Window *)(*((uint32_t *)VAR_SDL_SCREEN_WINDOW));
+#endif
+
+    swap_screens = (uint32_t *)(*((uint32_t *)VAR_SDL_SWAP_SCREENS));
+    //printf(PREFIX"swap_screens=%d\n", swap_screens);
+
+     
     if (nds.auto_state > 0) {
         if (need_loadstate > 0) {
             need_loadstate-= 1;
@@ -1669,7 +1735,7 @@ static int process_screen(void)
             *((uint8_t *)VAR_SDL_SCREEN1_HRES_MODE):
             *((uint8_t *)VAR_SDL_SCREEN0_HRES_MODE);
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
         nds.screen.pixels[idx] = gfx.lcd.virAddr[cur_sel][idx];
 #else
         nds.screen.pixels[idx] = (idx == 0) ?
@@ -1677,6 +1743,10 @@ static int process_screen(void)
             (uint32_t *)(*((uint32_t *)VAR_SDL_SCREEN1_PIXELS));
 #endif
 
+        screen0 = (idx == 0);
+        screen1 = (idx != 0);
+        show_pen = nds.pen.pos ? screen1 : screen0;
+            
         if (nds.screen.hres_mode[idx]) {
             srt.w = NDS_Wx2;
             srt.h = NDS_Hx2;
@@ -1697,9 +1767,7 @@ static int process_screen(void)
             nds.screen.pitch[idx] = nds.screen.bpp * srt.w;
 
             drt.y = idx * 120;
-            screen0 = (idx == 0);
-            screen1 = (idx != 0);
-            show_pen = nds.pen.pos ? screen1 : screen0;
+
             if (nds.hres_mode == 1) {
                 nds.hres_mode = 0;
                 pre_hres_mode = nds.dis_mode;
@@ -1713,7 +1781,140 @@ static int process_screen(void)
 #if defined(QX1000)
 #elif defined(TRIMUI)
 #elif defined(PANDORA)
-#elif defined(MMIYOO) || defined(A30)
+#elif defined(RG35XXH) && !defined(RG35XXH_GL) //trngaje
+
+       switch (nds.dis_mode) {
+        case NDS_DIS_MODE_VH_T0:
+            if (screen0) {
+                drt.x = 0;
+                drt.y = 0;
+                drt.w = FB_W;
+                drt.h = FB_H;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_VH_T1:
+            if (screen0) {
+                drt.x = 0;
+                drt.y = 0;
+                drt.w = FB_W;
+                drt.h = FB_H;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_S0:
+            if (screen0) {
+                drt.w = NDS_W * 2;
+                drt.h = NDS_H * 2;
+                drt.x = (FB_W - drt.w) / 2;
+                drt.y = (FB_H - drt.h) / 2;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_S1:
+            if (screen0) {
+                drt.x = 0;
+                drt.y = 0;
+                drt.w = FB_W;
+                drt.h = FB_H;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_V0:
+            drt.w = NDS_W;
+            drt.h = NDS_H;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = screen0? 48 : 48 + drt.h;
+
+            break;
+        case NDS_DIS_MODE_V1:
+			drt.w = 320;
+			drt.h = 240;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = screen0 ? 0 : drt.h;
+            break;
+        case NDS_DIS_MODE_H0:
+            drt.w = NDS_W;
+            drt.h = NDS_H;
+            drt.x = screen0 ? 64 : 64 + drt.w;
+            drt.y = (FB_H - drt.h) / 2;
+            break;
+        case NDS_DIS_MODE_H1:
+			drt.w = 320;
+			drt.h = 240;
+			drt.x = screen0 ? 0 : drt.w;
+            drt.y = (FB_H - drt.h) / 2;
+            break;
+        case NDS_DIS_MODE_VH_S0:
+            drt.x = screen1 ? FB_W -160 : 0;
+            drt.y = screen1 ? FB_H-120 : 0;
+            drt.w = screen1 ? 160:(FB_W - 160);
+            drt.h = screen1 ? 120:(FB_H - 120) ;
+            break;
+        case NDS_DIS_MODE_VH_S1:
+            drt.x = screen0 ? 0:FB_W - NDS_W ;
+            drt.y = screen0 ? 0:FB_H - NDS_H ;
+            drt.w = screen0 ? (FB_W - NDS_W) : NDS_W;
+            drt.h = screen0 ? (FB_H - NDS_H) : NDS_H;
+            break;
+       case NDS_DIS_MODE_VH_S2:
+            drt.w = screen0 ? (FB_W - 160) : 160;
+            drt.h = screen0 ? (FB_H - 120):120;
+            drt.x = screen0 ? ((FB_W - drt.w) / 2) : ((FB_W - drt.w) / 2);
+            drt.y = screen0 ? 0:FB_H-120;
+            break;
+        case NDS_DIS_MODE_VH_C0:
+            drt.w = screen0 ?  (FB_W - NDS_W):NDS_W;
+            drt.h = screen0 ?  (FB_H - NDS_H):NDS_H;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = screen0 ?  0:FB_H - NDS_H;
+            break;
+        case NDS_DIS_MODE_VH_C1:
+            drt.w = screen0 ? (FB_W - NDS_W): NDS_W;
+            drt.h = screen0? (FB_H - NDS_H):NDS_H ;
+            drt.x = screen0 ? 0 : FB_W - NDS_W;
+            drt.y = screen0? ((FB_H - drt.h) / 2) : ((FB_H - drt.h) / 2);
+            break;
+        case NDS_DIS_MODE_HH0:
+			drt.x = screen0 ? 320 : 0;
+			drt.y = 26;
+			drt.w = 427;
+			drt.h = 320;
+            rotate = E_MI_GFX_ROTATE_270 ; /* not used  */
+            break;
+        case NDS_DIS_MODE_HH1:
+			drt.x = screen0 ? 0:320 ;
+			drt.y = 26;
+			drt.w = 427;
+			drt.h = 320;
+            rotate = E_MI_GFX_ROTATE_90 ;/* not used  */
+            break;
+        case NDS_DIS_MODE_HRES0:
+            drt.w = NDS_Wx2;
+            drt.h = NDS_Hx2;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = (FB_H - drt.h) / 2;
+            break;
+        case NDS_DIS_MODE_HRES1:
+            drt.x = 0;
+            drt.y = 0;
+            drt.w = FB_W;
+            drt.h = FB_H;
+            break;
+        }
+#elif defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
         switch (nds.dis_mode) {
         case NDS_DIS_MODE_VH_T0:
             if (screen1) {
@@ -1721,11 +1922,11 @@ static int process_screen(void)
                 drt.y = 0;
                 drt.w = FB_W;
                 drt.h = FB_H;
-                show_pen = 1;
+                //show_pen = 1;
                 nds.pen.pos = 1;
             }
             else {
-                show_pen = 0;
+                //show_pen = 0;
                 need_update = 0;
             }
             break;
@@ -1735,11 +1936,11 @@ static int process_screen(void)
                 drt.y = 0;
                 drt.w = FB_W;
                 drt.h = FB_H;
-                show_pen = 1;
+                //show_pen = 1;
                 nds.pen.pos = 1;
             }
             else {
-                show_pen = 0;
+                //show_pen = 0;
                 need_update = 0;
             }
             break;
@@ -1749,11 +1950,11 @@ static int process_screen(void)
                 drt.h = NDS_H * 2;
                 drt.x = (FB_W - drt.w) / 2;
                 drt.y = (FB_H - drt.h) / 2;
-                show_pen = 1;
+                //show_pen = 1;
                 nds.pen.pos = 1;
             }
             else {
-                show_pen = 0;
+                //show_pen = 0;
                 need_update = 0;
             }
             break;
@@ -1763,11 +1964,11 @@ static int process_screen(void)
                 drt.y = 0;
                 drt.w = FB_W;
                 drt.h = FB_H;
-                show_pen = 1;
+                //show_pen = 1;
                 nds.pen.pos = 1;
             }
             else {
-                show_pen = 0;
+                //show_pen = 0;
                 need_update = 0;
             }
             break;
@@ -1881,17 +2082,33 @@ static int process_screen(void)
         printf(PREFIX"Unsupported platform\n");
         return 0;
 #endif
-
-#ifdef A30
+	nds.pen.pos = swap_screens ^ 1; // trngaje;
+	
+#if defined(A30) || defined(RG35XXH_GL)
         if (rotate == E_MI_GFX_ROTATE_180) {
             drt.y = (DEF_FB_H - drt.y) - drt.h;
             drt.x = (DEF_FB_W - drt.x) - drt.w;
         }
+#ifdef RG35XXH_GL
+        else if (rotate == E_MI_GFX_ROTATE_270) {
+#else        
         else if (rotate == E_MI_GFX_ROTATE_90) {
+#endif
             drt.x = (drt.x == 0) ? 320 : 0;
         }
-
+#if defined(RG35XXH)
+        if ((evt.mode == MMIYOO_MOUSE_MODE || evt.pen_display_cnt > 0) && show_pen) {
+            if (evt.pen_display_cnt > 0) {
+                evt.pen_display_cnt--;
+            }  
+#else
         if (show_pen && ((evt.mode == MMIYOO_MOUSE_MODE) || (nds.joy.show_cnt && (nds.joy.mode == MYJOY_MODE_MOUSE)))) {
+#endif
+#elif defined(RG35XXH)
+        if ((evt.mode == MMIYOO_MOUSE_MODE || evt.pen_display_cnt > 0) && show_pen) {
+            if (evt.pen_display_cnt > 0) {
+                evt.pen_display_cnt--;
+            }           
 #else
         if (show_pen && (evt.mode == MMIYOO_MOUSE_MODE)) {
 #endif
@@ -1904,7 +2121,7 @@ static int process_screen(void)
 #endif
         }
 
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
         if ((idx == 0) && (nds.alpha.border > 0) && ((nds.dis_mode == NDS_DIS_MODE_VH_T0) || (nds.dis_mode == NDS_DIS_MODE_VH_T1))) {
             int c0 = 0;
             uint32_t *p0 = NULL;
@@ -1945,20 +2162,73 @@ static int process_screen(void)
             MI_SYS_FlushInvCache(nds.screen.pixels[idx], nds.screen.pitch[idx] * srt.h);
 #endif
 
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
             GFX_Copy(idx, nds.screen.pixels[idx], srt, drt, nds.screen.pitch[idx], 0, rotate);
 #else
             GFX_Copy(-1, nds.screen.pixels[idx], srt, drt, nds.screen.pitch[idx], 0, rotate);
 #endif
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(RG35XXH) && ! defined(RG35XXH_GL)
+            switch (nds.dis_mode) {
+            case NDS_DIS_MODE_VH_T0:
+                drt.y = 0;
+                drt.w = 160;
+                drt.h = 120;
+                drt.x = FB_W - drt.w;	
+		switch (nds.alpha.pos % 4) {
+		case 2:
+		    drt.x = 0;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 3:
+		    drt.x = FB_W - drt.w;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 0:
+		    drt.x = FB_W - drt.w;
+		    drt.y = 0;
+		    break;
+		case 1:
+		    drt.x = 0;
+		    drt.y = 0;
+		    break;
+		}			
+                GFX_Copy(-1, nds.screen.pixels[1], srt, drt, nds.screen.pitch[1], 1, rotate);
+                break;
+            case NDS_DIS_MODE_VH_T1:
+                drt.y = 0;
+                drt.w = NDS_W;
+                drt.h = NDS_H;
+                drt.x = FB_W - drt.w;
+		switch (nds.alpha.pos % 4) {
+		case 2:
+		    drt.x = 0;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 3:
+		    drt.x = FB_W - drt.w;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 0:
+		    drt.x = FB_W - drt.w;
+		    drt.y = 0;
+		    break;
+		case 1:
+		    drt.x = 0;
+		    drt.y = 0;
+		    break;
+		}			
+                GFX_Copy(-1, nds.screen.pixels[1], srt, drt, nds.screen.pitch[1], 1, rotate);
+                break;
+            }
+#elif defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
             switch (nds.dis_mode) {
             case NDS_DIS_MODE_VH_T0:
                 drt.x = 0;
                 drt.y = 0;
                 drt.w = 160;
                 drt.h = 120;
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
                 switch (nds.alpha.pos) {
                 case 0:
                     drt.x = DEF_FB_W - drt.w;
@@ -1987,7 +2257,7 @@ static int process_screen(void)
                 drt.y = 0;
                 drt.w = NDS_W;
                 drt.h = NDS_H;
-#ifdef A30
+#if defined(A30) || defined(RG35XXH)
                 switch (nds.alpha.pos) {
                 case 0:
                     drt.x = DEF_FB_W - drt.w;
@@ -2063,11 +2333,11 @@ void sdl_update_screen(void)
         prepare_time -= 1;
     }
     else if (nds.update_screen == 0) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
         gfx.lcd.cur_sel ^= 1;
         *((uint32_t *)VAR_SDL_SCREEN0_PIXELS) = (uint32_t)gfx.lcd.virAddr[gfx.lcd.cur_sel][0];
         *((uint32_t *)VAR_SDL_SCREEN1_PIXELS) = (uint32_t)gfx.lcd.virAddr[gfx.lcd.cur_sel][1];
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
         nds.menu.drastic.enable = 0;
 #endif
 #endif
@@ -2184,7 +2454,7 @@ static void strip_newline(char *p)
 
 static void *video_handler(void *threadid)
 {
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
     EGLint egl_major = 0;
     EGLint egl_minor = 0;
     EGLint num_configs = 0;
@@ -2214,7 +2484,20 @@ static void *video_handler(void *threadid)
     eglMakeCurrent(vid.eglDisplay, vid.eglSurface, vid.eglSurface, vid.eglContext);
   
     vid.vShader = glCreateShader(GL_VERTEX_SHADER);
-    glShaderSource(vid.vShader, 1, &vShaderSrc, NULL);
+
+#ifdef RG35XXH_GL	
+	if (nds.display.rotate == 90)
+		 glShaderSource(vid.vShader, 1, &vShaderDegree90Src, NULL);
+	else if (nds.display.rotate == 180)
+		 glShaderSource(vid.vShader, 1, &vShaderDegree180Src, NULL);
+	else if (nds.display.rotate == 270)
+		 glShaderSource(vid.vShader, 1, &vShaderDegree270Src, NULL);
+	else
+		glShaderSource(vid.vShader, 1, &vShaderSrc, NULL);
+#else
+	glShaderSource(vid.vShader, 1, &vShaderSrc, NULL);
+#endif
+
     glCompileShader(vid.vShader);
   
     vid.fShader = glCreateShader(GL_FRAGMENT_SHADER);
@@ -2235,7 +2518,14 @@ static void *video_handler(void *threadid)
 
     glGenTextures(TEX_MAX, vid.texID);
 
+#ifdef RG35XXH_GL
+	if (nds.display.rotate == 90 || nds.display.rotate == 270)
+		glViewport(0, 0, DEF_FB_H, DEF_FB_W);
+	else 
+		glViewport(0, 0, DEF_FB_W, DEF_FB_H);
+#else
     glViewport(0, 0, DEF_FB_H, DEF_FB_W);
+#endif
     glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
     glClear(GL_COLOR_BUFFER_BIT);
 
@@ -2256,7 +2546,7 @@ static void *video_handler(void *threadid)
 #endif
 
     while (is_running) {
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
         if (nds.menu.enable) {
             if (nds.update_menu) {
                 nds.update_menu = 0;
@@ -2284,7 +2574,7 @@ static void *video_handler(void *threadid)
         }
     }
 
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
     glDeleteTextures(TEX_MAX, vid.texID);
     eglMakeCurrent(vid.eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
     eglDestroyContext(vid.eglDisplay, vid.eglContext);
@@ -2397,6 +2687,17 @@ static int read_config(void)
     struct json_object *jval = NULL;
     struct json_object *jfile = NULL;
 
+#ifdef RG35XXH
+	const char mykey_name[NUM_OF_MYKEY][20]= {
+        "up", "down", "left", "right", "a", "b", "x", "y", "l1", "r1", 
+        "l2", "r2", "l3", "r3","select", "start", "menu", "qsave", "qload", "ff", 
+		"exit", "menu_onion"
+    };
+	
+	char full_mykey_name[100];
+	int i;
+#endif
+
     jfile = json_object_from_file(nds.cfg.path);
     if (jfile == NULL) {
         printf(PREFIX"Failed to read settings from json file (%s)\n", nds.cfg.path);
@@ -2565,7 +2866,7 @@ static int read_config(void)
         nds.fast_forward = json_object_get_int(jval);
     }
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     json_object_object_get_ex(jfile, JSON_NDS_STATES, &jval);
     if (jval) {
         struct stat st = {0};
@@ -2595,10 +2896,35 @@ static int read_config(void)
             nds.menu.sel = 0;
         }
     }
+	
+#ifdef RG35XXH
+	json_object_object_get_ex(jfile, "input_dev", &jval);
+	if (jval) {
+        const char *dev = json_object_get_string(jval);
+
+        strcpy(nds.input.dev, dev);		
+	}
+
+	for (i=0; i< NUM_OF_MYKEY; i++) {
+		sprintf(full_mykey_name, "input_%s", mykey_name[i]);
+		json_object_object_get_ex(jfile, full_mykey_name, &jval);
+		if (jval)
+			nds.input.key[i] = json_object_get_int(jval);
+		else
+			nds.input.key[i] =  -1; // not defined
+	}
+	
+	json_object_object_get_ex(jfile, "display_rotate", &jval);
+	if (jval)
+		nds.display.rotate = json_object_get_int(jval);
+	else 
+		nds.display.rotate = 0;
+#endif	
+	
     reload_menu();
 
     reload_pen();
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     reload_overlay();
 #endif
     json_object_put(jfile);
@@ -2609,9 +2935,11 @@ static int read_config(void)
         close(fd);
 #endif
 
+#ifndef RG35XXH
 #ifndef A30
         snd_nds_reload_config();
 #endif
+#endif
 
 #if defined(TRIMUI) || defined(PANDORA) || defined(A30)
     }
@@ -3021,6 +3349,88 @@ int fb_quit(void)
 }
 #endif
 
+#if  defined(RG35XXH) //&& !defined(RG35XXH_GL)
+int fb_init(void)
+{
+#ifdef RG35XXH_GL
+    gfx.fb_dev = open("/dev/fb0", O_RDWR, 0);
+    if (gfx.fb_dev < 0) {
+        printf(PREFIX"Failed to open /dev/fb0\n");
+        return -1;
+    }
+
+    if (ioctl(gfx.fb_dev, FBIOGET_VSCREENINFO, &gfx.vinfo) < 0) {
+        printf(PREFIX"Failed to get fb info\n");
+        return -1;
+    }
+
+    gfx.fb.virAddr = mmap(NULL, FB_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, gfx.fb_dev, 0);
+    if (gfx.fb.virAddr == (void *)-1) {
+        close(gfx.fb_dev);
+        gfx.fb_dev = -1;
+        printf(PREFIX"Failed to mmap fb\n");
+        return -1;
+    }
+    printf(PREFIX"FB virAddr %p (size:%d)\n", gfx.fb.virAddr, FB_SIZE);
+    memset(gfx.fb.virAddr, 0 , FB_SIZE);
+
+    gfx.vinfo.yres_virtual = gfx.vinfo.yres * 2;
+    ioctl(gfx.fb_dev, FBIOPUT_VSCREENINFO, &gfx.vinfo);
+
+#else
+    gfx.fb_dev = open("/dev/fb0", O_RDWR);
+    if (gfx.fb_dev < 0) {
+        printf(PREFIX"Failed to open fb0\n");
+        return -1;
+    }
+
+    ioctl(gfx.fb_dev, FBIOGET_FSCREENINFO, &gfx.finfo);
+    ioctl(gfx.fb_dev, FBIOGET_VSCREENINFO, &gfx.vinfo);
+    gfx.vinfo.yoffset = 0;
+    gfx.vinfo.yres_virtual = gfx.vinfo.yres * 2;
+    ioctl(gfx.fb_dev, FBIOPUT_VSCREENINFO, &gfx.vinfo);
+    
+    gfx.hw.mem = mmap(NULL, FB_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, gfx.fb_dev, 0);
+    if (gfx.hw.mem == (void *)-1) {
+        close(gfx.fb_dev);
+        printf(PREFIX"Failed to mmap fb0\n");
+        return -1;
+    }
+    memset(gfx.hw.mem, 0 , FB_SIZE);
+	
+    gfx.hw.swsurface = SDL_CreateRGBSurface(SDL_SWSURFACE, FB_W, FB_H, 32, 0, 0, 0, 0);
+#endif
+    return 0;
+}
+
+int fb_quit(void)
+{
+#ifdef RG35XXH_GL
+    if (gfx.fb.virAddr) {
+        munmap(gfx.fb.virAddr, FB_SIZE);
+        gfx.fb.virAddr = NULL;
+    }
+
+    if (gfx.fb_dev > 0) {
+        close(gfx.fb_dev);
+        gfx.fb_dev = -1;
+    }
+#else
+    if (gfx.hw.swsurface != NULL)
+        SDL_FreeSurface(gfx.hw.swsurface);
+
+    gfx.vinfo.yoffset = 0;
+    ioctl(gfx.fb_dev, FBIOPUT_VSCREENINFO, &gfx.vinfo);
+    
+    munmap(gfx.hw.mem, FB_SIZE);
+    close(gfx.fb_dev);
+    gfx.fb_dev = -1;
+    
+#endif
+    return 0;
+}
+#endif
+
 #ifdef TRIMUI
 static int ion_alloc(int ion_fd, ion_alloc_info_t* info)
 {
@@ -3254,12 +3664,12 @@ int fb_init(void)
 {
     gfx.fb_dev = open("/dev/fb0", O_RDWR, 0);
     if (gfx.fb_dev < 0) {
-        printf(PREFIX"Failed to open framebuffer device\n");
+        printf(PREFIX"Failed to open /dev/fb0\n");
         return -1;
     }
 
     if (ioctl(gfx.fb_dev, FBIOGET_VSCREENINFO, &gfx.vinfo) < 0) {
-        printf(PREFIX"Failed to get framebuffer information\n");
+        printf(PREFIX"Failed to get fb info\n");
         return -1;
     }
 
@@ -3267,7 +3677,7 @@ int fb_init(void)
     if (gfx.fb.virAddr == (void *)-1) {
         close(gfx.fb_dev);
         gfx.fb_dev = -1;
-        printf(PREFIX"Failed to mmap /dev/fb0\n");
+        printf(PREFIX"Failed to mmap fb\n");
         return -1;
     }
     printf(PREFIX"FB virAddr %p (size:%d)\n", gfx.fb.virAddr, FB_SIZE);
@@ -3692,10 +4102,14 @@ int draw_pen(void *pixels, int width, int pitch)
 
 int GFX_Copy(int id, const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int pitch, int alpha, int rotate)
 {
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
     int tex = (id >= 0) ? id : TEX_TMP;
 
+#ifdef RG35XXH_GL
+    if ((id != -1) && (nds.dis_mode == NDS_DIS_MODE_HH0)) {
+#else
     if ((id != -1) && (nds.dis_mode == NDS_DIS_MODE_HH1)) {
+#endif
         vVertices[5] = ((((float)dstrect.x) / 640.0) - 0.5) * 2.0;
         vVertices[6] = ((((float)dstrect.y) / 480.0) - 0.5) * -2.0;
 
@@ -3708,7 +4122,11 @@ int GFX_Copy(int id, const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int
         vVertices[0] = vVertices[15];
         vVertices[1] = vVertices[6];
     }
+#ifdef RG35XXH_GL
+    else if ((id != -1) && (nds.dis_mode == NDS_DIS_MODE_HH1)) {
+#else    
     else if ((id != -1) && (nds.dis_mode == NDS_DIS_MODE_HH0)) {
+#endif
         vVertices[15] = ((((float)dstrect.x) / 640.0) - 0.5) * 2.0;
         vVertices[16] = ((((float)dstrect.y) / 480.0) - 0.5) * -2.0;
 
@@ -4174,6 +4592,88 @@ int GFX_Copy(int id, const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int
         }
     }
 #endif
+#ifdef RG35XXH 
+#ifndef RG35XXH_GL
+{
+    int x = 0;
+    int y = 0;
+    const uint32_t *src = pixels;
+    //uint32_t *dst = (uint32_t *)gfx.hw.mem;
+	uint32_t *dst = (uint32_t *)gfx.hw.swsurface->pixels;
+
+	if (src != 0) {		
+		if (srcrect.w == NDS_W) {
+			if (nds.dis_mode == NDS_DIS_MODE_HH0 ||  nds.dis_mode == NDS_DIS_MODE_HH1) {
+				SDL_Surface *t = NULL;
+				t = SDL_CreateRGBSurface(SDL_SWSURFACE, NDS_H, NDS_W, 32, 0, 0, 0, 0);
+				if (nds.dis_mode == NDS_DIS_MODE_HH0) {
+					// degree 90
+					int row, col;
+
+					for (row = 0; row < srcrect.h; ++row) { 
+						src = (uint32_t *)pixels + (row * NDS_W); 
+						dst = (uint32_t *)t->pixels + (NDS_H - row - 1) ; 
+						for (col = 0; col < srcrect.w; ++col) { 
+							*dst = *src;
+							src ++; 
+							dst += NDS_H; 
+						}  
+					}  
+				}
+				else  {
+					// degree 270
+					int row, col;
+					for (row = 0; row < srcrect.h; ++row) { 
+						src = (uint32_t *)pixels + (row * NDS_W); 
+						dst = (uint32_t *)t->pixels + row + ((NDS_W-1)* NDS_H) ; 
+						for (col = 0; col < srcrect.w; ++col) { 
+							*dst = *src;
+							src ++; 
+							dst -= NDS_H; 
+						}  
+					}  				
+				}
+				
+				dst = (uint32_t *)gfx.hw.swsurface->pixels + dstrect.y  * FB_W + dstrect.x;
+				
+				scale_mat_NEON((uint32_t *)t->pixels, srcrect.h, srcrect.w, srcrect.h*4, 
+													   dst, dstrect.h, dstrect.w, FB_W*4); 
+				//scale_mat((uint32_t *)t->pixels, srcrect.h, srcrect.w, srcrect.h*4, 
+				//									   dst, dstrect.w, dstrect.h, FB_W*4); 			
+				SDL_FreeSurface(t);
+			}
+			else {
+				// degree 0 only
+				dst += dstrect.y  * FB_W + dstrect.x;
+				
+				scale_mat_NEON((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+													   dst, dstrect.w, dstrect.h, FB_W*4); 
+				//scale_mat((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+				//                                       dst, dstrect.w, dstrect.h, FB_W*4); 
+			}
+		}
+		else {
+			dst += dstrect.y  * FB_W + dstrect.x;
+			if (srcrect.w  == dstrect.w && srcrect.h == dstrect.h) {
+				for (y = 0; y < srcrect.h; y++) {
+					for (x = 0; x < srcrect.w; x++) {
+						*dst++ = *src++;
+					}
+					dst+= (FB_W - srcrect.w);
+				}
+			}
+			else {
+				scale_mat_NEON((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+													   dst, dstrect.w, dstrect.h, FB_W*4); 
+				//scale_mat((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+				//                                       dst, dstrect.w, dstrect.h, FB_W*4); 				
+			}
+	  }
+	}
+
+}
+#endif
+#endif
 
 #ifdef TRIMUI
     int x = 0;
@@ -4899,7 +5399,7 @@ void GFX_Flip(void)
     gfx.vinfo.yoffset ^= FB_H;
 #endif
 
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
     eglSwapBuffers(vid.eglDisplay, vid.eglSurface);
 
     if (nds.theme.img) {
@@ -4924,6 +5424,21 @@ void GFX_Flip(void)
     ioctl(gfx.fb_dev, FBIO_WAITFORVSYNC, &r);
     gfx.fb.flip^= 1;
 #endif
+
+#ifdef RG35XXH
+#ifndef RG35XXH_GL
+	//neon_memcpy(gfx.hw.mem, gfx.hw.swsurface->pixels, FB_W * FB_H * 4); 
+    uint32_t *src = gfx.hw.swsurface->pixels;
+    uint32_t *dst = (uint32_t *)gfx.hw.mem;
+    int x, y;
+	
+	for (y = 0; y < FB_H; y++) {
+		for (x = 0; x < FB_W; x++) {
+			*dst++ = *src++;
+		}
+	}
+#endif
+#endif
 }
 
 int get_font_width(const char *info)
@@ -5046,7 +5561,7 @@ int reload_pen(void)
         if (get_file_path(nds.pen.path, nds.pen.sel, buf, 1) == 0) {
             t = IMG_Load(buf);
             if (t) {
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
                 int x = 0;
                 int y = 0;
                 uint32_t *p = malloc(t->pitch * t->h);
@@ -5137,7 +5652,7 @@ int reload_menu(void)
         SDL_FreeSurface(t);
     }
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     sprintf(buf, "%s/%s", folder, DRASTIC_MENU_CURSOR_FILE);
     nds.menu.drastic.cursor = IMG_Load(buf);
 #endif
@@ -5149,7 +5664,7 @@ int reload_menu(void)
     sprintf(buf, "%s/%s", folder, DRASTIC_MENU_YES_FILE);
     t = IMG_Load(buf);
     if (t) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         SDL_Rect nrt = {0, 0, LINE_H - 2, LINE_H - 2};
 #endif
 #if defined(TRIMUI) || defined(PANDORA)
@@ -5168,7 +5683,7 @@ int reload_menu(void)
     sprintf(buf, "%s/%s", folder, DRASTIC_MENU_NO_FILE);
     t = IMG_Load(buf);
     if (t) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         SDL_Rect nrt = {0, 0, LINE_H - 2, LINE_H - 2};
 #endif
 #if defined(TRIMUI) || defined(PANDORA)
@@ -5197,7 +5712,7 @@ int reload_bg(void)
     static int pre_mode = -1;
 #endif
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     char buf[MAX_PATH] = {0};
     SDL_Surface *t = NULL;
     SDL_Rect srt = {0, 0, IMG_W, IMG_H};
@@ -5274,7 +5789,13 @@ int reload_bg(void)
                     if (t) {
                         SDL_BlitSurface(t, NULL, nds.theme.img, NULL);
                         SDL_FreeSurface(t);
-#ifndef A30
+#if defined(A30) || defined(RG35XXH_GL)
+		        glBindTexture(GL_TEXTURE_2D, vid.texID[TEX_BG]);
+		        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+		        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, nds.theme.img->w, nds.theme.img->h, 0, GL_RGBA, GL_UNSIGNED_BYTE, nds.theme.img->pixels);
+#else
                         GFX_Copy(-1, nds.theme.img->pixels, nds.theme.img->clip_rect, drt, nds.theme.img->pitch, 0, E_MI_GFX_ROTATE_180);
 #endif
                     }
@@ -5286,14 +5807,14 @@ int reload_bg(void)
         }
         else {
             if (nds.theme.img) {
-#ifndef A30
-                GFX_Copy(-1, nds.theme.img->pixels, nds.theme.img->clip_rect, drt, nds.theme.img->pitch, 0, E_MI_GFX_ROTATE_180);
-#else
+#if defined(A30) || defined(RG35XXH_GL)
                 glBindTexture(GL_TEXTURE_2D, vid.texID[TEX_BG]);
                 glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
                 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
                 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
                 glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, nds.theme.img->w, nds.theme.img->h, 0, GL_RGBA, GL_UNSIGNED_BYTE, nds.theme.img->pixels);
+#else
+                GFX_Copy(-1, nds.theme.img->pixels, nds.theme.img->clip_rect, drt, nds.theme.img->pitch, 0, E_MI_GFX_ROTATE_180);
 #endif
             }
         }
@@ -5421,7 +5942,7 @@ int reload_bg(void)
     return 0;
 }
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
 int reload_overlay(void)
 {
     static int pre_sel = -1;
@@ -5528,7 +6049,7 @@ VideoBootStrap MMIYOO_bootstrap = {MMIYOO_DRIVER_NAME, "MMIYOO VIDEO DRIVER", MM
 
 int MMIYOO_VideoInit(_THIS)
 {
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(RG35XXH)
     FILE *fd = NULL;
     char buf[MAX_PATH] = {0};
 #endif
@@ -5541,6 +6062,14 @@ int MMIYOO_VideoInit(_THIS)
     signal(SIGTERM, sigterm_handler);
 #endif
 
+#if defined(RG35XXH)
+    SDL_zero(mode);
+    mode.format = SDL_PIXELFORMAT_ARGB8888;
+    mode.w = 640;
+    mode.h = 480;
+    mode.refresh_rate = 60;
+    SDL_AddDisplayMode(&display, &mode);
+#else
     SDL_zero(mode);
     mode.format = SDL_PIXELFORMAT_RGB565;
     mode.w = 800;
@@ -5595,6 +6124,7 @@ int MMIYOO_VideoInit(_THIS)
     mode.h = 272;
     mode.refresh_rate = 60;
     SDL_AddDisplayMode(&display, &mode);
+#endif
     SDL_AddVideoDisplay(&display, SDL_FALSE);
 
     LINE_H = 30;
@@ -5739,7 +6269,7 @@ void MMIYOO_VideoQuit(_THIS)
     lang_unload();
 }
 
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
 static const char *DIS_MODE0_640[] = {
     "640*480",
     "640*480",
@@ -6391,7 +6921,7 @@ int handle_menu(int key)
         case MENU_OVERLAY:
             if (nds.overlay.sel < nds.overlay.max) {
                 get_file_path(nds.overlay.path, nds.overlay.sel, buf, 0);
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                 reload_overlay();
 #endif
             }
@@ -6795,7 +7325,7 @@ int handle_menu(int key)
         }
     }
 
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
     nds.update_menu = 1;
 #else
     GFX_Copy(-1, cvt->pixels, cvt->clip_rect, cvt->clip_rect, cvt->pitch, 0, E_MI_GFX_ROTATE_180);
diff --git a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h
index 7397fd2..dd98449 100644
--- a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h
+++ b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h
@@ -32,7 +32,7 @@
 #include <linux/omapfb.h>
 #endif
 
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
 #include <EGL/egl.h>
 #include <GLES2/gl2.h>
 #endif
@@ -51,7 +51,7 @@
 #include "SDL_events.h"
 #include "SDL_video.h"
 #include "SDL_mouse.h"
-#include "SDL_video_mmiyoo.h"
+//#include "SDL_video_mmiyoo.h"
 #include "SDL_event_mmiyoo.h"
 
 #include "detour.h"
@@ -148,6 +148,16 @@
     #define MAX_PATH                128
 #endif
 
+#ifdef RG35XXH
+    #define DEF_FB_W                640
+    #define DEF_FB_H                480
+    #define FB_BPP                  4
+    #define IMG_W                   640
+    #define IMG_H                   480
+    #define SCREEN_DMA_SIZE         (NDS_Wx2 * NDS_Hx2 * 4)
+    #define RELOAD_BG_COUNT         1
+#endif
+
 #ifdef A30
     #define DEF_FB_W                640
     #define DEF_FB_H                480
@@ -226,7 +236,7 @@
 #define PEN_CP                      4
 #define FONT_PATH                   "resources/font/font.ttf"
 
-#if defined(MMIYOO) || defined(A30) || defined(PANDORA) || defined(QX1000)
+#if defined(MMIYOO) || defined(A30) || defined(PANDORA) || defined(QX1000) || defined(RG35XXH)
     #define DEF_FONT_SIZE           24
 #endif
 
@@ -334,10 +344,21 @@ enum _TEX_TYPE {
 };
 #endif
 
+#ifdef RG35XXH_GL
+enum _TEX_TYPE {
+    TEX_SCR0 = 0,
+    TEX_SCR1,
+    TEX_BG,
+    TEX_PEN,
+    TEX_TMP,
+    TEX_MAX
+};
+#endif
+
 typedef struct MMIYOO_VideoInfo {
     SDL_Window *window;
 
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
     EGLConfig eglConfig;
     EGLDisplay eglDisplay;
     EGLContext eglContext;
@@ -378,7 +399,7 @@ typedef struct _GFX {
     struct fb_fix_screeninfo finfo;
 
     struct {
-#ifdef A30
+#if defined(A30) || defined(RG35XXH_GL)
         void *virAddr;
 #endif
 
@@ -392,7 +413,7 @@ typedef struct _GFX {
 #endif
     } fb, tmp, overlay;
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
     struct {
         int cur_sel;
         void *virAddr[2][2];
@@ -418,6 +439,12 @@ typedef struct _GFX {
         ion_alloc_info_t ion;
 #endif
 
+#ifdef RG35XXH
+        uint32_t *mem;
+		SDL_Surface *swsurface;
+#endif
+
+
 #ifdef PANDORA
         uint32_t *mem[2];
 #endif
@@ -548,6 +575,17 @@ typedef struct _NDS {
         int show_cnt;
     } joy;
 #endif
+
+#ifdef RG35XXH
+    struct _INPUT {
+	    char dev[20]; /* ex) /dev/input/event0 */
+		int key[NUM_OF_MYKEY];
+	} input;
+	
+	struct _DISPLAY {
+		int rotate; // 0, 90, 180, 270
+	} display;
+#endif
 } NDS;
 
 typedef struct _CUST_MENU_SUB {
