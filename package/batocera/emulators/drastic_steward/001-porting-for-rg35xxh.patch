diff --git a/Makefile.mk b/Makefile.mk
index 9cf2df5..3f40f76 100644
--- a/Makefile.mk
+++ b/Makefile.mk
@@ -23,18 +23,18 @@ REL_VER  = $(shell git rev-parse HEAD | cut -c 1-8)
 
 .PHONY: all
 all:
-	make -C loader MOD=$(MOD)
+#	make -C loader MOD=$(MOD)
 	make -C detour MOD=$(MOD)
 	cp detour/libdtr.so drastic/libs/
-	make -C alsa MOD=$(MOD)
-	cp alsa/libasound.so.2 drastic/libs/
+#	make -C alsa MOD=$(MOD)
+#	cp alsa/libasound.so.2 drastic/libs/
 	make -C sdl2 -j4
 	cp sdl2/build/.libs/libSDL2-2.0.so.0 drastic/libs/
-	make -C unittest $(MOD)
+#	make -C unittest $(MOD)
 
 .PHONY: cfg
 cfg:
-	cp -a assets/$(MOD)/* drastic/
+#	cp -a assets/$(MOD)/* drastic/
 	cd sdl2 && ./autogen.sh && MOD=$(MOD) ./configure $(SDL2_CFG) --host=$(HOST)
 
 .PHONY: rel
diff --git a/detour/Makefile b/detour/Makefile
index 7d5bc20..fadccb5 100644
--- a/detour/Makefile
+++ b/detour/Makefile
@@ -16,6 +16,12 @@ ifeq ($(MOD),mmiyoo)
     LDFLAGS+= -L../mmiyoo/lib -lmi_common -lmi_sys -lmi_gfx -lmi_ao
 endif
 
+ifeq ($(MOD),rg35xxh)
+    CFLAGS += -DRG35XXH -I../mmiyoo/inc
+    CFLAGS += -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3 -Wl,--no-undefined
+    LDFLAGS+= -ljson-c
+endif
+
 ifeq ($(MOD),trimui)
     CFLAGS += -DTRIMUI -I../trimui/inc
     CFLAGS += -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3 -Wl,--no-undefined
diff --git a/detour/main.c b/detour/main.c
index 565bf12..9452c99 100644
--- a/detour/main.c
+++ b/detour/main.c
@@ -33,7 +33,7 @@ static int32_t dtr_load_state_index(void *system, uint32_t index, uint16_t *snap
     char buf[255] = {0};
     nds_load_state _func = (nds_load_state)FUN_LOAD_STATE;
 
-    sprintf(buf, "%s/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, index);
+    sprintf(buf, "%s/savestates/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, index);
     _func((void*)VAR_SYSTEM, buf, snapshot_top, snapshot_bottom, snapshot_only);
 }
 
@@ -42,7 +42,7 @@ static int32_t dtr_save_state_index(void *system, uint32_t index, uint16_t *snap
     char buf[255] = {0};
     nds_save_state _func1 = (nds_save_state)FUN_SAVE_STATE;
 
-    sprintf(buf, "%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, index);
+    sprintf(buf, "savestates/%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, index);
     _func1((void*)VAR_SYSTEM, states_path, buf, snapshot_top, snapshot_bottom);
 }
 
@@ -66,7 +66,7 @@ static void dtr_initialize_backup(backup_struct *backup, backup_type_enum backup
     if (path != NULL) {
         data_file_name = malloc(255);
         memset(data_file_name, 0, 255);
-        sprintf(data_file_name, "%s/%s.dsv", states_path, VAR_SYSTEM_GAMECARD_NAME);
+        sprintf(data_file_name, "%s/backup/%s.dsv", states_path, VAR_SYSTEM_GAMECARD_NAME);
     }
     backup->type = backup_type;
     backup->address_mask = size - 1;
@@ -152,7 +152,7 @@ LAB_08092f94:
 
 int dtr_savestate(int slot)
 {
-#if defined(MMIYOO) || defined(QX1000)
+#if defined(MMIYOO) || defined(QX1000) || defined(RG35XXH)
     char buf[255] = {0};
     nds_screen_copy16 _func0 = (nds_screen_copy16)FUN_SCREEN_COPY16;
 
@@ -171,7 +171,7 @@ int dtr_savestate(int slot)
         else {
             nds_save_state _func1 = (nds_save_state)FUN_SAVE_STATE;
 
-            sprintf(buf, "%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, slot);
+            sprintf(buf, "savestates/%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, slot);
             _func1((void*)VAR_SYSTEM, states_path, buf, d0, d1);
         }
     }
@@ -206,7 +206,7 @@ int dtr_savestate(int slot)
 
 int dtr_loadstate(int slot)
 {
-#if defined(MMIYOO) || defined(QX1000)
+#if defined(MMIYOO) || defined(QX1000) || defined(RG35XXH)
     char buf[255] = {0};
 
     if (is_hooked == 0) {
@@ -217,7 +217,7 @@ int dtr_loadstate(int slot)
     else {
         nds_load_state _func = (nds_load_state)FUN_LOAD_STATE;
 
-        sprintf(buf, "%s/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, slot);
+        sprintf(buf, "%s/savestates/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, slot);
         _func((void*)VAR_SYSTEM, buf, 0, 0, 0);
     }
 #endif
diff --git a/drastic/resources/lang/korean_kr b/drastic/resources/lang/korean_kr
new file mode 100644
index 0000000..9dc31c9
--- /dev/null
+++ b/drastic/resources/lang/korean_kr
@@ -0,0 +1,108 @@
+CPU=CPU
+Overlay=오버레이
+Display=화면
+Alpha=알파값 
+Border=테두리
+Position=위치
+Alt. Display=대체 화면
+Volume=소리 크기
+Disabled=비활성화
+Touchpad=터치패드
+Wallpaper=바탕화면
+Quick Save=빠른 저장하기
+Quick Load=빠른 불러오기
+Fast Forward=빠르게 플레이
+Top-Right=우측 상단
+Top-Left=좌측 상단
+Bottom-Left=좌측 하단
+Bottom-Right=우측 하단
+White=흰색
+Red=붉은색
+Green=녹색
+Blue=파란색
+Black=검정색
+Yellow=노란색
+Cyan=하늘색
+Version=버젼
+Change Options=옵션 변경
+Configure Controls=입력 설정
+Configure Firmware=펌웨어 설정
+Configure Cheats=치트 설정
+Load state=상태 불러오기
+Save state=상태 저장하기
+Load new game=새로운 게임 불러오기
+Restart game=게임 재 시작하기
+Return to game=게임으로 돌아가기
+Exit DraStic=DraStic 끝내기
+Keys=키
+Frame skip type=프레임 스킵 타입
+automatic=자동
+manual=수동
+yes=네
+no=아니오
+Yes=네
+No=아니오
+none=없음
+None=없음
+Frame skip value=프레임 스킵 값
+Screen orientation=화면 회전
+vertical=수직
+horizontal=수평
+single=단일
+Screen swap=화면 교환
+Show speed=표시 속도
+Enable sound=소리 활성화
+Fast forward=빠른 진행
+Mirror touchscreen=터치스크린 반전
+Compress savestates=savestates 압축하기
+Snapshot in savestates=Snapshot in savestates
+Enable cheats=치트 활성화
+Uncompress ROMs=ROMs 압축 풀기
+Backup in savestates=savestates 백업하기
+Speed override=Speed override
+Fix main 2D screen=Fix main 2D screen
+Disable edge marking=edge marking 비활성화
+High-resolution 3D=고해상도 3D
+Threaded 3D=Threaded 3D
+Delete game-specific config=게임 지정 설정 값 제거
+Exit: save for all games=끝내기: 모든게임을 위한 설정 값 저장
+Exit: save for this game=끝내기: 에 게임에만 설정 값 저장
+Exit without saving=저장 없이 끝내기
+Username=사용자 이름
+Language=언어
+Favorite Color=좋아하는 색
+Birthday Month=태어난 달
+Birthday Day=태어난 날
+English=영어
+French=프랑스어
+German=독일어
+Italian=이탈리아어
+Spanish=스페인어
+Chinese=중국어
+Japanese=일본어
+January=1월
+February=2월
+March=3월
+April=4월
+May=5월
+June=6월
+July=7월
+August=8월
+September=9월
+October=10월
+November=11월
+December=12월
+Extra Controls=기타 제어
+Restore default controls=기본 설정값으로 복구
+Unmapped=설정 안함
+Hotkey=핫키
+Swap L1-L2=L1과 L2 교환
+Swap R1-R2=R1과 R2 교환
+Mode=모드
+Pen X Speed=펜 X축 속도
+Pen Y Speed=펜 Y축 속도
+Pixel=펙셀
+Blur=블러
+Cursor=커서
+Show=표시
+Hide=감추기
diff --git a/drastic/resources/settings.json b/drastic/resources/settings.json
index 087baba..2b514ba 100644
--- a/drastic/resources/settings.json
+++ b/drastic/resources/settings.json
@@ -24,7 +24,7 @@
   "half_vol":0,
   "splash":3,
   "hotkey":0,
-  "states":"",
+  "states":"\/userdata\/saves\/nds\/drastic",
   "menu_bg":0,
   "menu_cursor":1,
   "fast_forward":6
diff --git a/sdl2/configure.ac b/sdl2/configure.ac
index d99f07e..87a6bdb 100644
--- a/sdl2/configure.ac
+++ b/sdl2/configure.ac
@@ -2424,6 +2424,21 @@ CheckMMiyooVideo()
     fi
 }
 
+CheckRG35XXHVideo()
+{
+    if test x$enable_video = xyes; then
+        AC_DEFINE(SDL_VIDEO_DRIVER_MMIYOO, 1, [ ])
+        AC_DEFINE(SDL_VIDEO_RENDER_MMIYOO, 1, [ ])
+        SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c $srcdir/src/video/mmiyoo/*.S"
+        have_video=yes
+        
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -DRG35XXH -fPIC -mcpu=cortex-a7 -mfpu=neon-vfpv4  -O3 -I../mmiyoo/inc -I../detour -I/%SDL2%"
+        EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L. -lEGL -lGLESv2 -lrt -lSDL2_image -lSDL2_ttf -ljson-c -L../detour -ldtr"
+        SUMMARY_video="${SUMMARY_video} mmiyoo"
+    fi
+}
+
+
 CheckTrimuiVideo()
 {
     if test x$enable_video = xyes; then
@@ -2504,6 +2519,20 @@ CheckMMiyooAudio()
     fi
 }
 
+CheckRG35XXHAudio()
+{
+    if test x$enable_audio = xyes; then
+        AC_DEFINE(SDL_AUDIO_DRIVER_MMIYOO, 1, [ ])
+        SOURCES="$SOURCES $srcdir/src/audio/mmiyoo/*.c"
+        have_audio=yes
+        if test x$HOST = xarm-linux; then
+            EXTRA_CFLAGS="$EXTRA_CFLAGS -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L../mmiyoo/lib  -l:libasound.so.2"
+        fi
+        SUMMARY_audio="${SUMMARY_audio} mmiyoo"
+    fi
+}
+
 CheckTrimuiAudio()
 {
     if test x$enable_audio = xyes; then
@@ -3847,6 +3876,9 @@ case "$host" in
             *mmiyoo*)           ARCH=mmiyoo
                 CheckMMiyooVideo
                 ;;
+            *rg35xxh*)           ARCH=rg35xxh
+                CheckRG35XXHVideo
+                ;;
             *trimui*)           ARCH=trimui
                 CheckTrimuiVideo
                 ;;
@@ -3978,6 +4010,9 @@ case "$host" in
             mmiyoo)
                 CheckMMiyooAudio
             ;;
+            rg35xxh)
+                CheckRG35XXHAudio
+            ;;
             trimui)
                 CheckTrimuiAudio
             ;;
@@ -4015,7 +4050,7 @@ case "$host" in
                 SOURCES="$SOURCES $srcdir/src/joystick/steam/*.c"
                 have_joystick=yes
             ;;
-            a30|mmiyoo|trimui|pandora|unittest)
+            a30|mmiyoo|rg35xxh|trimui|pandora|unittest)
                 AC_DEFINE(SDL_JOYSTICK_MMIYOO, 1, [ ])
                 SOURCES="$SOURCES $srcdir/src/joystick/mmiyoo/*.c"
                 have_joystick=yes
diff --git a/sdl2/src/video/SDL_stretch.c b/sdl2/src/video/SDL_stretch.c
index dad3eb5..d608a2e 100644
--- a/sdl2/src/video/SDL_stretch.c
+++ b/sdl2/src/video/SDL_stretch.c
@@ -296,7 +296,7 @@ INTERPOL_BILINEAR(const Uint32 *s0, const Uint32 *s1, int frac_w0, int frac_h0,
     INTERPOL(tmp,   tmp + 1, frac_w0, frac_w1, dst);
 }
 
-static int
+int
 scale_mat(const Uint32 *src, int src_w, int src_h, int src_pitch,
           Uint32 *dst, int dst_w, int dst_h, int dst_pitch)
 {
@@ -595,7 +595,7 @@ INTERPOL_BILINEAR_NEON(const Uint32 *s0, const Uint32 *s1, int frac_w, uint8x8_t
     *dst = vget_lane_u32(CAST_uint32x2_t e0, 0);
 }
 
-static int
+int
 scale_mat_NEON(const Uint32 *src, int src_w, int src_h, int src_pitch, Uint32 *dst, int dst_w, int dst_h, int dst_pitch)
 {
     BILINEAR___START
diff --git a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c
index 9543922..7fa1370 100644
--- a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c
+++ b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c
@@ -42,10 +42,57 @@
     #define INPUT_DEV "/dev/input/event4"
 #elif defined(QX1000) || defined(A30)
     #define INPUT_DEV "/dev/input/event3"
+#elif defined(RG35XXH)
+    #define INPUT_DEV "/dev/input/event1" /* RG35XXH */
+//    #define INPUT_DEV "/dev/input/event2" /* RG35XXH evmapy*/
 #else
     #define INPUT_DEV "/dev/input/event0"
 #endif
 
+#ifdef RG35XXH
+/*
+// for evmapy 
+    #define UP      103
+    #define DOWN    108
+    #define LEFT    105
+    #define RIGHT   106
+    #define A       57
+    #define B       29
+    #define X       42
+    #define Y       56
+    #define L1      18
+    #define L2      15
+    #define R1      20
+    #define R2      14
+    #define START   28
+    #define SELECT  97
+    #define MENU    1
+    #define POWER   116
+    #define VOLUP   115
+    #define VOLDOWN 114
+	*/
+    #define UP      103	/* not defined */
+    #define DOWN    108 /* not defined */
+    #define LEFT    105 /* not defined */
+    #define RIGHT   106 /* not defined */
+    #define A       BTN_SOUTH
+    #define B       BTN_EAST
+    #define X       BTN_NORTH
+    #define Y       BTN_C
+    #define L1      BTN_WEST
+    #define L2      BTN_SELECT
+    #define R1      BTN_Z
+    #define R2      BTN_START
+    #define START   BTN_TR
+    #define SELECT  BTN_TL
+    #define MENU    BTN_TL2
+    #define POWER   116 /* not defined */
+    #define VOLUP   115 /* not defined */
+    #define VOLDOWN 114	/* not defined */
+	#define L3		BTN_TR2
+	#define R3		BTN_MODE
+#endif
+
 #ifdef A30
     #define UP      103
     #define DOWN    108
@@ -254,7 +301,7 @@ static void release_all_keys(void)
 
 static int hit_hotkey(uint32_t bit)
 {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     uint32_t mask = (1 << bit) | (1 << ((nds.hotkey == HOTKEY_BIND_SELECT) ? MYKEY_SELECT : MYKEY_MENU));
 #endif
 
@@ -281,7 +328,7 @@ static void set_key(uint32_t bit, int val)
         }
 #endif
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
         if (nds.hotkey == HOTKEY_BIND_SELECT) {
             if (bit == MYKEY_SELECT) {
                 hotkey = (1 << MYKEY_SELECT);
@@ -306,7 +353,7 @@ int EventUpdate(void *data)
 
     uint32_t l1 = L1;
     uint32_t r1 = R1;
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
     uint32_t l2 = L2;
     uint32_t r2 = R2;
 #endif
@@ -365,7 +412,7 @@ int EventUpdate(void *data)
             y = Y;
         }
 
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         if (nds.swap_l1l2) {
             l1 = L2;
             l2 = L1;
@@ -399,22 +446,330 @@ int EventUpdate(void *data)
 
         if (event_fd > 0) {
             if (read(event_fd, &ev, sizeof(struct input_event))) {
-                if ((ev.type == EV_KEY) && (ev.value != 2)) {
+				if (ev.type == EV_ABS) {
+					if (ev.code == ABS_HAT0X) {
+						 if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0) && nds.keys_rotate) {
+							if (nds.keys_rotate == 1) {
+								// degree 270
+								if (ev.value < 0) { 
+									// up 
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+									set_key(MYKEY_UP,    1); 
+								}  
+								else if (ev.value > 0) { 
+									// down 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+										set_key(MYKEY_UP, 0); 
+									} 
+									set_key(MYKEY_DOWN,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+										set_key(MYKEY_UP, 0); 
+									} 
+
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+								}
+							}
+							else {
+								// degree 90
+								if (ev.value > 0) { 
+									// up 
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+									set_key(MYKEY_UP,    1); 
+								}  
+								else if (ev.value < 0) { 
+									// down 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+										set_key(MYKEY_UP, 0); 
+									} 
+									set_key(MYKEY_DOWN,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+										set_key(MYKEY_UP, 0); 
+									} 
+
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+								} 
+							}
+						 }
+						else {
+							// degree 0
+				
+							if (ev.value < 0) {
+								// left
+								if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+									set_key(MYKEY_RIGHT, 0);
+								}
+								set_key(MYKEY_LEFT,    1); 
+							} 
+							else if (ev.value > 0) {
+								// right
+								if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+									set_key(MYKEY_LEFT, 0);
+								} 
+								set_key(MYKEY_RIGHT,    1); 
+							} 
+							else { 
+								// center 
+								if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+									set_key(MYKEY_LEFT, 0); 
+								} 
+								if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+									set_key(MYKEY_RIGHT, 0); 
+								} 
+							} 
+						}
+					} 
+					else if (ev.code == ABS_HAT0Y) { 
+						if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0) && nds.keys_rotate) {
+							if (nds.keys_rotate == 1) {
+								// degree 270
+								if (ev.value > 0) {
+									// left
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+										set_key(MYKEY_RIGHT, 0);
+									}
+									set_key(MYKEY_LEFT,    1); 
+								} 
+								else if (ev.value < 0) {
+									// right
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+										set_key(MYKEY_LEFT, 0);
+									} 
+									set_key(MYKEY_RIGHT,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+										set_key(MYKEY_LEFT, 0); 
+									} 
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+										set_key(MYKEY_RIGHT, 0); 
+									} 
+								} 
+							}
+							else {
+								// degree 90
+								if (ev.value < 0) {
+									// left
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+										set_key(MYKEY_RIGHT, 0);
+									}
+									set_key(MYKEY_LEFT,    1); 
+								} 
+								else if (ev.value > 0) {
+									// right
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+										set_key(MYKEY_LEFT, 0);
+									} 
+									set_key(MYKEY_RIGHT,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+										set_key(MYKEY_LEFT, 0); 
+									} 
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+										set_key(MYKEY_RIGHT, 0); 
+									} 
+								} 
+							}
+						}
+						else {
+							// degree 0
+							
+							if (ev.value < 0) { 
+								// up 
+								if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+									set_key(MYKEY_DOWN, 0); 
+								} 
+								set_key(MYKEY_UP,    1); 
+							}  
+							else if (ev.value > 0) { 
+								// down 
+								if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+									set_key(MYKEY_UP, 0); 
+								} 
+								set_key(MYKEY_DOWN,    1); 
+							} 
+							else { 
+								// center 
+								if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+									set_key(MYKEY_UP, 0); 
+								} 
+
+								if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+									set_key(MYKEY_DOWN, 0); 
+								} 
+							} 
+						}
+					} 
+					else if (ev.code == ABS_Z) {
+						// left analog x
+						if (ev.value < -100) {
+							// left
+							evt.analogstick_left_x = ev.value / 1024;;
+						}
+						else if (ev.value > 100) {
+							// right
+							evt.analogstick_left_x = ev.value / 1024;;
+						}
+						else {
+							// center 
+							evt.analogstick_left_x = 0;
+						}						
+					}
+					else if (ev.code == ABS_RX) {
+						// left analog y
+						if (ev.value < -100) {
+							// up
+							evt.analogstick_left_y = ev.value / 1024;
+						}
+						else if (ev.value > 100) {
+							// down
+							evt.analogstick_left_y = ev.value / 1024;
+						}
+						else {
+							// center 
+							evt.analogstick_left_y = 0;
+						}		
+					}					
+					else if (ev.code == ABS_RY) {
+						if (nds.dis_mode == NDS_DIS_MODE_HH1) {
+							if (evt.mode == MMIYOO_KEYPAD_MODE) {
+								// right analog x -> dpad
+								// left -> up
+								// right -> down
+								if (ev.value < -100) {
+									// up 
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+									set_key(MYKEY_UP,    1); 							
+								}
+								else if (ev.value > 100) {
+									// down 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+										set_key(MYKEY_UP, 0); 
+									} 
+									set_key(MYKEY_DOWN,    1); 							
+								}
+								else {
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+										set_key(MYKEY_UP, 0); 
+									} 
+
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 							
+								}
+							}
+							else {
+								// right analog x -> touch
+								// left -> up
+								// right -> down
+								if (ev.value < -100) {
+									// up 
+									evt.analogstick_right_y = ev.value / 1024;
+								}
+								else if (ev.value > 100) {
+									// down 
+									evt.analogstick_right_y= ev.value / 1024;
+								}
+								else {
+									// center 
+									evt.analogstick_right_y = 0;
+								}								
+							}
+						}
+					}
+					else if (ev.code ==  ABS_RZ) {
+						if (nds.dis_mode == NDS_DIS_MODE_HH1) {
+							if (evt.mode == MMIYOO_KEYPAD_MODE) {
+								// right analog y to dpad
+								// down ->left
+								// up -> right
+								if (ev.value < -100) {
+									// right
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+										set_key(MYKEY_LEFT, 0);
+									} 
+									set_key(MYKEY_RIGHT,    1); 					
+								}
+								else if (ev.value > 100) {
+									// left
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+										set_key(MYKEY_RIGHT, 0);
+									}
+									set_key(MYKEY_LEFT,    1); 									
+								}
+								else {
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+										set_key(MYKEY_LEFT, 0); 
+									} 
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+										set_key(MYKEY_RIGHT, 0); 
+									} 							
+								}
+							}
+							else {
+								// right analog y to touch
+								// down ->left
+								// up -> right
+								if (ev.value < -100) {
+									// up 
+									evt.analogstick_right_x= ev.value  *  (-1) / 1024;
+								}
+								else if (ev.value > 100) {
+									// down 
+									evt.analogstick_right_x= ev.value  * (-1) / 1024;
+								}
+								else {
+									// center 
+									evt.analogstick_right_x  = 0;
+								}										
+							}
+						}
+					}
+				}
+                else if ((ev.type == EV_KEY) && (ev.value != 2)) {
                     //printf(PREFIX"code:%d, value:%d\n", ev.code, ev.value);
                     if (ev.code == l1)      { set_key(MYKEY_L1,    ev.value); }
                     if (ev.code == r1)      { set_key(MYKEY_R1,    ev.value); }
+#ifndef RG35XXH
                     if (ev.code == up)      { set_key(MYKEY_UP,    ev.value); }
                     if (ev.code == down)    { set_key(MYKEY_DOWN,  ev.value); }
                     if (ev.code == left)    { set_key(MYKEY_LEFT,  ev.value); }
                     if (ev.code == right)   { set_key(MYKEY_RIGHT, ev.value); }
+#endif 
                     if (ev.code == a)       { set_key(MYKEY_A,     ev.value); }
                     if (ev.code == b)       { set_key(MYKEY_B,     ev.value); }
                     if (ev.code == x)       { set_key(MYKEY_X,     ev.value); }
                     if (ev.code == y)       { set_key(MYKEY_Y,     ev.value); }
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
                     if (ev.code == l2)      { set_key(MYKEY_L2,    ev.value); }
                     if (ev.code == r2)      { set_key(MYKEY_R2,    ev.value); }
 #endif
+
+#if defined(RG35XXH)
+                    if (ev.code == L3)      { set_key(MYKEY_L3,    ev.value); }
+                    if (ev.code == R3)      { set_key(MYKEY_R3,    ev.value); }
+#endif
+					
 #ifdef QX1000
                     if (ev.code == L10)     { set_key(MYKEY_L1,    ev.value); }
                     if (ev.code == R10)     { set_key(MYKEY_R1,    ev.value); }
@@ -454,14 +809,14 @@ int EventUpdate(void *data)
                         break;
 #endif
                     }
-
+				}
                     hotkey_mask = 1;
                     if (nds.menu.enable || nds.menu.drastic.enable) {
                         hotkey_mask = 0;
                     }
 
                     if (hotkey_mask && hit_hotkey(MYKEY_UP)) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
                         if (evt.mode == MMIYOO_MOUSE_MODE) {
                             switch (nds.dis_mode) {
                             case NDS_DIS_MODE_VH_T0:
@@ -479,7 +834,7 @@ int EventUpdate(void *data)
                     }
 
                     if (hotkey_mask && hit_hotkey(MYKEY_DOWN)) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
                         if (evt.mode == MMIYOO_MOUSE_MODE) {
                             switch (nds.dis_mode) {
                             case NDS_DIS_MODE_VH_T0:
@@ -497,7 +852,7 @@ int EventUpdate(void *data)
                     }
 
                     if (hotkey_mask && hit_hotkey(MYKEY_LEFT)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                         if (nds.hres_mode == 0) {
                             if (nds.dis_mode > 0) {
                                 nds.dis_mode-= 1;
@@ -522,7 +877,7 @@ int EventUpdate(void *data)
                     }
 
                     if (hotkey_mask && hit_hotkey(MYKEY_RIGHT)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                         if (nds.hres_mode == 0) {
                             if (nds.dis_mode < NDS_DIS_MODE_LAST) {
                                 nds.dis_mode+= 1;
@@ -540,7 +895,7 @@ int EventUpdate(void *data)
                     }
 
                     if (hotkey_mask && hit_hotkey(MYKEY_A)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                         if ((evt.mode == MMIYOO_KEYPAD_MODE) && (nds.hres_mode == 0)) {
                             uint32_t tmp = nds.alt_mode;
                             nds.alt_mode = nds.dis_mode;
@@ -640,7 +995,7 @@ int EventUpdate(void *data)
                     }
 
                     if (hotkey_mask && hit_hotkey(MYKEY_START)) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
                         if (nds.menu.enable == 0) {
 #ifdef QX1000
                             update_wayland_res(640, 480);
@@ -659,7 +1014,7 @@ int EventUpdate(void *data)
                         set_key(MYKEY_START, 0);
                     }
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                     if (nds.hotkey == HOTKEY_BIND_MENU) {
                         if (hotkey_mask && hit_hotkey(MYKEY_SELECT)) {
                             set_key(MYKEY_MENU_ONION, 1);
@@ -676,7 +1031,7 @@ int EventUpdate(void *data)
 #endif
 
                     if (hotkey_mask && hit_hotkey(MYKEY_R1)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                         static int pre_ff = 0;
 
                         if (pre_ff != nds.fast_forward) {
@@ -693,7 +1048,7 @@ int EventUpdate(void *data)
                     }
 
                     if (hotkey_mask && hit_hotkey(MYKEY_L1)) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                         set_key(MYKEY_EXIT, 1);
 #endif
 
@@ -703,7 +1058,7 @@ int EventUpdate(void *data)
                         set_key(MYKEY_L1, 0);
                     }
 
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
                     if (hotkey_mask && hit_hotkey(MYKEY_R2)) {
                         set_key(MYKEY_QSAVE, 1);
                         set_key(MYKEY_R2, 0);
@@ -730,7 +1085,6 @@ int EventUpdate(void *data)
                 if (!(evt.keypad.bitmaps & 0x0f)) {
                     nds.pen.pre_ticks = clock();
                 }
-            }
         }
         SDL_SemPost(event_sem);
         usleep(1000000 / 60);
@@ -741,7 +1095,7 @@ int EventUpdate(void *data)
 
 void MMIYOO_EventInit(void)
 {
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(RG35XXH)
     DIR *dir = NULL;
 #endif
 
@@ -830,7 +1184,7 @@ void MMIYOO_PumpEvents(_THIS)
 {
     SDL_SemWait(event_sem);
     if (nds.menu.enable) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         int cc = 0;
         uint32_t bit = 0;
         uint32_t changed = pre_keypad_bitmaps ^ evt.keypad.bitmaps;
@@ -856,7 +1210,7 @@ void MMIYOO_PumpEvents(_THIS)
                 for (cc=0; cc<=MYKEY_LAST_BITS; cc++) {
                     bit = 1 << cc;
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                     if ((nds.hotkey == HOTKEY_BIND_MENU) && (cc == MYKEY_MENU)) {
                         continue;
                     }
@@ -872,6 +1226,12 @@ void MMIYOO_PumpEvents(_THIS)
                         SDL_SendKeyboardKey((evt.keypad.bitmaps & bit) ? SDL_PRESSED : SDL_RELEASED, SDL_GetScancodeFromKey(code[cc]));
                     }
                 }
+				
+#ifdef RG35XXH
+				if (changed & (1 << MYKEY_R3)) {
+                    SDL_SendMouseButton(vid.window, 0, (evt.keypad.bitmaps & (1 << MYKEY_R3)) ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_LEFT);
+                }
+#endif
 
 #if defined(TRIMUI) || defined(PANDORA)
                 if (pre_keypad_bitmaps & (1 << MYKEY_R2)) {
@@ -914,6 +1274,12 @@ void MMIYOO_PumpEvents(_THIS)
                     SDL_SendMouseButton(vid.window, 0, (evt.keypad.bitmaps & (1 << MYKEY_A)) ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_LEFT);
                 }
 
+#ifdef RG35XXH
+				if (changed & (1 << MYKEY_R3)) {
+                    SDL_SendMouseButton(vid.window, 0, (evt.keypad.bitmaps & (1 << MYKEY_R3)) ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_LEFT);
+                }
+#endif
+
                 for (cc=0; cc<=MYKEY_LAST_BITS; cc++) {
                     bit = 1 << cc;
                     if ((cc == MYKEY_FF) || (cc == MYKEY_QSAVE) || (cc == MYKEY_QLOAD) || (cc == MYKEY_EXIT) || (cc == MYKEY_R2)) {
@@ -965,15 +1331,16 @@ void MMIYOO_PumpEvents(_THIS)
                     evt.mouse.x+= get_move_interval(0);
                 }
             }
+			
             check_mouse_pos();
 
             if(updated){
                 int x = 0;
                 int y = 0;
-
-                x = (evt.mouse.x * 160) / evt.mouse.maxx;
-                y = (evt.mouse.y * 120) / evt.mouse.maxy;
-                SDL_SendMouseMotion(vid.window, 0, 0, x + 80, y + (nds.pen.pos ? 120 : 0));
+	   
+                x = (evt.mouse.x * 320) / evt.mouse.maxx;
+                y = (evt.mouse.y * 240) / evt.mouse.maxy;
+               SDL_SendMouseMotion(vid.window, 0, 0, x + 160, y + (nds.pen.pos ? 240 : 0));
             }
 
 #if defined(TRIMUI) || defined(PANDORA)
@@ -999,6 +1366,48 @@ void MMIYOO_PumpEvents(_THIS)
             pre_keypad_bitmaps = evt.keypad.bitmaps;
         }
     }
+	
+
+	{
+		// check left analog stick	
+		 int updated = 0;
+		 if (evt.analogstick_left_y != 0) {
+			updated = 1;
+			evt.mouse.y+= evt.analogstick_left_y;
+			evt.pen_display_cnt = 180;
+		}
+
+		if (evt.analogstick_left_x != 0) {
+			updated = 1;
+			evt.mouse.x+= evt.analogstick_left_x;
+			evt.pen_display_cnt = 180;
+		}
+
+		// check right analog stick	
+		 if (evt.analogstick_right_y != 0) {
+			updated = 1;
+			evt.mouse.y+= evt.analogstick_right_y;
+			evt.pen_display_cnt = 180;
+		}
+
+		if (evt.analogstick_right_x != 0) {
+			updated = 1;
+			evt.mouse.x+= evt.analogstick_right_x;
+			evt.pen_display_cnt = 180;
+		}
+		
+		check_mouse_pos();
+
+		if(updated){
+			int x = 0;
+			int y = 0;
+
+			x = (evt.mouse.x * 320) / evt.mouse.maxx;
+			y = (evt.mouse.y * 240) / evt.mouse.maxy;
+		   SDL_SendMouseMotion(vid.window, 0, 0, x + 160, y + (nds.pen.pos ? 240 : 0));
+		}	
+	}
+	
     SDL_SemPost(event_sem);
 }
 
diff --git a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h
index 86a7c03..cb03399 100644
--- a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h
+++ b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h
@@ -51,6 +51,8 @@
 #define MYKEY_POWER         20
 #define MYKEY_VOLUP         21
 #define MYKEY_VOLDOWN       22
+#define MYKEY_L3       23
+#define MYKEY_R3       24
 
 #define MYKEY_LAST_BITS     19 // ignore POWER, VOL-, VOL+ keys
 
@@ -70,6 +72,13 @@ typedef struct _MMIYOO_EventInfo {
     } mouse;
 
     int mode;
+    
+    // by trngaje
+    int analogstick_left_x;
+    int analogstick_left_y;
+    int analogstick_right_x;
+    int analogstick_right_y;
+	int pen_display_cnt;
 } MMIYOO_EventInfo;
 
 extern void MMIYOO_EventInit(void);
diff --git a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c
index e9ae232..42df8e7 100644
--- a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c
+++ b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c
@@ -90,6 +90,10 @@ static int is_running = 0;
 static int need_reload_bg = RELOAD_BG_COUNT;
 static SDL_Surface *cvt = NULL;
 
+//extern scale_mat_NEON(const Uint32 *src, int src_w, int src_h, int src_pitch, Uint32 *dst, int dst_w, int dst_h, int dst_pitch);
+extern scale_mat(const Uint32 *src, int src_w, int src_h, int src_pitch,
+          Uint32 *dst, int dst_w, int dst_h, int dst_pitch);
+		  
 extern MMIYOO_EventInfo evt;
 extern EGLConfig eglConfig;
 extern EGLDisplay eglDisplay;
@@ -559,7 +563,7 @@ static int draw_drastic_menu_main(void)
         p = &drastic_menu.item[cc];
         if (p->y == 201) {
             draw = 1;
-#if defined(MMIYOO) || defined(TRIMUI) || defined(A30)
+#if defined(MMIYOO) || defined(TRIMUI) || defined(A30) || defined(RG35XXH)
             sprintf(buf, "NDS %s", &p->msg[8]);
 #else
             sprintf(buf, "%s", &p->msg[8]);
@@ -643,7 +647,7 @@ static int draw_drastic_menu_main(void)
     }
 
     y = 10;
-#ifdef A30
+#if defined(A30) || defined(RG35XXH)
     sprintf(buf, "Rel "NDS_VER" Res %s", "640*480");
 #endif
 
@@ -692,7 +696,7 @@ static int draw_drastic_menu_main(void)
             _func((void*)VAR_SYSTEM, slot, top, bottom, 1);
             t = SDL_CreateRGBSurfaceFrom(top, NDS_W, NDS_H, 16, NDS_W * 2, 0, 0, 0, 0);
             if (t) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                 rt.x = FB_W - (NDS_W + (nds.enable_752x560 ? 30 : 10));
                 rt.y = nds.enable_752x560 ? h - 20 : 50;
                 rt.w = NDS_W;
@@ -704,7 +708,7 @@ static int draw_drastic_menu_main(void)
 
             t = SDL_CreateRGBSurfaceFrom(bottom, NDS_W, NDS_H, 16, NDS_W * 2, 0, 0, 0, 0);
             if (t) {
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                 rt.x = FB_W - (NDS_W + (nds.enable_752x560 ? 30 : 10));
                 rt.y = nds.enable_752x560 ? (h + NDS_H) - 20 : 50 + NDS_H;
                 rt.w = NDS_W;
@@ -1401,12 +1405,16 @@ static int process_screen(void)
     int screen_cnt = 0;
     char buf[MAX_PATH] = {0};
 
-#if defined(MMIYOO) || defined(PANDORA) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(PANDORA) || defined(QX1000) || defined(A30) || defined(RG35XXH)
     screen_cnt = 2;
 #else
     screen_cnt = 1;
 #endif
 
+#ifdef RG35XXH
+    vid.window = (SDL_Window *)(*((uint32_t *)VAR_SDL_SCREEN_WINDOW));
+#endif
+
 #ifdef A30
     vid.window = (SDL_Window *)(*((uint32_t *)VAR_SDL_SCREEN_WINDOW));
     vid.renderer = (SDL_Renderer *)(*((uint32_t *)VAR_SDL_SCREEN_RENDERER));
@@ -1588,6 +1596,138 @@ static int process_screen(void)
 #elif defined(QX1000)
 #elif defined(TRIMUI)
 #elif defined(PANDORA)
+#elif defined(RG35XXH)
+       switch (nds.dis_mode) {
+        case NDS_DIS_MODE_VH_T0:
+            if (screen0) {
+                drt.x = 0;
+                drt.y = 0;
+                drt.w = FB_W;
+                drt.h = FB_H;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_VH_T1:
+            if (screen0) {
+                drt.x = 0;
+                drt.y = 0;
+                drt.w = FB_W;
+                drt.h = FB_H;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_S0:
+            if (screen0) {
+                drt.w = NDS_W * 2;
+                drt.h = NDS_H * 2;
+                drt.x = (FB_W - drt.w) / 2;
+                drt.y = (FB_H - drt.h) / 2;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_S1:
+            if (screen0) {
+                drt.x = 0;
+                drt.y = 0;
+                drt.w = FB_W;
+                drt.h = FB_H;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_V0:
+            drt.w = NDS_W;
+            drt.h = NDS_H;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = screen0? 48 : 48 + drt.h;
+
+            break;
+        case NDS_DIS_MODE_V1:
+			drt.w = 320;
+			drt.h = 240;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = screen0 ? 0 : drt.h;
+            break;
+        case NDS_DIS_MODE_H0:
+            drt.w = NDS_W;
+            drt.h = NDS_H;
+            drt.x = screen0 ? 64 : 64 + drt.w;
+            drt.y = (FB_H - drt.h) / 2;
+            break;
+        case NDS_DIS_MODE_H1:
+			drt.w = 320;
+			drt.h = 240;
+			drt.x = screen0 ? 0 : drt.w;
+            drt.y = (FB_H - drt.h) / 2;
+            break;
+        case NDS_DIS_MODE_VH_S0:
+            drt.x = screen1 ? FB_W -160 : 0;
+            drt.y = screen1 ? FB_H-120 : 0;
+            drt.w = screen1 ? 160:(FB_W - 160);
+            drt.h = screen1 ? 120:(FB_H - 120) ;
+            break;
+        case NDS_DIS_MODE_VH_S1:
+            drt.x = screen0 ? 0:FB_W - NDS_W ;
+            drt.y = screen0 ? 0:FB_H - NDS_H ;
+            drt.w = screen0 ? (FB_W - NDS_W) : NDS_W;
+            drt.h = screen0 ? (FB_H - NDS_H) : NDS_H;
+            break;
+       case NDS_DIS_MODE_VH_S2:
+            drt.w = screen0 ? (FB_W - 160) : 160;
+            drt.h = screen0 ? (FB_H - 120):120;
+            drt.x = screen0 ? ((FB_W - drt.w) / 2) : ((FB_W - drt.w) / 2);
+            drt.y = screen0 ? 0:FB_H-120;
+            break;
+        case NDS_DIS_MODE_VH_C0:
+            drt.w = screen0 ?  (FB_W - NDS_W):NDS_W;
+            drt.h = screen0 ?  (FB_H - NDS_H):NDS_H;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = screen0 ?  0:FB_H - NDS_H;
+            break;
+        case NDS_DIS_MODE_VH_C1:
+            drt.w = screen0 ? (FB_W - NDS_W): NDS_W;
+            drt.h = screen0? (FB_H - NDS_H):NDS_H ;
+            drt.x = screen0 ? 0 : FB_W - NDS_W;
+            drt.y = screen0? ((FB_H - drt.h) / 2) : ((FB_H - drt.h) / 2);
+            break;
+        case NDS_DIS_MODE_HH0:
+			drt.x = screen0 ? 320 : 0;
+			drt.y = 26;
+			drt.w = 427;
+			drt.h = 320;
+            rotate = E_MI_GFX_ROTATE_270 ; /* not used  */
+            break;
+        case NDS_DIS_MODE_HH1:
+			drt.x = screen0 ? 0:320 ;
+			drt.y = 26;
+			drt.w = 427;
+			drt.h = 320;
+            rotate = E_MI_GFX_ROTATE_90 ;/* not used  */
+            break;
+        case NDS_DIS_MODE_HRES0:
+            drt.w = NDS_Wx2;
+            drt.h = NDS_Hx2;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = (FB_H - drt.h) / 2;
+            break;
+        case NDS_DIS_MODE_HRES1:
+            drt.x = 0;
+            drt.y = 0;
+            drt.w = FB_W;
+            drt.h = FB_H;
+            break;
+        }
 #elif defined(MMIYOO)
         switch (nds.dis_mode) {
         case NDS_DIS_MODE_VH_T0:
@@ -1757,8 +1897,11 @@ static int process_screen(void)
         return 0;
 #endif
 
-        if ((evt.mode == MMIYOO_MOUSE_MODE) && show_pen) {
+        if ((evt.mode == MMIYOO_MOUSE_MODE || evt.pen_display_cnt > 0) && show_pen) {
             draw_pen(nds.screen.pixels[idx], srt.w, nds.screen.pitch[idx]);
+			if (evt.pen_display_cnt > 0) {
+				evt.pen_display_cnt--;
+			}
         }
 
         if (need_update) {
@@ -1768,7 +1911,61 @@ static int process_screen(void)
 
             GFX_Copy(nds.screen.pixels[idx], srt, drt, nds.screen.pitch[idx], 0, rotate);
 
-#if defined(MMIYOO) || defined(A30)
+
+#ifdef RG35XXH
+            switch (nds.dis_mode) {
+            case NDS_DIS_MODE_VH_T0:
+                drt.y = 0;
+                drt.w = 160;
+                drt.h = 120;
+                drt.x = FB_W - drt.w;	
+		switch (nds.alpha.pos % 4) {
+		case 2:
+		    drt.x = 0;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 3:
+		    drt.x = FB_W - drt.w;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 0:
+		    drt.x = FB_W - drt.w;
+		    drt.y = 0;
+		    break;
+		case 1:
+		    drt.x = 0;
+		    drt.y = 0;
+		    break;
+		}			
+                GFX_Copy(nds.screen.pixels[1], srt, drt, nds.screen.pitch[1], 1, rotate);
+                break;
+            case NDS_DIS_MODE_VH_T1:
+                drt.y = 0;
+                drt.w = NDS_W;
+                drt.h = NDS_H;
+                drt.x = FB_W - drt.w;
+		switch (nds.alpha.pos % 4) {
+		case 2:
+		    drt.x = 0;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 3:
+		    drt.x = FB_W - drt.w;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 0:
+		    drt.x = FB_W - drt.w;
+		    drt.y = 0;
+		    break;
+		case 1:
+		    drt.x = 0;
+		    drt.y = 0;
+		    break;
+		}			
+                GFX_Copy(nds.screen.pixels[1], srt, drt, nds.screen.pitch[1], 1, rotate);
+                break;
+            }
+#elif defined(MMIYOO) || defined(A30)
             switch (nds.dis_mode) {
             case NDS_DIS_MODE_VH_T0:
                 drt.x = 0;
@@ -2248,7 +2445,7 @@ static int read_config(void)
         nds.fast_forward = json_object_get_int(jval);
     }
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     json_object_object_get_ex(jfile, JSON_NDS_STATES, &jval);
     if (jval) {
         struct stat st = {0};
@@ -2281,7 +2478,7 @@ static int read_config(void)
     reload_menu();
 
     reload_pen();
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     reload_overlay();
 #endif
     json_object_put(jfile);
@@ -2291,7 +2488,9 @@ static int read_config(void)
     if (fd > 0) {
         close(fd);
 #endif
+#ifndef RG35XXH
         snd_nds_reload_config();
+#endif
 #if defined(TRIMUI) || defined(PANDORA) || defined(A30)
     }
 #endif
@@ -2686,6 +2885,53 @@ int fb_quit(void)
 }
 #endif
 
+#if  defined(RG35XXH)
+int fb_init(void)
+{
+    gfx.fb_dev = open("/dev/fb0", O_RDWR);
+    if (gfx.fb_dev < 0) {
+        printf(PREFIX"Failed to open fb0\n");
+        return -1;
+    }
+
+#ifdef RG35XXH
+    ioctl(gfx.fb_dev, FBIOGET_FSCREENINFO, &gfx.finfo);
+    ioctl(gfx.fb_dev, FBIOGET_VSCREENINFO, &gfx.vinfo);
+    gfx.vinfo.yoffset = 0;
+    gfx.vinfo.yres_virtual = gfx.vinfo.yres * 2;
+    ioctl(gfx.fb_dev, FBIOPUT_VSCREENINFO, &gfx.vinfo);
+#endif
+    
+    gfx.hw.mem = mmap(NULL, FB_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, gfx.fb_dev, 0);
+    if (gfx.hw.mem == (void *)-1) {
+        close(gfx.fb_dev);
+        printf(PREFIX"Failed to mmap fb0\n");
+        return -1;
+    }
+    memset(gfx.hw.mem, 0 , FB_SIZE);
+	
+#ifdef RG35XXH
+	gfx.hw.swsurface = SDL_CreateRGBSurface(SDL_SWSURFACE, FB_W, FB_H, 32, 0, 0, 0, 0);
+#endif
+    return 0;
+}
+
+int fb_quit(void)
+{
+#ifdef RG35XXH
+	if (gfx.hw.swsurface != NULL)
+		SDL_FreeSurface(gfx.hw.swsurface);
+#endif
+    gfx.vinfo.yoffset = 0;
+    ioctl(gfx.fb_dev, FBIOPUT_VSCREENINFO, &gfx.vinfo);
+    
+    munmap(gfx.hw.mem, FB_SIZE);
+    close(gfx.fb_dev);
+    gfx.fb_dev = -1;
+    return 0;
+}
+#endif
+
 #ifdef TRIMUI
 static int ion_alloc(int ion_fd, ion_alloc_info_t* info)
 {
@@ -3625,6 +3871,139 @@ int GFX_Copy(const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int pitch,
         }
     }
 #endif
+#ifdef RG35XXH 
+    int x = 0;
+    int y = 0;
+    const uint32_t *src = pixels;
+    //uint32_t *dst = (uint32_t *)gfx.hw.mem;
+	uint32_t *dst = (uint32_t *)gfx.hw.swsurface->pixels;
+
+	if (src != 0) {		
+		if (srcrect.w == NDS_W) {
+			if (nds.dis_mode == NDS_DIS_MODE_HH0 ||  nds.dis_mode == NDS_DIS_MODE_HH1) {
+				SDL_Surface *t = NULL;
+				t = SDL_CreateRGBSurface(SDL_SWSURFACE, NDS_H, NDS_W, 32, 0, 0, 0, 0);
+				if (nds.dis_mode == NDS_DIS_MODE_HH0) {
+					// degree 90
+					int row, col;
+
+					for (row = 0; row < srcrect.h; ++row) { 
+						src = (uint32_t *)pixels + (row * NDS_W); 
+						dst = (uint32_t *)t->pixels + (NDS_H - row - 1) ; 
+						for (col = 0; col < srcrect.w; ++col) { 
+							*dst = *src;
+							src ++; 
+							dst += NDS_H; 
+						}  
+					}  
+				}
+				else  {
+					// degree 270
+					int row, col;
+					for (row = 0; row < srcrect.h; ++row) { 
+						src = (uint32_t *)pixels + (row * NDS_W); 
+						dst = (uint32_t *)t->pixels + row + ((NDS_W-1)* NDS_H) ; 
+						for (col = 0; col < srcrect.w; ++col) { 
+							*dst = *src;
+							src ++; 
+							dst -= NDS_H; 
+						}  
+					}  				
+				}
+				
+				dst = (uint32_t *)gfx.hw.swsurface->pixels + dstrect.y  * FB_W + dstrect.x;
+				
+				scale_mat_NEON((uint32_t *)t->pixels, srcrect.h, srcrect.w, srcrect.h*4, 
+													   dst, dstrect.h, dstrect.w, FB_W*4); 
+				//scale_mat((uint32_t *)t->pixels, srcrect.h, srcrect.w, srcrect.h*4, 
+				//									   dst, dstrect.w, dstrect.h, FB_W*4); 			
+				SDL_FreeSurface(t);
+			}
+			else {
+				// degree 0 only
+				dst += dstrect.y  * FB_W + dstrect.x;
+				
+				scale_mat_NEON((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+													   dst, dstrect.w, dstrect.h, FB_W*4); 
+				//scale_mat((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+				//                                       dst, dstrect.w, dstrect.h, FB_W*4); 
+			}
+		}
+		else {
+			dst += dstrect.y  * FB_W + dstrect.x;
+			if (srcrect.w  == dstrect.w && srcrect.h == dstrect.h) {
+				for (y = 0; y < srcrect.h; y++) {
+					for (x = 0; x < srcrect.w; x++) {
+						*dst++ = *src++;
+					}
+					dst+= (FB_W - srcrect.w);
+				}
+			}
+			else {
+				scale_mat_NEON((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+													   dst, dstrect.w, dstrect.h, FB_W*4); 
+				//scale_mat((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+				//                                       dst, dstrect.w, dstrect.h, FB_W*4); 				
+			}
+	  }
+	}
+
+
+#endif
+
+#ifdef FUNKEYS
+    if ((srcrect.w == NDS_W) && (srcrect.h == NDS_H)) {
+        uint16_t *dst = (uint16_t *)gfx.hw.mem + (((FB_H - NDS_H) >> 1) * FB_W);
+        uint16_t *src = (uint16_t *)pixels;
+
+        asm volatile (
+            "1:  add %0, #16            ;"
+            "    vldmia %0!, {q0-q7}    ;"
+            "    vldmia %0!, {q8-q14}   ;"
+            "    vstmia %1!, {q0-q7}    ;"
+            "    vstmia %1!, {q8-q14}   ;"
+            "    vldmia %0!, {q0-q7}    ;"
+            "    vldmia %0!, {q8-q14}   ;"
+            "    vstmia %1!, {q0-q7}    ;"
+            "    vstmia %1!, {q8-q14}   ;"
+            "    add %0, #16            ;"
+            "    subs %2, #1            ;"
+            "    bne 1b                 ;"
+            :
+            : "r"(src), "r"(dst), "r"(NDS_H)
+            : "q0", "q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9", "q10", "q11", "q12", "q13", "q14", "memory", "cc"
+        );
+    }
+    else if ((srcrect.w == FB_W) && (srcrect.h == FB_H)) {
+        int x = 0;
+        int y = 0;
+        uint32_t v = 0;
+        uint16_t *dst = (uint16_t *)gfx.hw.mem;
+        uint32_t *src = (uint32_t *)pixels;
+
+        for (y = 0; y < srcrect.h; y++) {
+            for (x = 0; x < srcrect.w; x++) {
+                v = *src++;
+                *dst++ = ((v & 0xf80000) >> 8) | ((v & 0xfc00) >> 5) | ((v & 0xf8) >> 3);
+            }
+        }
+    }
+    else {
+        int x = 0;
+        int y = 0;
+        uint32_t v = 0;
+        uint16_t *dst = (uint16_t *)gfx.hw.mem + (((FB_H - NDS_H) >> 1) * FB_W);
+        uint32_t *src = (uint32_t *)pixels;
+
+        for (y = 0; y < srcrect.h; y++) {
+            for (x = 0; x < srcrect.w; x++) {
+                v = *src++;
+                *dst++ = ((v & 0xf80000) >> 8) | ((v & 0xfc00) >> 5) | ((v & 0xf8) >> 3);
+            }
+            dst+= (FB_W - srcrect.w);
+        }
+    }
+#endif
 
 #ifdef TRIMUI
     int x = 0;
@@ -4359,6 +4738,19 @@ void GFX_Flip(void)
     ioctl(gfx.fb_dev, FBIO_WAITFORVSYNC, &r);
     gfx.fb.flip^= 1;
 #endif
+
+#ifdef RG35XXH
+	//neon_memcpy(gfx.hw.mem, gfx.hw.swsurface->pixels, FB_W * FB_H * 4); 
+    uint32_t *src = gfx.hw.swsurface->pixels;
+    uint32_t *dst = (uint32_t *)gfx.hw.mem;
+    int x, y;
+	
+	for (y = 0; y < FB_H; y++) {
+		for (x = 0; x < FB_W; x++) {
+			*dst++ = *src++;
+		}
+	}
+#endif
 }
 
 int get_font_width(const char *info)
@@ -4548,7 +4940,7 @@ int reload_menu(void)
         SDL_FreeSurface(t);
     }
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     sprintf(buf, "%s/%s", folder, DRASTIC_MENU_CURSOR_FILE);
     nds.menu.drastic.cursor = IMG_Load(buf);
 #endif
@@ -4560,7 +4952,7 @@ int reload_menu(void)
     sprintf(buf, "%s/%s", folder, DRASTIC_MENU_YES_FILE);
     t = IMG_Load(buf);
     if (t) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         SDL_Rect nrt = {0, 0, LINE_H - 2, LINE_H - 2};
 #endif
 #if defined(TRIMUI) || defined(PANDORA)
@@ -4579,7 +4971,7 @@ int reload_menu(void)
     sprintf(buf, "%s/%s", folder, DRASTIC_MENU_NO_FILE);
     t = IMG_Load(buf);
     if (t) {
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         SDL_Rect nrt = {0, 0, LINE_H - 2, LINE_H - 2};
 #endif
 #if defined(TRIMUI) || defined(PANDORA)
@@ -4608,7 +5000,7 @@ int reload_bg(void)
     static int pre_mode = -1;
 #endif
 
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(RG35XXH)
     char buf[MAX_PATH] = {0};
     SDL_Surface *t = NULL;
     SDL_Rect srt = {0, 0, IMG_W, IMG_H};
@@ -4822,7 +5214,7 @@ int reload_bg(void)
     return 0;
 }
 
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
 int reload_overlay(void)
 {
     static int pre_sel = -1;
@@ -4965,7 +5357,7 @@ VideoBootStrap MMIYOO_bootstrap = {MMIYOO_DRIVER_NAME, "MMIYOO VIDEO DRIVER", MM
 
 int MMIYOO_VideoInit(_THIS)
 {
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(RG35XXH)
     FILE *fd = NULL;
     char buf[MAX_PATH] = {0};
 #endif
@@ -4978,13 +5370,20 @@ int MMIYOO_VideoInit(_THIS)
     signal(SIGTERM, sigterm_handler);
 #endif
 
-#ifdef A30
+#if defined(A30)
     SDL_zero(mode);
     mode.format = SDL_PIXELFORMAT_ARGB8888;
     mode.w = REAL_W;
     mode.h = REAL_H;
     mode.refresh_rate = 60;
     SDL_AddDisplayMode(&display, &mode);
+#elif defined(RG35XXH)
+    SDL_zero(mode);
+    mode.format = SDL_PIXELFORMAT_ARGB8888;
+    mode.w = 640;
+    mode.h = 480;
+    mode.refresh_rate = 60;
+    SDL_AddDisplayMode(&display, &mode);
 #else
     SDL_zero(mode);
     mode.format = SDL_PIXELFORMAT_RGB565;
@@ -5194,7 +5593,7 @@ void MMIYOO_VideoQuit(_THIS)
     lang_unload();
 }
 
-#if defined(MMIYOO) || defined(QX1000) || defined(A30)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
 static const char *DIS_MODE0_640[] = {
     "640*480",
     "640*480",
@@ -5742,7 +6141,7 @@ int handle_menu(int key)
         case MENU_OVERLAY:
             if (nds.overlay.sel < nds.overlay.max) {
                 get_file_path(nds.overlay.path, nds.overlay.sel, buf, 0);
-#if defined(MMIYOO) || defined(A30)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                 reload_overlay();
 #endif
             }
diff --git a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h
index c8b1785..d738d19 100644
--- a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h
+++ b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h
@@ -131,6 +131,16 @@
     #define MAX_PATH                128
 #endif
 
+#ifdef RG35XXH
+    #define DEF_FB_W                640
+    #define DEF_FB_H                480
+    #define FB_BPP                  4
+    #define IMG_W                   640
+    #define IMG_H                   480
+    #define SCREEN_DMA_SIZE         (NDS_Wx2 * NDS_Hx2 * 4)
+    #define RELOAD_BG_COUNT         1
+#endif
+
 #ifdef A30
     #define DEF_FB_W                640
     #define DEF_FB_H                480
@@ -208,7 +218,7 @@
 #define PEN_RB                      3
 #define FONT_PATH                   "resources/font/font.ttf"
 
-#if defined(MMIYOO) || defined(A30) || defined(PANDORA) || defined(QX1000)
+#if defined(MMIYOO) || defined(A30) || defined(PANDORA) || defined(QX1000) || defined(RG35XXH)
     #define DEF_FONT_SIZE           24
 #endif
 
@@ -365,6 +375,12 @@ typedef struct _GFX {
         ion_alloc_info_t ion;
 #endif
 
+#ifdef RG35XXH
+        uint32_t *mem;
+		SDL_Surface *swsurface;
+#endif
+
+
 #ifdef PANDORA
         uint32_t *mem[2];
 #endif
