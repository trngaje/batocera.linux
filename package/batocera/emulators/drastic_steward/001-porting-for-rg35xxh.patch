diff --git a/Makefile b/Makefile
index c577a6f..2808fda 100644
--- a/Makefile
+++ b/Makefile
@@ -29,6 +29,12 @@ ifeq ($(MOD),mmiyoo)
     export CROSS=/opt/mmiyoo/bin/arm-linux-gnueabihf-
 endif
 
+ifeq ($(MOD),rg35xxh)
+    SDL2_CFG+= --disable-oss
+    SDL2_CFG+= --disable-alsa
+    #export CROSS=/opt/mmiyoo/bin/arm-linux-gnueabihf-
+endif
+
 ifeq ($(MOD),trimui)
     SDL2_CFG+= --disable-oss
     SDL2_CFG+= --disable-alsa
@@ -58,25 +64,35 @@ else
     export HOST=arm-linux
     $(shell cd sdl2 && rm -rf libEGL.so libGLESv2.so)
 ifneq ($(MOD),qx1000)
-    $(shell cd sdl2 && ln -s ../drastic/libs/libEGL.so)
-    $(shell cd sdl2 && ln -s ../drastic/libs/libGLESv2.so)
+	ifneq ($(MOD),rg35xxh)
+		$(shell cd sdl2 && ln -s ../drastic/libs/libEGL.so)
+		$(shell cd sdl2 && ln -s ../drastic/libs/libGLESv2.so)
+	endif
 endif
 endif
 
 .PHONY: all
 all:
+ifneq ($(MOD),rg35xxh)
 	make -C loader MOD=$(MOD)
+endif
 	make -C detour MOD=$(MOD)
 	cp detour/libdtr.so drastic/libs/
+ifneq ($(MOD),rg35xxh)
 	make -C alsa MOD=$(MOD)
 	cp alsa/libasound.so.2 drastic/libs/
+endif
 	make -C sdl2 -j4
 	cp sdl2/build/.libs/libSDL2-2.0.so.0 drastic/libs/
+ifneq ($(MOD),rg35xxh)
 	make -C unittest $(MOD)
+endif
 
 .PHONY: cfg
 cfg:
+ifneq ($(MOD),rg35xxh)
 	cp assets/$(MOD)/* drastic/
+endif
 	cd sdl2 && ./autogen.sh && MOD=$(MOD) ./configure $(SDL2_CFG) --host=$(HOST)
 
 .PHONY: rel
diff --git a/Makefile.a30 b/Makefile.a30
new file mode 100644
index 0000000..0b00b1c
--- /dev/null
+++ b/Makefile.a30
@@ -0,0 +1,26 @@
+export MOD=a30
+export PATH=/opt/a30/bin:$(shell echo $$PATH)
+export CROSS=/opt/a30/bin/arm-linux-
+export CC=${CROSS}gcc
+export AR=${CROSS}ar
+export AS=${CROSS}as
+export LD=${CROSS}ld
+export CXX=${CROSS}g++
+export HOST=arm-linux
+    
+$(shell cd sdl2 && rm -rf libEGL.so libGLESv2.so)
+$(shell sed -i 's/"xv":30000/"xv":80000/g' drastic/resources/settings.json)
+$(shell sed -i 's/"yv":35000/"yv":85000/g' drastic/resources/settings.json)
+$(shell sed -i 's/"maxcpu":1550/"maxcpu":1500/g' drastic/resources/settings.json)
+
+SDL2_CFG+= --enable-loadso
+SDL2_CFG+= --enable-joystick
+SDL2_CFG+= --disable-video-opengl
+SDL2_CFG+= --disable-video-opengles
+SDL2_CFG+= --disable-video-opengles2
+
+include Makefile.mk
+
+.PHONY: push
+push:
+	adb push drastic/libs/* /mnt/SDCARD/Emu/drastic/libs/
diff --git a/Makefile.mk b/Makefile.mk
new file mode 100644
index 0000000..20efd62
--- /dev/null
+++ b/Makefile.mk
@@ -0,0 +1,62 @@
+SDL2_CFG+= --disable-joystick-virtual
+SDL2_CFG+= --disable-jack
+SDL2_CFG+= --disable-power
+SDL2_CFG+= --disable-sensor
+SDL2_CFG+= --disable-ime
+SDL2_CFG+= --disable-dbus
+SDL2_CFG+= --disable-fcitx
+SDL2_CFG+= --enable-hidapi
+SDL2_CFG+= --disable-libudev
+SDL2_CFG+= --disable-video-x11
+SDL2_CFG+= --disable-video-kmsdrm
+SDL2_CFG+= --disable-video-vulkan
+SDL2_CFG+= --disable-video-wayland
+SDL2_CFG+= --disable-video-dummy
+SDL2_CFG+= --disable-sndio
+SDL2_CFG+= --disable-diskaudio
+SDL2_CFG+= --disable-pulseaudio
+SDL2_CFG+= --disable-dummyaudio
+SDL2_CFG+= --enable-oss
+SDL2_CFG+= --enable-alsa
+
+REL_VER  = $(shell git rev-parse HEAD | cut -c 1-8)
+
+.PHONY: all
+all:
+#	make -C loader MOD=$(MOD)
+	make -C detour MOD=$(MOD)
+	cp detour/libdtr.so drastic/libs/
+#	make -C alsa MOD=$(MOD)
+#	cp alsa/libasound.so.2 drastic/libs/
+	make -C sdl2 -j4
+	cp sdl2/build/.libs/libSDL2-2.0.so.0 drastic/libs/
+#	make -C unittest $(MOD)
+
+.PHONY: cfg
+cfg:
+#	cp -a assets/$(MOD)/* drastic/
+	cd sdl2 && ./autogen.sh && MOD=$(MOD) ./configure $(SDL2_CFG) --host=$(HOST)
+
+.PHONY: rel
+rel:
+	zip -r drastic_$(MOD)_$(REL_VER).zip drastic
+
+.PHONY: clean
+clean:
+	rm -rf drastic/libs2
+	rm -rf drastic/cpuclock
+	rm -rf drastic/launch.sh
+	rm -rf drastic/config.json
+	rm -rf drastic/libs/libdtr.so
+	rm -rf drastic/libs/libasound.so.2
+	rm -rf drastic/libs/libSDL2-2.0.so.0
+	rm -rf drastic/libs/libfreetype.so.6
+	rm -rf drastic/libs/libglib-2.0.so.0
+	rm -rf drastic/libs/libharfbuzz.so.0
+	rm -rf drastic/libs/libpcre2-8.so.0
+	make -C alsa clean
+	make -C detour clean
+	make -C loader clean
+	make -C sdl2 distclean
+	sed -i 's/screen_orientation.*/screen_orientation = 0/g' drastic/config/drastic.cfg
+	cd drastic && mkdir -p backup scripts slot2 unzip_cache cheats input_record profiles savestates
diff --git a/Makefile.trimui b/Makefile.trimui
new file mode 100644
index 0000000..38849ed
--- /dev/null
+++ b/Makefile.trimui
@@ -0,0 +1,23 @@
+export MOD=trimui
+export PATH=/opt/mmiyoo/bin:$(shell echo $$PATH)
+export CROSS=/opt/mmiyoo/bin/arm-linux-gnueabihf-
+export CC=${CROSS}gcc
+export AR=${CROSS}ar
+export AS=${CROSS}as
+export LD=${CROSS}ld
+export CXX=${CROSS}g++
+export HOST=arm-linux
+
+$(shell cd sdl2 && rm -rf libEGL.so libGLESv2.so)
+$(shell cd sdl2 && ln -s ../drastic/libs/libEGL.so)
+$(shell cd sdl2 && ln -s ../drastic/libs/libGLESv2.so)
+
+$(shell sed -i 's/"xv":80000/"xv":30000/g' drastic/resources/settings.json)
+$(shell sed -i 's/"yv":85000/"yv":35000/g' drastic/resources/settings.json)
+$(shell sed -i 's/"maxcpu":1500/"maxcpu":1550/g' drastic/resources/settings.json)
+
+SDL2_CFG+= --disable-video-opengl
+SDL2_CFG+= --disable-video-opengles
+SDL2_CFG+= --disable-video-opengles2
+
+include Makefile.mk
diff --git a/README.md b/README.md
index 6bf4778..4dc0f91 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,5 @@
-# NDS Emulator (DraStic) for Miyoo Mini (Plus), TRIMUI SMART, FunKey S, RG Nano and F(x)tec Pro1 (QX1000)
-![image](images/mmiyoo_640/mm.jpg) ![image](images/mmiyoo_640/mmp.jpg) ![image](images/mmiyoo_752/mm.jpg) ![image](images/trimui_320/trimui.jpg) ![image](images/funkeys_240/funkeys.jpg) ![image](images/funkeys_240/rgnano.jpg) ![image](images/qx1000_1080/pro1.jpg)  
+# NDS Emulator (DraStic) for Miyoo Mini (Plus), TRIMUI SMART and F(x)tec Pro1 (QX1000)
+![image](images/mmiyoo_640/mm.jpg) ![image](images/mmiyoo_640/mmp.jpg) ![image](images/mmiyoo_752/mm.jpg) ![image](images/trimui_320/trimui.jpg) ![image](images/qx1000_1080/pro1.jpg)  
 
 &nbsp;
 
@@ -12,7 +12,6 @@
    -  [Miyoo Mini (Plus)](#miyoo-mini-plus)
    -  [Miyoo Mini v4](#miyoo-mini-v4)
    -  [TRIMUI SMART](#trimui-smart)
-   -  [FunKey S and RG Nano](#funkey-s-and-rg-nano)
    -  [F(x)tec Pro1 (QX1000)](#fxtec-pro1-qx1000)
 
 &nbsp;
@@ -64,15 +63,6 @@ $ make
 $ make rel MOD=trimui
 ```
 
-### How to build code for FunKey S and RG Nano
-```
-$ sudo docker run -it --rm -u $(id -u ${USER}):$(id -g ${USER}) -v $(pwd):/nds mmiyoo /bin/bash
-$ cd /nds
-$ make cfg MOD=funkeys
-$ make
-$ make rel MOD=funkeys
-```
-
 ### How to build code for F(x)tec Pro1 (QX1000)
 ```
 $ make cfg MOD=qx1000
@@ -595,76 +585,6 @@ Go to DraStic menu and then select "Restart Game".
 
 &nbsp;
 
-### FunKey S and RG Nano
-![image](images/funkeys_240/funkeys.jpg) ![image](images/funkeys_240/rgnano.jpg)  
-
-##### Layout 0, Screen0: 240x192, Image: bg_s0.png  
-| ![image](images/funkeys_240/dis_0.png) |
-|-|
-
-&nbsp;
-
-#### DraStic Menu: Original  
-| ![image](images/mmiyoo_640/menu_2.png) |
-|-|
-
-&nbsp;
-
-#### DraStic Menu: Refined  
-| ![image](images/funkeys_240/menu_0.png) |
-|-|
-
-&nbsp;
-
-#### Cheat Menu: Original  
-| ![image](images/mmiyoo_640/menu_3.png) |
-|-|
-
-&nbsp;
-
-#### Cheat Menu: Refined  
-| ![image](images/funkeys_240/menu_1.png) |
-|-|
-
-&nbsp;
-
-#### Hotkeys
-|  Keys              | Description                      |
-| ------------------ | -------------------------------- |
-| START + LEFT       | Change Keypad mode / Stylus mode |
-| START + RIGHT      | Swap screen                      |
-| START + L1         | Quick load state                 |
-| START + R1         | Quick save state                 |
-| START + SELECT     | Exit from DraStic emulator       |
-| **Keypad Mode**    |                                  |
-| MENU (Short Press) | Enter DraStic menu               |
-| START + Y          | Change background image          |
-| **Stylus Mode**    |                                  |
-| DPAD               | Move the pen                     |
-| A                  | Touch screen                     |
-| R1                 | Lower moving speed               |
-| START + Y          | Change stylus pen                |
-
-&nbsp;
-
-### Installation
-```
-1. Place "nds_drastic_funkey-s*.opk" in Emulators folder.
-2. Place "drastic" folder in the root folder.
-3. Create "NDS" folder in the root folder if not exist.
-4. Place BIOS files in "drastic/system" folder.
-5. Place roms in "NDS" folder.
-
-BIOS files:
-    cd63893f	drastic/system/drastic_bios_arm7.bin
-    f307d77a	drastic/system/drastic_bios_arm9.bin
-    1280f0d5	drastic/system/nds_bios_arm7.bin
-    2ab23573	drastic/system/nds_bios_arm9.bin
-    13046805	drastic/system/nds_firmware.bin
-```
-
-&nbsp;
-
 ### F(x)tec Pro1 (QX1000)
 ![image](images/qx1000_1080/pro1.jpg)  
 
diff --git a/detour/Makefile b/detour/Makefile
index 51a3db8..61725b4 100644
--- a/detour/Makefile
+++ b/detour/Makefile
@@ -1,15 +1,21 @@
 TARGET  = libdtr.so
 LDFLAGS = -fpic -shared
 MOD     = mmiyoo
-SRC     = main.c
+SRC     = main.c pmparser.c
 
 ifeq ($(MOD),mmiyoo)
-    CFLAGS += -DMMIYOO -I../mmiyoo/inc
+    CFLAGS += -DMMIYOO -I../mmiyoo/inc -I.
     CFLAGS += -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3 -Wl,--no-undefined
     LDFLAGS+= -ljson-c
     LDFLAGS+= -L../mmiyoo/lib -lmi_common -lmi_sys -lmi_gfx -lmi_ao
 endif
 
+ifeq ($(MOD),rg35xxh)
+    CFLAGS += -DRG35XXH -I../mmiyoo/inc
+    CFLAGS += -O3 -Wl,--no-undefined
+    LDFLAGS+= -ljson-c
+endif
+
 ifeq ($(MOD),trimui)
     CFLAGS += -DTRIMUI -I../trimui/inc
     CFLAGS += -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3 -Wl,--no-undefined
diff --git a/detour/detour.h b/detour/detour.h
index 872cc2c..9ed54c2 100644
--- a/detour/detour.h
+++ b/detour/detour.h
@@ -1,52 +1,123 @@
 #ifndef __PATCH_H__
 #define __PATCH_H__
-
-    #define VAR_SYSTEM                  0x083f4000
-    #define VAR_SYSTEM_GAMECARD_NAME    0x0847e8e8
-    #define VAR_SYSTEM_SAVESTATE_NUM    0x08479780
-    #define VAR_SDL_SCREEN_RENDERER     0x0aee9568
-    #define VAR_SDL_SCREEN_BPP          0x0aee957c
-    #define VAR_SDL_SCREEN_NEED_INIT    0x0aee95a0
+    #include "drastic.h"
+ 
+    //nds_system
+    #define VAR_SYSTEM                  (base_addr_rx + 0x003f6000)
+    #define VAR_SYSTEM_GAMECARD_NAME    (base_addr_rx + 0x00480b38)
+    #define VAR_SYSTEM_SAVESTATE_NUM    (VAR_SYSTEM + 0x47b9c0)
+    
+    #define VAR_SDL_SCREEN_BPP          VAR_DAT_03f2a5b0
+    #define VAR_SDL_SCREEN_NEED_INIT    VAR_DAT_03f2a5dc
+    #define VAR_SDL_SCREEN_WINDOW       VAR_DAT_03f2a578
+    #define VAR_SDL_SCREEN_RENDERER     VAR_DAT_03f2a580
 
     #define VAR_SDL_SCREEN0_SHOW        0x0aee9544
-    #define VAR_SDL_SCREEN0_HRES_MODE   0x0aee9545
+    #define VAR_SDL_SCREEN0_HRES_MODE   VAR_DAT_03f2a549
     #define VAR_SDL_SCREEN0_TEXTURE     0x0aee952c
-    #define VAR_SDL_SCREEN0_PIXELS      0x0aee9530
+    #define VAR_SDL_SCREEN0_PIXELS      VAR_DAT_03f2a530
     #define VAR_SDL_SCREEN0_X           0x0aee9534
     #define VAR_SDL_SCREEN0_Y           0x0aee9538
 
     #define VAR_SDL_SCREEN1_SHOW        0x0aee9560
-    #define VAR_SDL_SCREEN1_HRES_MODE   0x0aee9561
+    #define VAR_SDL_SCREEN1_HRES_MODE    (VAR_DAT_03f2a549 + 0x28)
     #define VAR_SDL_SCREEN1_TEXTURE     0x0aee9548
-    #define VAR_SDL_SCREEN1_PIXELS      0x0aee954c
+    #define VAR_SDL_SCREEN1_PIXELS     ( VAR_DAT_03f2a530 + 8*5)
     #define VAR_SDL_SCREEN1_X           0x0aee9550
     #define VAR_SDL_SCREEN1_Y           0x0aee9554
+	
+	#define VAR_SDL_SWAP_SCREENS    VAR_DAT_03f2a5d4
+	#define VAR_SDL_FRAME_COUNT      VAR_DAT_03f2a5f4
+	#define VAR_SDL_SCREEN_CURSOR  VAR_DAT_03f2a5e4 
+	
+    #define VAR_DAT_03f2a578		(base_addr_rx + 0x03f2a578)
+    #define VAR_DAT_03f2a580		(base_addr_rx + 0x03f2a580)
+    #define VAR_DAT_03f2a530		(base_addr_rx + 0x03f2a530)
+    #define VAR_DAT_03f2a549		(base_addr_rx + 0x03f2a549)
+    #define VAR_DAT_03f2a5b0		(base_addr_rx + 0x03f2a5b0)
+    #define VAR_DAT_03f2a5dc		(base_addr_rx + 0x03f2a5dc)
+
+    #define VAR_DAT_0402a548		(base_addr_rx + 0x0402a548)
+    #define VAR_DAT_0402a549		(base_addr_rx + 0x0402a549)
+    #define VAR_DAT_0402a5b0		(base_addr_rx + 0x0402a5b0)
+    #define VAR_SDL_SCREEN		(base_addr_rx + 0x0402a528)
+    #define VAR_DAT_0402a530		(base_addr_rx + 0x0402a530)
+    
+    #define VAR_DAT_0402a580		(base_addr_rx + 0x0402a580)
+    #define VAR_DAT_0402a550		(base_addr_rx + 0x0402a550)
+    #define VAR_DAT_0402a570		(base_addr_rx + 0x0402a570)
+    #define VAR_DAT_0402a5f4		(base_addr_rx + 0x0402a5f4)
+    #define VAR_DAT_0402a5f0		(base_addr_rx + 0x0402a5f0)
+    #define VAR_DAT_0402a590		(base_addr_rx + 0x0402a590)
+    #define VAR_DAT_0402a598		(base_addr_rx + 0x0402a598)
+    
+	#define VAR_DAT_03f2a5f4     (base_addr_rx + 0x03f2a5f4)
+	#define VAR_DAT_03f2a5e4    (base_addr_rx + 0x03f2a5e4)
+	
+	#define VAR_DAT_03f2a5d4   (base_addr_rx + 0x03f2a5d4)
+	
+    #define VAR_ADPCM_STEP_TABLE        (base_addr_rx + 0x0025b230)
+    #define VAR_ADPCM_INDEX_STEP_TABLE  (base_addr_rx + 0x0025b2e8)
+    #define VAR_DESMUME_FOOTER_STR      (base_addr_rx + 0x0025b370)
 
-    #define VAR_ADPCM_STEP_TABLE        0x0815a600
-    #define VAR_ADPCM_INDEX_STEP_TABLE  0x0815a6b8
-    #define VAR_DESMUME_FOOTER_STR      0x0815a740
+    #define FUN_FREE                    (base_addr_rx + 0x0402C218)
+    #define FUN_REALLOC                 (base_addr_rx + 0x0402c288)
+    #define FUN_MALLOC                  (base_addr_rx + 0x0402c6f0)
+    #define FUN_SCREEN_COPY16           (base_addr_rx + 0x00097df0)
+    #define FUN_PRINT_STRING            (base_addr_rx + 0x00097c30)
+    #define FUN_PRINT_STRING_EXT        (base_addr_rx + 0x000978f0)
+    #define FUN_LOAD_STATE_INDEX        (base_addr_rx + 0x00088ff0)
+    #define FUN_SAVE_STATE_INDEX        (base_addr_rx + 0x00088f10)
+    #define FUN_QUIT                    (base_addr_rx + 0x0000fa20)
+    //#define FUN_SAVESTATE_PRE           0x08095a80
+    //#define FUN_SAVESTATE_POST          0x08095154
+    
+    #define FUN_UPDATE_SCREEN           (base_addr_rx + 0x00099df0)
+    #define FUN_UPDATE_SCREENS          (base_addr_rx + 0x0009a350)
+    #define FUN_FRAME_GEOMETRY         (base_addr_rx + 0x00074fd0)
+    #define FUN_UPDATE_FRAME         	(base_addr_rx + 0x00034260)
+    
+    #define FUN_SET_SCREEN_MENU_OFF     (base_addr_rx + 0x0009a170)
+    
+    #define FUN_LOAD_STATE              (base_addr_rx + 0x000884c0)
+    #define FUN_SAVE_STATE              (base_addr_rx + 0x00088b70)
+    #define FUN_BLIT_SCREEN_MENU        (base_addr_rx + 0x000982f0)
+    #define FUN_INITIALIZE_BACKUP       (base_addr_rx + 0x00086090)
+    #define FUN_SET_SCREEN_MENU_OFF     (base_addr_rx + 0x0009a170)
+    #define FUN_GET_SCREEN_PTR          (base_addr_rx + 0x0009a7e0)
+    #define FUN_SPU_ADPCM_DECODE_BLOCK  (base_addr_rx + 0x0007f540)
 
-    #define FUN_FREE                    0x08003e58
-    #define FUN_REALLOC                 0x0800435c
-    #define FUN_MALLOC                  0x080046e0
-    #define FUN_SCREEN_COPY16           0x080a59d8
-    #define FUN_PRINT_STRING            0x080a5398
-    #define FUN_LOAD_STATE_INDEX        0x08095ce4
-    #define FUN_SAVE_STATE_INDEX        0x08095c10
-    #define FUN_QUIT                    0x08006444
-    #define FUN_SAVESTATE_PRE           0x08095a80
-    #define FUN_SAVESTATE_POST          0x08095154
-    #define FUN_UPDATE_SCREEN           0x080a83c0
-    #define FUN_SET_SCREEN_MENU_OFF     0x080a8240
-    #define FUN_LOAD_STATE              0x080951c0
-    #define FUN_SAVE_STATE              0x0809580c
-    #define FUN_BLIT_SCREEN_MENU        0x080a62d8
-    #define FUN_INITIALIZE_BACKUP       0x08092f40
-    #define FUN_SET_SCREEN_MENU_OFF     0x080a8240
-    #define FUN_GET_SCREEN_PTR          0x080a890c
-    #define FUN_SPU_ADPCM_DECODE_BLOCK  0x0808d268
+    #define FUN_INITIALIZE_MEMORY (base_addr_rx + 0x0001e7e0)
+    #define FUN_PLATFORM_INITIALIZE_INPUT (base_addr_rx + 0x0009c030)
+    #define FUN_INITIALIZE_SYSTEM_DIRECTORY (base_addr_rx + 0x00010780)
+    //#define CODE_FAST_FORWARD           0x08006ad0
 
-    #define CODE_FAST_FORWARD           0x08006ad0
+    /* add by trngaje */
+    #define FUN_UPDATE_INPUT            (base_addr_rx + 0x00098430)
+    #define FUN_PLATFORM_GET_INPUT	(base_addr_rx + 0x0009aaf0)
+    #define FUN_MENU                    (base_addr_rx + 0x00093460)
+    #define FUN_SET_SCREEN_ORIENTATION  (base_addr_rx + 0x0009a7b0)
+    #define FUN_UPDATE_SCREEN_MENU	(base_addr_rx + 0x00099f40)
+    #define FUN_LUA_IS_ACTIVE		(base_addr_rx + 0x000999b0)
+    #define FUN_LUA_ON_FRAME_UPDATE	(base_addr_rx + 0x00099be0)
+    #define FUN_SET_DEBUG_MODE		(base_addr_rx + 0x00095fa0)
+    #define FUN_CPU_BLOCK_LOG_ALL	(base_addr_rx + 0x000305c0)
+    #define FUN_SET_SCREEN_SWAP		(base_addr_rx + 0x0009a7d0)
+    #define FUN_QUIT			(base_addr_rx + 0x0000fa20)
+    #define FUN_SPU_FAKE_MICROPHONE_STOP	(base_addr_rx + 0x00080220)
+    #define FUN_SPU_FAKE_MICROPHONE_START	(base_addr_rx + 0x00080200)
+    #define FUN_TOUCHSCREEN_SET_POSITION	(base_addr_rx + 0x00084bc0)
+    #define FUN_BACKUP_SAVE_PART_0		(base_addr_rx + 0x00085840)
+    #define FUN_BACKUP_SAVE 			(base_addr_rx + 0x00086040)
+    #define FUN_GET_GUI_INPUT			(base_addr_rx + 0x0009b7b0)
+    #define FUN_DRAW_MENU_BG			(base_addr_rx + 0x00093140)
+    #define FUN_SAVESTATE_INDEX_TIMESTAMP 	(base_addr_rx + 0x000890b0)
+    #define FUN_GAMECARD_CLOSE			(base_addr_rx + 0x00084520)
+    #define FUN_AUDIO_EXIT			(base_addr_rx + 0x0009ce20)
+    #define FUN_INPUT_LOG_CLOSE			(base_addr_rx + 0x00098cf0)
+    #define FUN_UNINITIALIZE_MEMORY		(base_addr_rx + 0x0001f1e0)
+    #define FUN_PLATFORM_QUIT			(base_addr_rx + 0x00099de0)
+    #define FUN_SAVE_DIRECTORY_CONFIG_FILE	(base_addr_rx + 0x00099de0)
 
     #define ALIGN_ADDR(addr)        ((void*)((size_t)(addr) & ~(page_size - 1)))
 
@@ -102,23 +173,50 @@
     typedef void (*nds_free)(void *ptr);
     typedef void (*nds_set_screen_menu_off)(void);
     typedef void (*nds_quit)(void *system);
-    typedef void (*nds_screen_copy16)(uint16_t *dest, uint32_t screen_number);
-    typedef int32_t (*nds_load_state_index)(void *system, uint32_t index, uint16_t *snapshot_top, uint16_t *snapshot_bottom, uint32_t snapshot_only);
-    typedef int32_t (*nds_save_state_index)(void *system, uint32_t index, uint16_t *snapshot_top, uint16_t *snapshot_bottom);
+    typedef void (*nds_screen_copy16)(unsigned short *param_1,unsigned int param_2);
+    typedef void (*nds_load_state_index)(void *system, uint32_t index, uint16_t *snapshot_top, uint16_t *snapshot_bottom, uint32_t snapshot_only);
+                    
+    typedef void (*nds_save_state_index)(void *system, uint32_t index, uint16_t *snapshot_top, uint16_t *snapshot_bottom);
+ 
     typedef int32_t (*nds_load_state)(void *system, const char *path, uint16_t *snapshot_top, uint16_t *snapshot_bottom, uint32_t snapshot_only);
-    typedef int32_t (*nds_save_state)(void *system, const char *dir, char *filename, uint16_t *snapshot_top, uint16_t *snapshot_bottom);
+    typedef void (*nds_save_state)(ulong *param_1,char *param_2,char *param_3,void *param_4,void *param_5);
+    
     typedef void* (*nds_get_screen_ptr)(uint32_t screen_number);
     typedef void* (*nds_realloc)(void *ptr, size_t size);
     typedef void* (*nds_malloc)(size_t size);
     typedef void (*nds_spu_adpcm_decode_block)(spu_channel_struct *channel);
 
+    typedef void (*nds_platform_get_input)(long param_1/*input_struct *input*/);
+    typedef bool (*nds_lua_is_active)(void);
+    typedef void (*nds_lua_on_frame_update)(void);
+    typedef void (*nds_set_debug_mode)(long param_1,unsigned char param_2);
+    typedef int (*nds_cpu_block_log_all)(long param_1,char *param_2);
+    //typedef void (*nds_screen_copy16)(ushort *param_1,unsigned int param_2);
+    typedef void (*nds_menu)(long param_1,int param_2);
+    typedef void (*nds_set_screen_swap)(unsigned int param_1);
+    //typedef void (*nds_quit)(long param_1);
+    typedef void (*nds_spu_fake_microphone_stop)(long param_1);
+    typedef void (*nds_spu_fake_microphone_start)(long param_1);
+    typedef void (*nds_touchscreen_set_position)(long param_1,uint param_2,uint param_3);
+    typedef void (*nds_set_screen_orientation)(unsigned int param_1);
+    typedef void (*nds_get_gui_input)(long param_1,unsigned int *param_2);
+    typedef long (*nds_savestate_index_timestamp)(long param_1,unsigned int param_2);
+    typedef int (*nds_gamecard_close)(long param_1);
+    typedef void (*nds_audio_exit)(long param_1);
+    typedef FILE * (*nds_input_log_close)(long param_1);
+    typedef int (*nds_uninitialize_memory)(long param_1);
+    typedef void (*nds_platform_quit)(void);
+    typedef unsigned long (*nds_save_directory_config_file)(long param_1,unsigned long param_2);
+    
     void detour_init(size_t page_size, const char *path);
     void detour_quit(void);
-    void detour_hook(uint32_t old_func, uint32_t new_func);
+    void detour_hook(uint64_t old_func, uint64_t new_func);
 
     int dtr_quit(void);
     int dtr_savestate(int slot);
     int dtr_loadstate(int slot);
     int dtr_fastforward(uint8_t v);
 
+   extern uint64_t base_addr_rx;
+
 #endif
diff --git a/detour/detour.h.org b/detour/detour.h.org
new file mode 100644
index 0000000..872cc2c
--- /dev/null
+++ b/detour/detour.h.org
@@ -0,0 +1,124 @@
+#ifndef __PATCH_H__
+#define __PATCH_H__
+
+    #define VAR_SYSTEM                  0x083f4000
+    #define VAR_SYSTEM_GAMECARD_NAME    0x0847e8e8
+    #define VAR_SYSTEM_SAVESTATE_NUM    0x08479780
+    #define VAR_SDL_SCREEN_RENDERER     0x0aee9568
+    #define VAR_SDL_SCREEN_BPP          0x0aee957c
+    #define VAR_SDL_SCREEN_NEED_INIT    0x0aee95a0
+
+    #define VAR_SDL_SCREEN0_SHOW        0x0aee9544
+    #define VAR_SDL_SCREEN0_HRES_MODE   0x0aee9545
+    #define VAR_SDL_SCREEN0_TEXTURE     0x0aee952c
+    #define VAR_SDL_SCREEN0_PIXELS      0x0aee9530
+    #define VAR_SDL_SCREEN0_X           0x0aee9534
+    #define VAR_SDL_SCREEN0_Y           0x0aee9538
+
+    #define VAR_SDL_SCREEN1_SHOW        0x0aee9560
+    #define VAR_SDL_SCREEN1_HRES_MODE   0x0aee9561
+    #define VAR_SDL_SCREEN1_TEXTURE     0x0aee9548
+    #define VAR_SDL_SCREEN1_PIXELS      0x0aee954c
+    #define VAR_SDL_SCREEN1_X           0x0aee9550
+    #define VAR_SDL_SCREEN1_Y           0x0aee9554
+
+    #define VAR_ADPCM_STEP_TABLE        0x0815a600
+    #define VAR_ADPCM_INDEX_STEP_TABLE  0x0815a6b8
+    #define VAR_DESMUME_FOOTER_STR      0x0815a740
+
+    #define FUN_FREE                    0x08003e58
+    #define FUN_REALLOC                 0x0800435c
+    #define FUN_MALLOC                  0x080046e0
+    #define FUN_SCREEN_COPY16           0x080a59d8
+    #define FUN_PRINT_STRING            0x080a5398
+    #define FUN_LOAD_STATE_INDEX        0x08095ce4
+    #define FUN_SAVE_STATE_INDEX        0x08095c10
+    #define FUN_QUIT                    0x08006444
+    #define FUN_SAVESTATE_PRE           0x08095a80
+    #define FUN_SAVESTATE_POST          0x08095154
+    #define FUN_UPDATE_SCREEN           0x080a83c0
+    #define FUN_SET_SCREEN_MENU_OFF     0x080a8240
+    #define FUN_LOAD_STATE              0x080951c0
+    #define FUN_SAVE_STATE              0x0809580c
+    #define FUN_BLIT_SCREEN_MENU        0x080a62d8
+    #define FUN_INITIALIZE_BACKUP       0x08092f40
+    #define FUN_SET_SCREEN_MENU_OFF     0x080a8240
+    #define FUN_GET_SCREEN_PTR          0x080a890c
+    #define FUN_SPU_ADPCM_DECODE_BLOCK  0x0808d268
+
+    #define CODE_FAST_FORWARD           0x08006ad0
+
+    #define ALIGN_ADDR(addr)        ((void*)((size_t)(addr) & ~(page_size - 1)))
+
+    typedef enum _backup_type_enum {
+        BACKUP_TYPE_NONE   = 0,
+        BACKUP_TYPE_FLASH  = 1,
+        BACKUP_TYPE_EEPROM = 2,
+        BACKUP_TYPE_NAND   = 3
+    } backup_type_enum;
+
+    typedef struct _backup_struct {
+        uint32_t dirty_page_bitmap[2048];
+        char file_path[1024];
+        backup_type_enum type;
+        uint32_t access_address;
+        uint32_t address_mask;
+        uint32_t fix_file_size;
+        uint8_t *data;
+        uint8_t jedec_id[4];
+        uint32_t write_frame_counter;
+        uint16_t mode;
+        uint8_t state;
+        uint8_t status;
+        uint8_t address_bytes;
+        uint8_t state_step;
+        uint8_t firmware;
+        uint8_t footer_written;
+    } backup_struct;
+
+    typedef struct _spu_channel_struct {
+        int16_t adpcm_sample_cache[64];
+        uint64_t sample_offset;
+        uint64_t frequency_step;
+        uint32_t adpcm_cache_block_offset;
+        uint8_t *io_region;
+        uint8_t *samples;
+        uint32_t sample_address;
+        uint32_t sample_length;
+        uint32_t loop_wrap;
+        int16_t volume_multiplier_left;
+        int16_t volume_multiplier_right;
+        int16_t adpcm_loop_sample;
+        int16_t adpcm_sample;
+        uint8_t format;
+        uint8_t dirty_bits;
+        uint8_t active;
+        uint8_t adpcm_loop_index;
+        uint8_t adpcm_current_index;
+        uint8_t adpcm_looped;
+        uint8_t capture_timer;
+    } spu_channel_struct;
+
+    typedef void (*nds_free)(void *ptr);
+    typedef void (*nds_set_screen_menu_off)(void);
+    typedef void (*nds_quit)(void *system);
+    typedef void (*nds_screen_copy16)(uint16_t *dest, uint32_t screen_number);
+    typedef int32_t (*nds_load_state_index)(void *system, uint32_t index, uint16_t *snapshot_top, uint16_t *snapshot_bottom, uint32_t snapshot_only);
+    typedef int32_t (*nds_save_state_index)(void *system, uint32_t index, uint16_t *snapshot_top, uint16_t *snapshot_bottom);
+    typedef int32_t (*nds_load_state)(void *system, const char *path, uint16_t *snapshot_top, uint16_t *snapshot_bottom, uint32_t snapshot_only);
+    typedef int32_t (*nds_save_state)(void *system, const char *dir, char *filename, uint16_t *snapshot_top, uint16_t *snapshot_bottom);
+    typedef void* (*nds_get_screen_ptr)(uint32_t screen_number);
+    typedef void* (*nds_realloc)(void *ptr, size_t size);
+    typedef void* (*nds_malloc)(size_t size);
+    typedef void (*nds_spu_adpcm_decode_block)(spu_channel_struct *channel);
+
+    void detour_init(size_t page_size, const char *path);
+    void detour_quit(void);
+    void detour_hook(uint32_t old_func, uint32_t new_func);
+
+    int dtr_quit(void);
+    int dtr_savestate(int slot);
+    int dtr_loadstate(int slot);
+    int dtr_fastforward(uint8_t v);
+
+#endif
diff --git a/detour/drastic.h b/detour/drastic.h
new file mode 100644
index 0000000..b0806a6
--- /dev/null
+++ b/detour/drastic.h
@@ -0,0 +1,127 @@
+#ifndef __DRASTIC_H__
+#define __DRASTIC_H__
+
+#pragma pack(1)
+
+typedef uint64_t u64;
+typedef uint32_t u32;
+typedef uint16_t u16;
+typedef uint8_t u8;
+typedef unsigned char    byte;
+
+typedef struct
+{
+	wchar_t username[11];
+	u32 language;
+	u32 favorite_color;
+	u32 birthday_month;
+	u32 birthday_day;
+} config_firmware_struct;
+
+typedef struct
+{
+	config_firmware_struct firmware;
+	char rom_directory[1024];
+	u32 file_list_display_type;
+	u32 frameskip_type;
+	u32 frameskip_value;
+	u32 show_frame_counter;
+	u32 screen_orientation;
+	u32 screen_scaling;
+	u32 screen_swap;
+	u32 savestate_number;
+	u32 fast_forward;
+	u32 enable_sound;
+	u32 clock_speed;
+	u32 threaded_3d;
+	u32 mirror_touch;
+	u32 compress_savestates;
+	u32 savestates_snapshot;
+	u32 enable_cheats;
+	u32 unzip_roms;
+	u32 backup_in_savestates;
+	u32 ignore_gamecard_limit;
+	u32 frame_interval;
+	u32 batch_threads_3d_count;
+	u32 trim_roms;
+	u32 fix_main_2d_screen;
+	u32 disable_edge_marking;
+	u32 hires_3d;
+	u32 bypass_3d;
+	u32 use_rtc_custom_time;
+	time_t rtc_custom_time;
+	u32 rtc_system_time;
+	u16 controls_a[40];
+	u16 controls_b[40];
+	u64 controls_code_to_config_map[2048];
+} config_struct;
+
+typedef struct event_s event_struct;
+struct event_s
+{
+	u32 cycles_forward;
+//	event_callback_type callback;
+	void *data;
+	event_struct *next;
+	event_struct *previous;
+	u8 type;
+};
+
+typedef struct
+{
+	event_struct event_storage[16];
+	event_struct *base;
+} event_list_struct;
+
+typedef struct input_s input_struct;
+typedef struct system_s system_struct;
+
+struct input_s
+{
+	u8 capture_buffer[0x80000];
+	u8 *capture_ptr;
+	system_struct *system;
+	u32 button_status;
+	u32 touch_x;
+	u32 touch_y;
+	u8 touch_status;
+	u8 touch_pressure;
+	u32 last_button_status;
+	u32 last_touch_x;
+	u32 last_touch_y;
+	u8 last_touch_status;
+	FILE *log_file;
+	u8 log_mode;
+};
+
+struct system_s
+{
+	u64 frame_number;
+	u64 global_cycles;
+	u32 cycles_to_next_event;
+	u16 scanline_number;
+	u8 undefined_1[2];
+	event_list_struct event_list; // 0x184
+	u8 undefined_2[4];
+	//gamecard_struct gamecard; // 0x2cf0;
+	unsigned char dummy1[0x2cf0];
+	//spi_peripherals_struct spi_peripherals; // 0x2448
+	unsigned char dummy2[0x2448];
+	//rtc_struct rtc; // 0x1c
+	unsigned char dummy3[0x1c];
+	input_struct input; //0x80030
+	u8 undefined_3[4];
+	config_struct config; // 0x4558
+	//benchmark_struct benchmark; // 0x68
+	unsigned char dummy4[0x68];
+	char gamecard_path[1024];
+	char root_path[1024];
+	char user_root_path[1024];
+	char gamecard_filename[1024];
+	char gamecard_name[1024];
+	
+};
+
+
+
+#endif
diff --git a/detour/main.c b/detour/main.c
index 765c6da..e4b4aa2 100644
--- a/detour/main.c
+++ b/detour/main.c
@@ -11,6 +11,9 @@
 #endif
 
 #include "detour.h"
+#include "pmparser.h"
+
+#include "drastic.h"
 
 #define PREFIX "[DTR] "
 
@@ -18,6 +21,11 @@ static int is_hooked = 0;
 static size_t page_size = 4096;
 static char states_path[255] = {0};
 
+uint64_t base_addr=0;
+uint64_t base_addr_r=0;
+uint64_t base_addr_rx=0;
+uint64_t base_addr_rw=0;
+/*
 int dtr_fastforward(uint8_t v)
 {
     uint32_t *ff = (uint32_t*)CODE_FAST_FORWARD;
@@ -27,25 +35,214 @@ int dtr_fastforward(uint8_t v)
     *ff = 0xe3a03000 | v;
     return 0;
 }
+*/
+
+/*
+[DTR] dtr_load_state_index
+[DTR] trngaje_var1=/userdata/system/drastic
+[DTR] trngaje_var2=0168 - Mario Kart DS (U)(SCZ)
+[DTR] trngaje_index=0
+[DTR] trngaje_buf=/userdata/system/drastic/savestates/0168 - Mario Kart DS (U)(SCZ)_0.dss
+*/
 
 static int32_t dtr_load_state_index(void *system, uint32_t index, uint16_t *snapshot_top, uint16_t *snapshot_bottom, uint32_t snapshot_only)
+//static int32_t dtr_load_state_index(system_struct *system, uint32_t index, uint16_t *snapshot_top, uint16_t *snapshot_bottom, uint32_t snapshot_only)
 {
-    char buf[255] = {0};
+    char buf[2080] = {0};
     nds_load_state _func = (nds_load_state)FUN_LOAD_STATE;
+  
+    printf("[trngaje] system = %p\n", system - base_addr_rx);
+    //printf("[trngaje] VAR_SYSTEM_GAMECARD_NAME = 0x%p\n", system + 0x8ab38 - base_addr_rx);
+    //printf("[trngaje] states_path=%s\n",  states_path);
+    //printf("[trngaje] user_root_path=%s\n",  system->user_root_path);
+    //printf("[trngaje] gamecard_name=%s\n",  system->gamecard_name);
+    
+    printf(PREFIX"dtr_load_state_index\n");
+    //printf(PREFIX"trngaje_var1=%s\n", (char *)(system) + 0x8a338); // drastic folder
+    //printf(PREFIX"trngaje_var2=%s\n", (char *)(system) + 0x8ab38); // GAMECARD_NAME
+    //printf(PREFIX"trngaje_index=%d\n", index);
+    //sprintf(buf, "%s/savestates/%s_%d.dss", (char *)(system) + 0x8a338, (char *)(system) + 0x8ab38, index);
+    //printf(PREFIX"trngaje_buf=%s\n", buf);
+
+    //sprintf(buf, "%s/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, index);
+    sprintf(buf, "%s/savestates/%s_%d.dss", states_path, (char *)(system + 0x8ab38), index);
+    //sprintf(buf, "%s/savestates/%s_%d.dss", (char *)(system) + 0x8a338, (char *)(system) + 0x8ab38, index);
+    _func((void*)system, buf, snapshot_top, snapshot_bottom, snapshot_only);
 
-    sprintf(buf, "%s/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, index);
-    _func((void*)VAR_SYSTEM, buf, snapshot_top, snapshot_bottom, snapshot_only);
 }
+#if 0
+void save_state_index(long param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4)
 
-static int32_t dtr_save_state_index(void *system, uint32_t index, uint16_t *snapshot_top, uint16_t *snapshot_bottom)
 {
-    char buf[255] = {0};
+  undefined auStack_848 [1056];
+  undefined auStack_428 [1056];
+  long local_8;
+  
+  local_8 = ___stack_chk_guard;
+  __sprintf_chk(auStack_848,1,0x420,"%s%csavestates",param_1 + 0x8a338,0x2f,0);
+  __sprintf_chk(auStack_428,1,0x420,"%s_%d.dss",param_1 + 0x8ab38,param_2);
+  save_state(param_1,auStack_848,auStack_428,param_3,param_4);
+  if (local_8 == ___stack_chk_guard) {
+    return;
+  }
+                    /* WARNING: Subroutine does not return */
+  __stack_chk_fail();
+}
+#endif
+/*
+[DTR] dtr_save_state_index
+[DTR] trngaje_var2=0168 - Mario Kart DS (U)(SCZ)
+Saving state to /userdata/saves/drastic/savesates/_savestate_temp.dss.
+Error: could not open /userdata/saves/drastic/savesates/_savestate_temp.dss.
+*/
+
+
+static void dtr_save_state_index(long param_1, unsigned int  param_2, unsigned long param_3, unsigned long param_4)
+
+{
+  unsigned char auStack_848 [1056];
+  unsigned char auStack_428 [1056];
+  long local_8;
+  nds_save_state save_state = (nds_save_state)FUN_SAVE_STATE;
+  
+  __sprintf_chk(auStack_848,1,0x420,"%s%csavestates", states_path/*param_1 + 0x8a338*/,0x2f,0);
+  __sprintf_chk(auStack_428,1,0x420,"%s_%d.dss",param_1 + 0x8ab38, param_2);
+  save_state(param_1,auStack_848,auStack_428,param_3,param_4);
+}
+
+
+/*
+static void dtr_save_state_index(void *system, uint32_t index, uint16_t *snapshot_top, uint16_t *snapshot_bottom)
+{
+    char buf1[1056];
+    char buf2[1056];
+
     nds_save_state _func1 = (nds_save_state)FUN_SAVE_STATE;
+    printf(PREFIX"dtr_save_state_index\n");
+    //printf(PREFIX"trngaje_var1=%s\n", (char *)(system) + 0x8a338); // drastic folder
+    printf(PREFIX"trngaje_var2=%s\n", (char *)(system + 0x8ab38)); // GAMECARD_NAME
+    //printf(PREFIX"trngaje_index=%d\n", index);
+    //sprintf(buf, "%s/savestates/%s_%d.dss", (char *)(system) + 0x8a338, (char *)(system) + 0x8ab38, index);
+    //printf(PREFIX"trngaje_buf=%s\n", buf);
+    
+    //sprintf(buf, "%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, index);
+    sprintf(buf1, "%s/savesates", states_path);
+    sprintf(buf2, "%s_%d.dss", (char *)(system + 0x8ab38), index);
+    printf(PREFIX"trngaje_buf1=%s\n", buf1);
+    printf(PREFIX"trngaje_buf2=%s\n", buf2);
+    _func1(system, buf1, buf2, snapshot_top, snapshot_bottom);
+}
+*/
 
-    sprintf(buf, "%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, index);
-    _func1((void*)VAR_SYSTEM, states_path, buf, snapshot_top, snapshot_bottom);
+void dtr_initialize_backup(void *param_1,int param_2,void *param_3,uint param_4,char *param_5)
+{
+  uint uVar1;
+  int iVar2;
+  unsigned char uVar3;
+  FILE *__stream;
+  size_t sVar4;
+  long __off;
+  ulong uVar5;
+  void *pvVar6;
+  uint uVar7;
+  ulong uVar8;
+  //char *basedup;
+  //char *basen;
+  //char sbackup[2080];
+  
+  printf("[trngaje] dtr_initialize_backup++\n");
+  *(int *)((long)param_1 + 0x2400) = param_2;
+  *(uint *)((long)param_1 + 0x2408) = param_4 - 1;
+  *(void **)((long)param_1 + 0x2410) = param_3;
+  *(unsigned char *)((long)param_1 + 0x2426) = 0;
+  *(unsigned int *)((long)param_1 + 0x240c) = 0;
+  if (param_2 != 1) {
+    if (param_2 == 0) {
+      *(unsigned char *)((long)param_1 + 0x2424) = 0;
+      goto joined_r0x00086290;
+    }
+    if (param_2 != 2) goto joined_r0x00086290;
+    if (param_4 < 0x10001) {
+      uVar3 = 2;
+      if (param_4 < 0x201) {
+        uVar3 = 1;
+      }
+      *(unsigned char *)((long)param_1 + 0x2424) = uVar3;
+      goto joined_r0x00086290;
+    }
+  }
+  *(unsigned char *)((long)param_1 + 0x2424) = 3; // backup->address_bytes = 3; // 0x003f6000 + 100 + 0x940 + 0x2424
+joined_r0x00086290:
+  if (param_5 == (char *)0x0) {
+    *(char *)((long)param_1 + 0x2000) = '\0';
+    *(unsigned char *)((long)param_1 + 0x2423) = 0;
+    return;
+  }
+  
+#if 0  
+    basedup = strdup(param_5);
+    basen = basename(basedup);
+    sprintf(sbackup, "%s/backup/%s", states_path, basen);
+    printf("[trngaje] dtr_initialize_backup:sbackup=%s\n", sbackup);
+    
+    __stream = fopen(sbackup,"rb");
+#else
+    __stream = fopen(param_5,"rb");
+#endif
+  
+  *(unsigned char *)((long)param_1 + 0x2427) = 0;
+  if (__stream == (FILE *)0x0) {
+    puts("Failed to load backup file.");
+    memset(param_3,param_4,0xff);
+    memset(param_1,0xff,(ulong)(param_4 >> 0xc));
+  }
+  else {
+    sVar4 = fread(param_3,(ulong)param_4,1,__stream);
+    if (sVar4 != 1) {
+      puts(" Failed to load entire size.");
+    }
+    __off = ftell(__stream);
+    fseek(__stream,0,2);
+    uVar5 = ftell(__stream);
+    fseek(__stream,__off,0);
+    uVar8 = uVar5 & 0xffffffff;
+    fclose(__stream);
+    __printf_chk(1,"Loading backup file %s, %d bytes\n",param_5,uVar5 & 0xffffffff);
+    uVar7 = (uint)uVar5;
+    if (param_4 + 0x7a != uVar7) {
+      *(uint *)((long)param_1 + 0x240c) = param_4 + 0x7a;
+    }
+    uVar1 = param_4 + 0x3fff >> 0xe;
+    if (uVar7 < param_4) {
+      iVar2 = uVar7 - 0x400;
+      if (iVar2 < 0) {
+        iVar2 = 0;
+      }
+      pvVar6 = memmem((void *)((long)param_3 + (long)iVar2),(ulong)(uVar7 - iVar2),
+                      (const void *)VAR_DESMUME_FOOTER_STR/*desmume_footer_str.10935*/,0x52);
+      // pvVar4 = memmem(data + uVar3,uVar2 - uVar3, (const void *)VAR_DESMUME_FOOTER_STR, 0x52);
+      if (pvVar6 != (void *)0x0) {
+        uVar8 = (long)pvVar6 - (long)param_3;
+        __printf_chk(1," Found DeSmuME footer at position %d. Truncating.\n",uVar8 & 0xffffffff);
+      }
+      uVar5 = uVar8 >> 0xe & 0x3ffff;
+      __printf_chk(1," Backup file less than full size (should be %d, loaded %d).\n",(ulong)param_4,
+                   uVar8 & 0xffffffff);
+      memset((void *)((long)param_3 + (uVar8 & 0xffffffff)),param_4 - (int)uVar8,0xff);
+      memset(param_1,0,uVar5 << 2);
+      memset((void *)((long)param_1 + uVar5 * 4),0xff,(ulong)((uVar1 - (int)uVar5) * 4));
+    }
+    else {
+      memset(param_1,0,(ulong)uVar1);
+    }
+  }
+  strncpy((char *)((long)param_1 + 0x2000),param_5,0x3ff);
+  *(unsigned char *)((long)param_1 + 0x23ff) = 0;
+  *(unsigned char *)((long)param_1 + 0x2423) = 0;
+  return;
 }
 
+/*
 static void dtr_initialize_backup(backup_struct *backup, backup_type_enum backup_type, uint8_t *data, uint32_t size, char *path)
 {
     char *data_file_name = NULL;
@@ -62,11 +259,12 @@ static void dtr_initialize_backup(backup_struct *backup, backup_type_enum backup
     uint32_t truncate_size = 0;
     uint32_t desmume_footer_position = 0;
     uint32_t clean_pages_loaded = 0;
-
+    printf(PREFIX"dtr_initialize_backup:%s\n", VAR_SYSTEM_GAMECARD_NAME);
+    
     if (path != NULL) {
         data_file_name = malloc(255);
         memset(data_file_name, 0, 255);
-        sprintf(data_file_name, "%s/%s.dsv", states_path, VAR_SYSTEM_GAMECARD_NAME);
+        sprintf(data_file_name, "%s/backup/%s.dsv", states_path, VAR_SYSTEM_GAMECARD_NAME);
     }
     backup->type = backup_type;
     backup->address_mask = size - 1;
@@ -148,11 +346,339 @@ LAB_08092f94:
     if (data_file_name) {
         free(data_file_name);
     }
+    
+}
+*/
+
+
+
+void dtr_backup_save(long param_1)
+{
+  char *__filename;
+  int iVar1;
+  uint uVar2;
+  uint uVar3;
+  uint uVar4;
+  int iVar5;
+  FILE *pFVar6;
+  long lVar7;
+  unsigned long local_88;
+  unsigned long uStack_80;
+  unsigned long local_78;
+  unsigned long uStack_70;
+  unsigned long local_68;
+  unsigned long uStack_60;
+  unsigned long local_58;
+  unsigned long uStack_50;
+  unsigned long local_48;
+  unsigned long uStack_40;
+  unsigned short local_38;
+  unsigned char local_36;
+  unsigned char local_35;
+  unsigned char local_34;
+  unsigned char local_33;
+  unsigned char local_32;
+  unsigned char local_31;
+  unsigned char local_30;
+  unsigned char local_2f;
+  unsigned int local_2e;
+  char local_2a;
+  unsigned short local_29;
+  unsigned char local_27;
+  unsigned char local_26;
+  unsigned char local_25;
+  unsigned char local_24;
+  unsigned char local_23;
+  unsigned long local_22;
+  unsigned long local_1a;
+  unsigned int  local_12;
+  long local_8;
+  unsigned char desmume_footer[122];
+
+  if (*(char *)(param_1 + 0x2000) == '\0') {
+    return;
+  }
+  
+  __filename = (char *)(param_1 + 0x2000);
+  printf("[trngaje] dtr_backup_save: __filename=%s\n", __filename);
+  
+  iVar1 = *(int *)(param_1 + 0x2408 /*"__cxa_allocate_exception" + param_1 + 0x10*/);
+  pFVar6 = fopen(__filename,"rb+");
+  if (pFVar6 == (FILE *)0x0) {
+    __printf_chk(1," Couldn\'t open backup file %s. Trying to create.\n",__filename);
+    pFVar6 = fopen(__filename,"wb");
+    fclose(pFVar6);
+    pFVar6 = fopen(__filename,"rb+");
+    if (pFVar6 == (FILE *)0x0) {
+      __printf_chk(1,"  Failed to open %s for writing.\n",__filename);
+      goto LAB_00085914;
+    }
+  }
+  puts("Saving backup data file.");
+  uVar4 = iVar1 + 0x4000U >> 0xe;
+  if (*(int *)(param_1 + 0x240c /*"__cxa_allocate_exception" + param_1 + 0x14*/) != 0) {
+    __printf_chk(1," Fixing file size to %d bytes.\n");
+    iVar5 = fileno(pFVar6);
+    iVar5 = ftruncate(iVar5,(ulong)*(uint *)(param_1 + 0x240c/*"__cxa_allocate_exception" + param_1 + 0x14*/));
+    if (iVar5 == 0) {
+      *(unsigned int *)(param_1 + 0x240c/*"__cxa_allocate_exception" + param_1 + 0x14*/) = 0;
+    }
+    else {
+      puts(" Truncation failed.");
+      *(unsigned int *)(param_1 + 0x240c/*"__cxa_allocate_exception" + param_1 + 0x14*/) = 0;
+    }
+  }
+  if (uVar4 != 0) {
+    lVar7 = 0;
+    do {
+      uVar3 = (int)lVar7 << 0xe;
+      for (uVar2 = *(uint *)(param_1 + lVar7 * 4); uVar2 != 0; uVar2 = uVar2 >> 1) {
+        if ((uVar2 & 1) != 0) {
+          fseek(pFVar6,(ulong)uVar3,0);
+          fwrite((void *)(*(long *)(param_1 + 0x2410/*"__cxa_allocate_exception" + param_1 + 0x18*/) + (ulong)uVar3),
+                 0x200,1,pFVar6);
+        }
+        uVar3 = uVar3 + 0x200;
+      }
+      *(unsigned int *)(param_1 + lVar7 * 4) = 0;
+      lVar7 = lVar7 + 1;
+    } while ((uint)lVar7 < uVar4);
+  }
+  if (*(unsigned char *)(param_1 + 0x2427) /*"_ZdlPvm"[param_1 + 6]*/ == '\0') {
+    uVar4 = iVar1 + 1;
+ #if 0   
+
+    local_2a = "_ZdlPvm"[param_1 + 3];
+
+
+    local_33 = (unsigned char)(uVar4 >> 0x18);
+    local_2e = 0;
+    local_29 = 0;
+    local_27 = 0;
+    local_22 = 0x45442d7c00000000;
+    local_1a = 0x415320454d554d53;
+    local_12 = 0x7c2d4556;
+
+#endif
+
+    memcpy(desmume_footer,
+           "|<--Snip above here to create a raw sav by excluding this DeSmuME savedata footer:",0x52
+          );
+    desmume_footer[0x5e] = *(unsigned char *)(param_1 + 0x2424); //backup->address_bytes; // 0x003f6000 + 100 + 0x940 + 0x2424
+    
+    //(uint32_t) (*((uint64_t *)VAR_SDL_SCREEN_CURSOR)); 
+    
+    desmume_footer[0x52] = (u8)uVar4;
+    desmume_footer[0x55] = (u8)((uint)uVar4 >> 0x18);
+    desmume_footer[0x53] = (u8)((uint)uVar4 >> 8);
+    desmume_footer[0x72] = 'E';
+    desmume_footer[0x73] = ' ';
+    desmume_footer[0x74] = 'S';
+    desmume_footer[0x75] = 'A';
+    desmume_footer[0x54] = (u8)((uint)uVar4 >> 0x10);
+    desmume_footer[0x6a] = '|';
+    desmume_footer[0x6b] = '-';
+    desmume_footer[0x6c] = 'D';
+    desmume_footer[0x6d] = 'E';
+    desmume_footer[0x6e] = 'S';
+    desmume_footer[0x6f] = 'M';
+    desmume_footer[0x70] = 'U';
+    desmume_footer[0x71] = 'M';
+    desmume_footer[0x76] = 'V';
+    desmume_footer[0x77] = 'E';
+    desmume_footer[0x78] = '-';
+    desmume_footer[0x79] = '|';
+    desmume_footer[0x56] = desmume_footer[0x52];
+    desmume_footer[0x57] = desmume_footer[0x53];
+    desmume_footer[0x58] = desmume_footer[0x54];
+    desmume_footer[0x59] = desmume_footer[0x55];
+    desmume_footer[0x5a] = 0;//uVar2;
+    desmume_footer[0x5b] = 0;//uVar2;
+    desmume_footer[0x5c] = 0;//uVar2;
+    desmume_footer[0x5d] = 0;//uVar2;
+    desmume_footer[0x5f] = 0;//uVar2;
+    desmume_footer[0x60] = 0;//uVar2;
+    desmume_footer[0x61] = 0;//uVar2;
+    desmume_footer[0x62] = desmume_footer[0x52];
+    desmume_footer[99] = desmume_footer[0x53];
+    desmume_footer[100] = desmume_footer[0x54];
+    desmume_footer[0x65] = desmume_footer[0x55];
+    desmume_footer[0x66] = 0;//uVar2;
+    desmume_footer[0x67] = 0;//uVar2;
+    desmume_footer[0x68] = 0;//uVar2;
+    desmume_footer[0x69] = 0;//uVar2;
+    
+    fseek(pFVar6,(ulong)uVar4,0);
+    //fwrite(&local_88,0x7a,1,pFVar6);
+    fwrite(desmume_footer,0x7a,1,pFVar6);
+    puts(" Saving DeSmuME footer.");
+    *(unsigned char *)(param_1 + 0x2427) /*"_ZdlPvm"[param_1 + 6]*/ = '\x01';
+  }
+  fclose(pFVar6);
+LAB_00085914:
+
+    return;
+ //}
+
 }
+/*
+struct backup_struct {
+    u32 dirty_page_bitmap[2048]; // size 0x2000
+    char file_path[1024]; // size 0x400
+    enum backup_type_enum type; // size 4
+    u32 access_address;
+    u32 address_mask;
+    u32 fix_file_size;
+    
+    u8 *data; // size 8
+    u8 jedec_id[4];
+    u32 write_frame_counter;
+    
+    u16 mode;
+    u8 state;
+    u8 status;
+    
+    u8 address_bytes;
+    u8 state_step;
+    u8 firmware;
+    u8 footer_written;
+};
+*/
+
+#if 0
+void backup_save(backup_struct *backup)
+
+{
+  uint uVar1;
+  u8 uVar2;
+  int iVar3;
+  FILE *pFVar4;
+  FILE *data_file;
+  u8 *__ptr;
+  u32 uVar5;
+  uint uVar6;
+  u32 dirty_page_block;
+  u32 backup_size;
+  int __off;
+  int iVar7;
+  u32 write_offset_in_block;
+  char *__filename;
+  backup_struct *pbVar8;
+  u32 dirty_page_blocks;
+  u8 desmume_footer [122];
+  
+  iVar3 = __stack_chk_guard;
+  __filename = backup->file_path;
+  uVar5 = backup->address_mask;
+  pFVar4 = fopen(__filename,"rb+");
+  if (pFVar4 == (FILE *)0x0) {
+    __printf_chk(1," Couldn\'t open backup file %s. Trying to create.\n",__filename);
+    pFVar4 = fopen(__filename,"wb");
+    fclose(pFVar4);
+    pFVar4 = fopen(__filename,"rb+");
+    if (pFVar4 == (FILE *)0x0) {
+      __printf_chk(1,"  Failed to open %s for writing.\n",__filename);
+      goto LAB_08092908;
+    }
+  }
+  puts("Saving backup data file.");
+  uVar1 = uVar5 + 0x4000 >> 0xe;
+  if (backup->fix_file_size != 0) {
+    __printf_chk(1," Fixing file size to %d bytes.\n");
+    iVar7 = fileno(pFVar4);
+    iVar7 = ftruncate(iVar7,backup->fix_file_size);
+    if (iVar7 != 0) {
+      puts(" Truncation failed.");
+    }
+    backup->fix_file_size = 0;
+  }
+  if (uVar1 != 0) {
+    iVar7 = 0;
+    pbVar8 = backup;
+    do {
+      __off = iVar7;
+      for (uVar6 = pbVar8->dirty_page_bitmap[0]; uVar6 != 0; uVar6 = uVar6 >> 1) {
+        while ((uVar6 & 1) != 0) {
+          fseek(pFVar4,__off,0);
+          __ptr = backup->data + __off;
+          __off = __off + 0x200;
+          fwrite(__ptr,0x200,1,pFVar4);
+          uVar6 = uVar6 >> 1;
+          if (uVar6 == 0) goto LAB_080927f4;
+        }
+        __off = __off + 0x200;
+      }
+LAB_080927f4:
+      iVar7 = iVar7 + 0x4000;
+      pbVar8->dirty_page_bitmap[0] = 0;
+      pbVar8 = (backup_struct *)(pbVar8->dirty_page_bitmap + 1);
+    } while (iVar7 != uVar1 << 0xe);
+  }
+  uVar2 = backup->footer_written;
+  if (uVar2 == '\0') {
+    iVar7 = uVar5 + 1;
+    memcpy(desmume_footer,
+           "|<--Snip above here to create a raw sav by excluding this DeSmuME savedata footer:",0x52
+          );
+    desmume_footer[0x5e] = backup->address_bytes;
+    desmume_footer[0x52] = (u8)iVar7;
+    desmume_footer[0x55] = (u8)((uint)iVar7 >> 0x18);
+    desmume_footer[0x53] = (u8)((uint)iVar7 >> 8);
+    desmume_footer[0x72] = 'E';
+    desmume_footer[0x73] = ' ';
+    desmume_footer[0x74] = 'S';
+    desmume_footer[0x75] = 'A';
+    desmume_footer[0x54] = (u8)((uint)iVar7 >> 0x10);
+    desmume_footer[0x6a] = '|';
+    desmume_footer[0x6b] = '-';
+    desmume_footer[0x6c] = 'D';
+    desmume_footer[0x6d] = 'E';
+    desmume_footer[0x6e] = 'S';
+    desmume_footer[0x6f] = 'M';
+    desmume_footer[0x70] = 'U';
+    desmume_footer[0x71] = 'M';
+    desmume_footer[0x76] = 'V';
+    desmume_footer[0x77] = 'E';
+    desmume_footer[0x78] = '-';
+    desmume_footer[0x79] = '|';
+    desmume_footer[0x56] = desmume_footer[0x52];
+    desmume_footer[0x57] = desmume_footer[0x53];
+    desmume_footer[0x58] = desmume_footer[0x54];
+    desmume_footer[0x59] = desmume_footer[0x55];
+    desmume_footer[0x5a] = uVar2;
+    desmume_footer[0x5b] = uVar2;
+    desmume_footer[0x5c] = uVar2;
+    desmume_footer[0x5d] = uVar2;
+    desmume_footer[0x5f] = uVar2;
+    desmume_footer[0x60] = uVar2;
+    desmume_footer[0x61] = uVar2;
+    desmume_footer[0x62] = desmume_footer[0x52];
+    desmume_footer[99] = desmume_footer[0x53];
+    desmume_footer[100] = desmume_footer[0x54];
+    desmume_footer[0x65] = desmume_footer[0x55];
+    desmume_footer[0x66] = uVar2;
+    desmume_footer[0x67] = uVar2;
+    desmume_footer[0x68] = uVar2;
+    desmume_footer[0x69] = uVar2;
+    fseek(pFVar4,iVar7,0);
+    fwrite(desmume_footer,0x7a,1,pFVar4);
+    puts(" Saving DeSmuME footer.");
+    backup->footer_written = '\x01';
+  }
+  fclose(pFVar4);
+LAB_08092908:
+  if (iVar3 != __stack_chk_guard) {
+                    /* WARNING: Subroutine does not return */
+    __stack_chk_fail();
+  }
+  return;
+}
+#endif
+
 
 int dtr_savestate(int slot)
 {
-#if defined(MMIYOO) || defined(QX1000)
+#if defined(MMIYOO) || defined(QX1000) || defined(RG35XXH)
     char buf[255] = {0};
     nds_screen_copy16 _func0 = (nds_screen_copy16)FUN_SCREEN_COPY16;
 
@@ -171,7 +697,7 @@ int dtr_savestate(int slot)
         else {
             nds_save_state _func1 = (nds_save_state)FUN_SAVE_STATE;
 
-            sprintf(buf, "%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, slot);
+            sprintf(buf, "savestates/%s_%d.dss", VAR_SYSTEM_GAMECARD_NAME, slot);
             _func1((void*)VAR_SYSTEM, states_path, buf, d0, d1);
         }
     }
@@ -206,7 +732,7 @@ int dtr_savestate(int slot)
 
 int dtr_loadstate(int slot)
 {
-#if defined(MMIYOO) || defined(QX1000)
+#if defined(MMIYOO) || defined(QX1000) || defined(RG35XXH)
     char buf[255] = {0};
 
     if (is_hooked == 0) {
@@ -217,7 +743,7 @@ int dtr_loadstate(int slot)
     else {
         nds_load_state _func = (nds_load_state)FUN_LOAD_STATE;
 
-        sprintf(buf, "%s/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, slot);
+        sprintf(buf, "%s/savestates/%s_%d.dss", states_path, VAR_SYSTEM_GAMECARD_NAME, slot);
         _func((void*)VAR_SYSTEM, buf, 0, 0, 0);
     }
 #endif
@@ -238,24 +764,67 @@ int dtr_quit(void)
 
 void detour_init(size_t page, const char *path)
 {
+    char addr1[20],addr2[20], perm[8], offset[20], dev[10],inode[30],pathname[PATH_MAX];
+    FILE* fp;
+    
     page_size = page;
 
     is_hooked = 0;
+
+    fp=fopen("/proc/self/maps", "r");
+    if (fp != NULL) {
+    	char buf[200];
+    	while (fgets(buf, 200, fp) != NULL) {
+    		//printf("%s", buf);
+    		_pmparser_split_line(buf, addr1, addr2, perm, offset, dev, inode, pathname);
+    		if (strcmp(basename(pathname), "drastic") == 0) {
+    			printf("%s, %s, %s, %s, %s, %s, %s\n", addr1, addr2, perm, offset, dev, inode, pathname);
+    			
+    			base_addr = (uint64_t)strtol(addr1, NULL, 16);
+    			if (strcmp(perm, "r-xp") == 0)
+    				base_addr_rx = base_addr; // - 0xd100;
+    			else if (strcmp(perm, "r--p") == 0)
+    				base_addr_r = base_addr;
+    			else if (strcmp(perm, "rw-p") == 0)
+    				base_addr_rw = base_addr - 0x15b000;
+    			printf("base_addr = 0x%lx\n", base_addr);
+    		}
+    	}
+    	fclose(fp);
+    	printf("base_addr_rx = 0x%lx\n", base_addr_rx);
+    	printf("base_addr_r = 0x%lx\n", base_addr_r);
+    	printf("base_addr_rw = 0x%lx\n", base_addr_rw);
+    }
+    
     if ((path != NULL) && (path[0] != 0)) {
         is_hooked = 1;
         strcpy(states_path, path);
         detour_hook(FUN_LOAD_STATE_INDEX, (intptr_t)dtr_load_state_index);
         detour_hook(FUN_SAVE_STATE_INDEX, (intptr_t)dtr_save_state_index);
         detour_hook(FUN_INITIALIZE_BACKUP, (intptr_t)dtr_initialize_backup);
+        //detour_hook(FUN_BACKUP_SAVE, (intptr_t)dtr_backup_save);
         printf(PREFIX"Enabled savestate hooking\n");
     }
+
+    detour_hook(FUN_BACKUP_SAVE, (intptr_t)dtr_backup_save);
 }
 
-void detour_hook(uint32_t old_func, uint32_t new_func)
+void detour_hook(uint64_t old_func, uint64_t new_func)
 {
-    volatile uint8_t *base = (uint8_t *)(intptr_t)old_func;
+    int i;
+    
+    volatile uint8_t *base = (uint8_t *)(intptr_t)(/*base_addr_rx + */old_func);
+    printf(PREFIX"detour_hook++: old_func=0x%lx\n", base);
+    printf(PREFIX"detour_hook++: new_func=0x%lx\n", new_func);
+    mprotect(ALIGN_ADDR(base), page_size, PROT_READ | PROT_WRITE | PROT_EXEC);
+
+    for(i=0; i<16; i++) {
+    	printf("0x%x,", base[i]);
+    }
+    
+/*
 
-    mprotect(ALIGN_ADDR(base), page_size, PROT_READ | PROT_WRITE);
+// for armhf
     base[0] = 0x04;
     base[1] = 0xf0;
     base[2] = 0x1f;
@@ -264,33 +833,73 @@ void detour_hook(uint32_t old_func, uint32_t new_func)
     base[5] = new_func >> 8;
     base[6] = new_func >> 16;
     base[7] = new_func >> 24;
+	*/
+	
+	//for aarch64
+	/*
+    400078: 58000049 ldr x9, 400080 <_start+0x8>
+    40007c: d61f0120 br x9
+    400080: 55667788 .word 0x55667788
+    400084: 11223344 .word 0x11223344
+  	*/
+  	/*
+    base[0] = 0x70;
+    base[1] = 0x00;
+    base[2] = 0x00;
+    base[3] = 0x10;
+    base[4] = 0x11;
+    base[5] = 0x02;
+    base[6] = 0x40;
+    base[7] = 0xf9;
+    base[8] = 0x20;
+    base[9] = 0x02;
+    base[10] = 0x1f;
+    base[11] = 0xd6;
+
+ */
+/*
+    memcpy(base, "\xe1\x03\xbe\xa9\x40\x00\x00\x58\x00\x00\x1f\xd6\x00\x00\x00\x00"
+		"\x00\x00\x00\x00\xe1\x03\xc2\xa8", 24);
+    //memcpy(base + 12, new_func, 8);
+    base[12] = new_func >> 0;
+    base[13] = new_func >> 8;
+    base[14] = new_func >> 16;
+    base[15] = new_func >> 24;
+    base[16] = new_func >> 32;
+    base[17] = new_func >> 40;
+    base[18] = new_func >> 48;
+    base[19] = new_func >> 56;  
+    */
+    //base[0] = 0x40; // x0 : 1st parameter of function is corrupted
+    base[0] = 0x51; // x17
+    //base[0] = 0x47;
+    //base[0] = 0x48; // x8
+    //base[0] = 0x49; // x9
+    base[1] = 0x00;
+    base[2] = 0x00;
+    base[3] = 0x58;
+    //base[4] = 0x00; // x0
+    //base[5] = 0x00; // x0
+    
+    base[4] = 0x20; // x17
+    base[5] = 0x02; // x17
+         
+    base[6] = 0x1f;
+    base[7] = 0xd6;
+    base[8] = new_func >> 0;
+    base[9] = new_func >> 8;
+    base[10] = new_func >> 16;
+    base[11] = new_func >> 24;
+    base[12] = new_func >> 32;
+    base[13] = new_func >> 40;
+    base[14] = new_func >> 48;
+    base[15] = new_func >> 56;
+    printf(PREFIX"detour_hook--\n");
 }
 
 void detour_quit(void)
 {
 }
 
-#ifdef UNITTEST
-TEST_GROUP(detour);
-
-TEST_SETUP(detour)
-{
-}
-
-TEST_TEAR_DOWN(detour)
-{
-}
-
-TEST(detour, detour_init)
-{
-    detour_init(0, "/tmp");
-    TEST_ASSERT_EQUAL_INT(page_size, 0);
-    TEST_ASSERT_EQUAL_STRING(states_path, "/tmp");
-}
 
-TEST_GROUP_RUNNER(detour)
-{
-    RUN_TEST_CASE(detour, detour_init);
-}
-#endif
 
diff --git a/detour/pmparser.c b/detour/pmparser.c
new file mode 100644
index 0000000..e875f00
--- /dev/null
+++ b/detour/pmparser.c
@@ -0,0 +1,227 @@
+/*
+ @Author	: ouadimjamal@gmail.com
+ @date		: December 2015
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.  No representations are made about the suitability of this
+software for any purpose.  It is provided "as is" without express or
+implied warranty.
+*/
+
+#include "pmparser.h"
+
+/**
+ * gobal variables
+ */
+//procmaps_struct* g_last_head=NULL;
+//procmaps_struct* g_current=NULL;
+
+
+procmaps_iterator* pmparser_parse(int pid){
+	procmaps_iterator* maps_it = malloc(sizeof(procmaps_iterator));
+	char maps_path[500];
+	if(pid>=0 ){
+		sprintf(maps_path,"/proc/%d/maps",pid);
+	}else{
+		sprintf(maps_path,"/proc/self/maps");
+	}
+	FILE* file=fopen(maps_path,"r");
+	if(!file){
+		fprintf(stderr,"pmparser : cannot open the memory maps, %s\n",strerror(errno));
+		return NULL;
+	}
+	int ind=0;char buf[PROCMAPS_LINE_MAX_LENGTH];
+	int c;
+	procmaps_struct* list_maps=NULL;
+	procmaps_struct* tmp;
+	procmaps_struct* current_node=list_maps;
+	char addr1[20],addr2[20], perm[8], offset[20], dev[10],inode[30],pathname[PATH_MAX];
+	while( !feof(file) ){
+		if (fgets(buf,PROCMAPS_LINE_MAX_LENGTH,file) == NULL){
+			fprintf(stderr,"pmparser : fgets failed, %s\n",strerror(errno));
+			return NULL;
+		}
+		//allocate a node
+		tmp=(procmaps_struct*)malloc(sizeof(procmaps_struct));
+		//fill the node
+		_pmparser_split_line(buf,addr1,addr2,perm,offset, dev,inode,pathname);
+		//printf("#%s",buf);
+		//printf("%s-%s %s %s %s %s\t%s\n",addr1,addr2,perm,offset,dev,inode,pathname);
+		//addr_start & addr_end
+		unsigned long l_addr_start;
+		sscanf(addr1,"%lx",(long unsigned *)&tmp->addr_start );
+		sscanf(addr2,"%lx",(long unsigned *)&tmp->addr_end );
+		//size
+		tmp->length=(unsigned long)(tmp->addr_end-tmp->addr_start);
+		//perm
+		strcpy(tmp->perm,perm);
+		tmp->is_r=(perm[0]=='r');
+		tmp->is_w=(perm[1]=='w');
+		tmp->is_x=(perm[2]=='x');
+		tmp->is_p=(perm[3]=='p');
+
+		//offset
+		sscanf(offset,"%lx",&tmp->offset );
+		//device
+		strcpy(tmp->dev,dev);
+		//inode
+		tmp->inode=atoi(inode);
+		//pathname
+		strcpy(tmp->pathname,pathname);
+		tmp->next=NULL;
+		//attach the node
+		if(ind==0){
+			list_maps=tmp;
+			list_maps->next=NULL;
+			current_node=list_maps;
+		}
+		current_node->next=tmp;
+		current_node=tmp;
+		ind++;
+		//printf("%s",buf);
+	}
+
+	//close file
+	fclose(file);
+
+
+	//g_last_head=list_maps;
+	maps_it->head = list_maps;
+	maps_it->current =  list_maps;
+	return maps_it;
+}
+
+
+procmaps_struct* pmparser_next(procmaps_iterator* p_procmaps_it){
+	if(p_procmaps_it->current == NULL)
+		return NULL;
+	procmaps_struct* p_current = p_procmaps_it->current;
+	p_procmaps_it->current = p_procmaps_it->current->next;
+	return p_current;
+	/*
+	if(g_current==NULL){
+		g_current=g_last_head;
+	}else
+		g_current=g_current->next;
+
+	return g_current;
+	*/
+}
+
+
+
+void pmparser_free(procmaps_iterator* p_procmaps_it){
+	procmaps_struct* maps_list = p_procmaps_it->head;
+	if(maps_list==NULL) return ;
+	procmaps_struct* act=maps_list;
+	procmaps_struct* nxt=act->next;
+	while(act!=NULL){
+		free(act);
+		act=nxt;
+		if(nxt!=NULL)
+			nxt=nxt->next;
+	}
+	free(p_procmaps_it);
+}
+
+
+void _pmparser_split_line(
+		char*buf,char*addr1,char*addr2,
+		char*perm,char* offset,char* device,char*inode,
+		char* pathname){
+	//
+	int orig=0;
+	int i=0;
+	//addr1
+	while(buf[i]!='-'){
+		addr1[i-orig]=buf[i];
+		i++;
+	}
+	addr1[i]='\0';
+	i++;
+	//addr2
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' '){
+		addr2[i-orig]=buf[i];
+		i++;
+	}
+	addr2[i-orig]='\0';
+
+	//perm
+	while(buf[i]=='\t' || buf[i]==' ')
+		i++;
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' '){
+		perm[i-orig]=buf[i];
+		i++;
+	}
+	perm[i-orig]='\0';
+	//offset
+	while(buf[i]=='\t' || buf[i]==' ')
+		i++;
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' '){
+		offset[i-orig]=buf[i];
+		i++;
+	}
+	offset[i-orig]='\0';
+	//dev
+	while(buf[i]=='\t' || buf[i]==' ')
+		i++;
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' '){
+		device[i-orig]=buf[i];
+		i++;
+	}
+	device[i-orig]='\0';
+	//inode
+	while(buf[i]=='\t' || buf[i]==' ')
+		i++;
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' '){
+		inode[i-orig]=buf[i];
+		i++;
+	}
+	inode[i-orig]='\0';
+	//pathname
+	pathname[0]='\0';
+	while(buf[i]=='\t' || buf[i]==' ')
+		i++;
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' ' && buf[i]!='\n'){
+		pathname[i-orig]=buf[i];
+		i++;
+	}
+	pathname[i-orig]='\0';
+
+}
+
+void pmparser_print(procmaps_struct* map, int order){
+
+	procmaps_struct* tmp=map;
+	int id=0;
+	if(order<0) order=-1;
+	while(tmp!=NULL){
+		//(unsigned long) tmp->addr_start;
+		if(order==id || order==-1){
+			printf("Backed by:\t%s\n",strlen(tmp->pathname)==0?"[anonym*]":tmp->pathname);
+			printf("Range:\t\t%p-%p\n",tmp->addr_start,tmp->addr_end);
+			printf("Length:\t\t%ld\n",tmp->length);
+			printf("Offset:\t\t%ld\n",tmp->offset);
+			printf("Permissions:\t%s\n",tmp->perm);
+			printf("Inode:\t\t%d\n",tmp->inode);
+			printf("Device:\t\t%s\n",tmp->dev);
+		}
+		if(order!=-1 && id>order)
+			tmp=NULL;
+		else if(order==-1){
+			printf("#################################\n");
+			tmp=tmp->next;
+		}else tmp=tmp->next;
+
+		id++;
+	}
+}
diff --git a/detour/pmparser.h b/detour/pmparser.h
new file mode 100644
index 0000000..1162470
--- /dev/null
+++ b/detour/pmparser.h
@@ -0,0 +1,99 @@
+/*
+ @Author	: ouadimjamal@gmail.com
+ @date		: December 2015
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.  No representations are made about the suitability of this
+software for any purpose.  It is provided "as is" without express or
+implied warranty.
+
+ */
+
+#ifndef H_PMPARSER
+#define H_PMPARSER
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <linux/limits.h>
+
+//maximum line length in a procmaps file
+#define PROCMAPS_LINE_MAX_LENGTH  (PATH_MAX + 100) 
+/**
+ * procmaps_struct
+ * @desc hold all the information about an area in the process's  VM
+ */
+typedef struct procmaps_struct{
+	void* addr_start; 	//< start address of the area
+	void* addr_end; 	//< end address
+	unsigned long length; //< size of the range
+
+	char perm[5];		//< permissions rwxp
+	short is_r;			//< rewrote of perm with short flags
+	short is_w;
+	short is_x;
+	short is_p;
+
+	long offset;	//< offset
+	char dev[12];	//< dev major:minor
+	int inode;		//< inode of the file that backs the area
+
+	char pathname[600];		//< the path of the file that backs the area
+	//chained list
+	struct procmaps_struct* next;		//<handler of the chinaed list
+} procmaps_struct;
+
+/**
+ * procmaps_iterator
+ * @desc holds iterating information
+ */
+typedef struct procmaps_iterator{
+	procmaps_struct* head;
+	procmaps_struct* current;
+} procmaps_iterator;
+/**
+ * pmparser_parse
+ * @param pid the process id whose memory map to be parser. the current process if pid<0
+ * @return an iterator over all the nodes
+ */
+procmaps_iterator* pmparser_parse(int pid);
+
+/**
+ * pmparser_next
+ * @description move between areas
+ * @param p_procmaps_it the iterator to move on step in the chained list
+ * @return a procmaps structure filled with information about this VM area
+ */
+procmaps_struct* pmparser_next(procmaps_iterator* p_procmaps_it);
+/**
+ * pmparser_free
+ * @description should be called at the end to free the resources
+ * @param p_procmaps_it the iterator structure returned by pmparser_parse
+ */
+void pmparser_free(procmaps_iterator* p_procmaps_it);
+
+/**
+ * _pmparser_split_line
+ * @description internal usage
+ */
+void _pmparser_split_line(char*buf,char*addr1,char*addr2,char*perm, char* offset, char* device,char*inode,char* pathname);
+
+/**
+ * pmparser_print
+ * @param map the head of the list
+ * @order the order of the area to print, -1 to print everything
+ */
+void pmparser_print(procmaps_struct* map,int order);
+
+
+
+
+
+#endif
diff --git a/drastic/resources/lang/chinese_cn b/drastic/resources/lang/chinese_cn
index e6344f2..0169224 100644
--- a/drastic/resources/lang/chinese_cn
+++ b/drastic/resources/lang/chinese_cn
@@ -6,6 +6,7 @@ Border=小画边框色
 Position=小画位置
 Alt. Display=快捷切换显示
 Volume=音量
+Disable=禁用
 Disabled=禁用
 Touchpad=触控位置
 Wallpaper=壁纸
@@ -106,3 +107,9 @@ Blur=模糊风格
 Cursor=菜单鼠标
 Show=显示
 Hide=隐藏
+CPU Clock=CPU频率
+CPU Core=CPU核心
+Joy Mode=摇杆模式
+Joy DZone=摇杆死区
+D-Pad=十字键
+Stylus=触控笔
diff --git a/drastic/resources/lang/chinese_tw b/drastic/resources/lang/chinese_tw
index c9481b9..5cec504 100644
--- a/drastic/resources/lang/chinese_tw
+++ b/drastic/resources/lang/chinese_tw
@@ -6,6 +6,7 @@ Border=小視窗邊框色
 Position=小視窗位置
 Alt. Display=熱鍵切換顯示
 Volume=音量
+Disable=禁用
 Disabled=禁用
 Touchpad=觸控位置
 Wallpaper=背景
@@ -106,3 +107,9 @@ Blur=模糊風格
 Cursor=菜單游標
 Show=顯示
 Hide=隱藏
+CPU Clock=CPU頻率
+CPU Core=CPU核心
+Joy Mode=搖桿模式
+Joy DZone=搖桿死區
+D-Pad=十字鍵
+Stylus=觸控筆
diff --git a/drastic/resources/lang/korean_kr b/drastic/resources/lang/korean_kr
new file mode 100644
index 0000000..9dc31c9
--- /dev/null
+++ b/drastic/resources/lang/korean_kr
@@ -0,0 +1,108 @@
+CPU=CPU
+Overlay=오버레이
+Display=화면
+Alpha=알파값 
+Border=테두리
+Position=위치
+Alt. Display=대체 화면
+Volume=소리 크기
+Disabled=비활성화
+Touchpad=터치패드
+Wallpaper=바탕화면
+Quick Save=빠른 저장하기
+Quick Load=빠른 불러오기
+Fast Forward=빠르게 플레이
+Top-Right=우측 상단
+Top-Left=좌측 상단
+Bottom-Left=좌측 하단
+Bottom-Right=우측 하단
+White=흰색
+Red=붉은색
+Green=녹색
+Blue=파란색
+Black=검정색
+Yellow=노란색
+Cyan=하늘색
+Version=버젼
+Change Options=옵션 변경
+Configure Controls=입력 설정
+Configure Firmware=펌웨어 설정
+Configure Cheats=치트 설정
+Load state=상태 불러오기
+Save state=상태 저장하기
+Load new game=새로운 게임 불러오기
+Restart game=게임 재 시작하기
+Return to game=게임으로 돌아가기
+Exit DraStic=DraStic 끝내기
+Keys=키
+Frame skip type=프레임 스킵 타입
+automatic=자동
+manual=수동
+yes=네
+no=아니오
+Yes=네
+No=아니오
+none=없음
+None=없음
+Frame skip value=프레임 스킵 값
+Screen orientation=화면 회전
+vertical=수직
+horizontal=수평
+single=단일
+Screen swap=화면 교환
+Show speed=표시 속도
+Enable sound=소리 활성화
+Fast forward=빠른 진행
+Mirror touchscreen=터치스크린 반전
+Compress savestates=savestates 압축하기
+Snapshot in savestates=Snapshot in savestates
+Enable cheats=치트 활성화
+Uncompress ROMs=ROMs 압축 풀기
+Backup in savestates=savestates 백업하기
+Speed override=Speed override
+Fix main 2D screen=Fix main 2D screen
+Disable edge marking=edge marking 비활성화
+High-resolution 3D=고해상도 3D
+Threaded 3D=Threaded 3D
+Delete game-specific config=게임 지정 설정 값 제거
+Exit: save for all games=끝내기: 모든게임을 위한 설정 값 저장
+Exit: save for this game=끝내기: 에 게임에만 설정 값 저장
+Exit without saving=저장 없이 끝내기
+Username=사용자 이름
+Language=언어
+Favorite Color=좋아하는 색
+Birthday Month=태어난 달
+Birthday Day=태어난 날
+English=영어
+French=프랑스어
+German=독일어
+Italian=이탈리아어
+Spanish=스페인어
+Chinese=중국어
+Japanese=일본어
+January=1월
+February=2월
+March=3월
+April=4월
+May=5월
+June=6월
+July=7월
+August=8월
+September=9월
+October=10월
+November=11월
+December=12월
+Extra Controls=기타 제어
+Restore default controls=기본 설정값으로 복구
+Unmapped=설정 안함
+Hotkey=핫키
+Swap L1-L2=L1과 L2 교환
+Swap R1-R2=R1과 R2 교환
+Mode=모드
+Pen X Speed=펜 X축 속도
+Pen Y Speed=펜 Y축 속도
+Pixel=펙셀
+Blur=블러
+Cursor=커서
+Show=표시
+Hide=감추기
diff --git a/drastic/resources/pen/6_cp.png b/drastic/resources/pen/6_cp.png
new file mode 100644
index 0000000..a58b0de
Binary files /dev/null and b/drastic/resources/pen/6_cp.png differ
diff --git a/sdl2/configure.ac b/sdl2/configure.ac
index e5a7647..fe3a511 100644
--- a/sdl2/configure.ac
+++ b/sdl2/configure.ac
@@ -2398,12 +2398,25 @@ CheckQNXAudio()
     fi
 }
 
+CheckA30Video()
+{
+    if test x$enable_video = xyes; then
+        AC_DEFINE(SDL_VIDEO_DRIVER_MMIYOO, 1, [ ])
+        AC_DEFINE(SDL_VIDEO_RENDER_MMIYOO, 1, [ ])
+        SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c $srcdir/src/video/mmiyoo/*.S"
+        have_video=yes
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -DA30 -fPIC -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3 -I../detour -I/opt/a30/arm-a30-linux-gnueabihf/sysroot/usr/include/SDL2"
+        EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L. -lMali -lrt -lSDL2_image -lSDL2_ttf -ljson-c -L../detour -ldtr"
+        SUMMARY_video="${SUMMARY_video} mmiyoo"
+    fi
+}
+
 CheckMMiyooVideo()
 {
     if test x$enable_video = xyes; then
         AC_DEFINE(SDL_VIDEO_DRIVER_MMIYOO, 1, [ ])
         AC_DEFINE(SDL_VIDEO_RENDER_MMIYOO, 1, [ ])
-        SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c $srcdir/src/video/mmiyoo/*.S"
         have_video=yes
         EXTRA_CFLAGS="$EXTRA_CFLAGS -DMMIYOO -fPIC -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3 -I../mmiyoo/inc -I../detour -I/opt/mmiyoo/arm-buildroot-linux-gnueabihf/sysroot/usr/include/SDL2"
         EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L. -lEGL -lGLESv2 -lrt -lSDL2_image -lSDL2_ttf -ljson-c -L../detour -ldtr"
@@ -2411,27 +2424,28 @@ CheckMMiyooVideo()
     fi
 }
 
-CheckTrimuiVideo()
+CheckRG35XXHVideo()
 {
     if test x$enable_video = xyes; then
         AC_DEFINE(SDL_VIDEO_DRIVER_MMIYOO, 1, [ ])
         AC_DEFINE(SDL_VIDEO_RENDER_MMIYOO, 1, [ ])
         SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c"
         have_video=yes
-        EXTRA_CFLAGS="$EXTRA_CFLAGS -DTRIMUI -fPIC -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3 -I../trimui/inc -I../detour -I/opt/mmiyoo/arm-buildroot-linux-gnueabihf/sysroot/usr/include/SDL2"
-        EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L. -lEGL -lGLESv2 -lrt -lSDL2_image -lSDL2_ttf -ljson-c -L../detour -ldtr"
+   
+        EXTRA_CFLAGS="$EXTRA_CFLAGS %CFLAGS%  -DRG35XXH -DRG35XXH_GL -fPIC  -O3 -I../mmiyoo/inc -I../detour -I/%SDL2%"
+        EXTRA_LDFLAGS="$EXTRA_LDFLAGS  %LDFLAGS% -lmali -lEGL -lGLESv2 -lrt -lSDL2_image -lSDL2_ttf -ljson-c -L../detour -ldtr"
         SUMMARY_video="${SUMMARY_video} mmiyoo"
     fi
 }
 
-CheckFunkeysVideo()
+CheckTrimuiVideo()
 {
     if test x$enable_video = xyes; then
         AC_DEFINE(SDL_VIDEO_DRIVER_MMIYOO, 1, [ ])
         AC_DEFINE(SDL_VIDEO_RENDER_MMIYOO, 1, [ ])
-        SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c $srcdir/src/video/mmiyoo/*.S"
         have_video=yes
-        EXTRA_CFLAGS="$EXTRA_CFLAGS -DFUNKEYS -fPIC -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3 -I../funkeys/inc -I../detour -I/opt/mmiyoo/arm-buildroot-linux-gnueabihf/sysroot/usr/include/SDL2"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -DTRIMUI -fPIC -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3 -I../trimui/inc -I../detour -I/opt/mmiyoo/arm-buildroot-linux-gnueabihf/sysroot/usr/include/SDL2"
         EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L. -lEGL -lGLESv2 -lrt -lSDL2_image -lSDL2_ttf -ljson-c -L../detour -ldtr"
         SUMMARY_video="${SUMMARY_video} mmiyoo"
     fi
@@ -2442,7 +2456,7 @@ CheckPandoraVideo()
     if test x$enable_video = xyes; then
         AC_DEFINE(SDL_VIDEO_DRIVER_MMIYOO, 1, [ ])
         AC_DEFINE(SDL_VIDEO_RENDER_MMIYOO, 1, [ ])
-        SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c $srcdir/src/video/mmiyoo/*.S"
         have_video=yes
         EXTRA_CFLAGS="$EXTRA_CFLAGS -DPANDORA -fPIC -mcpu=cortex-a8 -mtune=cortex-a8 -mfpu=neon -ffast-math -O3 -I../detour -I/usr/local/include/SDL2"
         EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L. -lEGL -lGLESv2 -lrt -lSDL2_image -lSDL2_ttf -ljson-c -L../detour -ldtr"
@@ -2455,7 +2469,7 @@ CheckQX1000Video()
     if test x$enable_video = xyes; then
         AC_DEFINE(SDL_VIDEO_DRIVER_MMIYOO, 1, [ ])
         AC_DEFINE(SDL_VIDEO_RENDER_MMIYOO, 1, [ ])
-        SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/mmiyoo/*.c $srcdir/src/video/mmiyoo/*.S"
         have_video=yes
         EXTRA_CFLAGS="$EXTRA_CFLAGS -DQX1000 -fPIC -mcpu=cortex-a53 -mtune=cortex-a53 -mfpu=neon -O3 -I../detour -I/usr/local/include/SDL2"
         EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L. -lwayland-client -lwayland-egl -lEGL -lGLESv2 -lrt -lSDL2_image -lSDL2_ttf -ljson-c -L../detour -ldtr"
@@ -2476,6 +2490,20 @@ CheckUnittestVideo()
     fi
 }
 
+CheckA30Audio()
+{
+    if test x$enable_audio = xyes; then
+        AC_DEFINE(SDL_AUDIO_DRIVER_MMIYOO, 1, [ ])
+        SOURCES="$SOURCES $srcdir/src/audio/mmiyoo/*.c"
+        have_audio=yes
+        if test x$HOST = xarm-linux; then
+            EXTRA_CFLAGS="$EXTRA_CFLAGS -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -l:libasound.so.2"
+        fi
+        SUMMARY_audio="${SUMMARY_audio} mmiyoo"
+    fi
+}
+
 CheckMMiyooAudio()
 {
     if test x$enable_audio = xyes; then
@@ -2490,21 +2518,21 @@ CheckMMiyooAudio()
     fi
 }
 
-CheckTrimuiAudio()
+CheckRG35XXHAudio()
 {
     if test x$enable_audio = xyes; then
         AC_DEFINE(SDL_AUDIO_DRIVER_MMIYOO, 1, [ ])
         SOURCES="$SOURCES $srcdir/src/audio/mmiyoo/*.c"
         have_audio=yes
         if test x$HOST = xarm-linux; then
-            EXTRA_CFLAGS="$EXTRA_CFLAGS -mcpu=cortex-a7 -mfpu=neon-vfpv4 -O3"
-            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -l:libasound.so.2"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS  %CFLAGS% -O3"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L../mmiyoo/lib  -l:libasound.so.2"
         fi
         SUMMARY_audio="${SUMMARY_audio} mmiyoo"
     fi
 }
 
-CheckFunkeysAudio()
+CheckTrimuiAudio()
 {
     if test x$enable_audio = xyes; then
         AC_DEFINE(SDL_AUDIO_DRIVER_MMIYOO, 1, [ ])
@@ -3841,15 +3869,18 @@ case "$host" in
         esac
 
         case "$MOD" in
+            *a30*)              ARCH=a30
+                CheckA30Video
+                ;;
             *mmiyoo*)           ARCH=mmiyoo
                 CheckMMiyooVideo
                 ;;
+            *rg35xxh*)           ARCH=rg35xxh
+                CheckRG35XXHVideo
+                ;;
             *trimui*)           ARCH=trimui
                 CheckTrimuiVideo
                 ;;
-            *funkeys*)          ARCH=funkeys
-                CheckFunkeysVideo
-                ;;
             *pandora*)          ARCH=pandora
                 CheckPandoraVideo
                 ;;
@@ -3975,6 +4006,9 @@ case "$host" in
             mmiyoo)
                 CheckMMiyooAudio
             ;;
+            rg35xxh)
+                CheckRG35XXHAudio
+            ;;
             trimui)
                 CheckTrimuiAudio
             ;;
@@ -4015,7 +4049,7 @@ case "$host" in
                 SOURCES="$SOURCES $srcdir/src/joystick/steam/*.c"
                 have_joystick=yes
             ;;
-            mmiyoo|trimui|funkeys|pandora|unittest)
+            mmiyoo|rg35xxh|trimui|funkeys|pandora|unittest)
                 AC_DEFINE(SDL_JOYSTICK_MMIYOO, 1, [ ])
                 SOURCES="$SOURCES $srcdir/src/joystick/mmiyoo/*.c"
                 have_joystick=yes
diff --git a/sdl2/src/SDL.c b/sdl2/src/SDL.c
index d020649..abfcdb4 100644
--- a/sdl2/src/SDL.c
+++ b/sdl2/src/SDL.c
@@ -153,6 +153,7 @@ SDL_InitSubSystem(Uint32 flags)
 {
     Uint32 flags_initialized = 0;
 
+    printf("[trngaje] SDL_InitSubSystem:0x%x\n", flags);
     if(!SDL_MainIsReady) {
         SDL_SetError("Application didn't initialize properly, did you include SDL_main.h in the file containing your main() function?");
         return -1;
@@ -225,11 +226,14 @@ SDL_InitSubSystem(Uint32 flags)
 
     /* Initialize the video subsystem */
     if((flags & SDL_INIT_VIDEO)) {
+		printf("[trngaje] SDL_InitSubSystem:SDL_INIT_VIDEO\n");
 #if !SDL_VIDEO_DISABLED
         if(SDL_PrivateShouldInitSubsystem(SDL_INIT_VIDEO)) {
             if(SDL_VideoInit(NULL) < 0) {
+				printf("[trngaje] SDL_InitSubSystem:SDL_INIT_VIDEO:fail\n");
                 goto quit_and_error;
             }
+			printf("[trngaje] SDL_InitSubSystem:SDL_INIT_VIDEO:success\n");
         }
         SDL_PrivateSubsystemRefCountIncr(SDL_INIT_VIDEO);
         flags_initialized |= SDL_INIT_VIDEO;
diff --git a/sdl2/src/audio/mmiyoo/SDL_audio_mmiyoo.c b/sdl2/src/audio/mmiyoo/SDL_audio_mmiyoo.c
index 3a15d3d..43b5a80 100644
--- a/sdl2/src/audio/mmiyoo/SDL_audio_mmiyoo.c
+++ b/sdl2/src/audio/mmiyoo/SDL_audio_mmiyoo.c
@@ -1,9 +1,9 @@
 /*
-  Customized version for Miyoo-Mini handheld.
-  Only tested under Miyoo-Mini stock OS (original firmware) with Parasyte compatible layer.
+  Special customized version for the DraStic emulator that runs on
+  Miyoo Mini (Plus), TRIMUI-SMART and Miyoo A30 handhelds.
 
   Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
-  Copyright (C) 2022-2022 Steward Fu <steward.fu@gmail.com>
+  Copyright (C) 2022-2024 Steward Fu <steward.fu@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -21,9 +21,6 @@
      misrepresented as being the original software.
   3. This notice may not be removed or altered from any source distribution.
 */
-#include "../../SDL_internal.h"
-
-#if SDL_AUDIO_DRIVER_MMIYOO
 
 #include <stdio.h>
 #include <string.h>
@@ -35,6 +32,7 @@
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 
+#include "../../SDL_internal.h"
 #include "SDL_timer.h"
 #include "SDL_audio.h"
 #include "SDL_audio_mmiyoo.h"
@@ -169,10 +167,8 @@ static int MMIYOO_Init(SDL_AudioDriverImpl *impl)
 
 AudioBootStrap MMIYOOAUDIO_bootstrap = {"MMIYOO", "MMIYOO AUDIO DRIVER", MMIYOO_Init, 0};
 
-#endif
-
 #ifdef UNITTEST
-    #include "unity_fixture.h"
+#include "unity_fixture.h"
 
 TEST_GROUP(sdl2_audio_mmiyoo);
 
diff --git a/sdl2/src/audio/mmiyoo/SDL_audio_mmiyoo.h b/sdl2/src/audio/mmiyoo/SDL_audio_mmiyoo.h
index 0042a38..7f52f41 100644
--- a/sdl2/src/audio/mmiyoo/SDL_audio_mmiyoo.h
+++ b/sdl2/src/audio/mmiyoo/SDL_audio_mmiyoo.h
@@ -1,10 +1,9 @@
 /*
-  Customized version for Miyoo-Mini handheld.
-  Only tested under Miyoo-Mini stock OS (original firmware) with Parasyte compatible layer.
+  Special customized version for the DraStic emulator that runs on
+  Miyoo Mini (Plus), TRIMUI-SMART and Miyoo A30 handhelds.
 
   Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
-  Copyright (C) 2022-2022 Steward Fu <steward.fu@gmail.com>
-
+  Copyright (C) 2022-2024 Steward Fu <steward.fu@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -22,11 +21,11 @@
      misrepresented as being the original software.
   3. This notice may not be removed or altered from any source distribution.
 */
-#include "../../SDL_internal.h"
 
 #ifndef __SDL_AUDIO_MMIYOO_H__
 #define __SDL_AUDIO_MMIYOO_H__
 
+#include "../../SDL_internal.h"
 #include "../SDL_sysaudio.h"
 
 #define _THIS   SDL_AudioDevice *this
diff --git a/sdl2/src/joystick/mmiyoo/SDL_joystick_mmiyoo.c b/sdl2/src/joystick/mmiyoo/SDL_joystick_mmiyoo.c
index e95b19b..13e5ad6 100644
--- a/sdl2/src/joystick/mmiyoo/SDL_joystick_mmiyoo.c
+++ b/sdl2/src/joystick/mmiyoo/SDL_joystick_mmiyoo.c
@@ -1,10 +1,9 @@
 /*
-  Customized version for Miyoo-Mini handheld.
-  Only tested under Miyoo-Mini stock OS (original firmware) with Parasyte compatible layer.
+  Special customized version for the DraStic emulator that runs on
+  Miyoo Mini (Plus), TRIMUI-SMART and Miyoo A30 handhelds.
 
   Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
-  Copyright (C) 2022-2022 Steward Fu <steward.fu@gmail.com>
-
+  Copyright (C) 2022-2024 Steward Fu <steward.fu@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -22,17 +21,422 @@
      misrepresented as being the original software.
   3. This notice may not be removed or altered from any source distribution.
 */
-#include "../../SDL_internal.h"
 
-#if defined(SDL_JOYSTICK_MMIYOO)
+#include "../../SDL_internal.h"
+#include "../../events/SDL_events_c.h"
+#include "../../core/linux/SDL_evdev.h"
+#include "../../thread/SDL_systhread.h"
 
+#include "SDL_events.h"
 #include "SDL_joystick.h"
 #include "../SDL_sysjoystick.h"
 #include "../SDL_joystick_c.h"
+#include "../../video/mmiyoo/SDL_video_mmiyoo.h"
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <termios.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/select.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <linux/input.h>
+
+#ifdef A30
+#define SERIAL_GAMEDECK         "/dev/ttyS0"
+#define MIYOO_AXIS_MAX_COUNT    16
+#define MIYOO_PLAYER_MAGIC      0xFF
+#define MIYOO_PLAYER_MAGIC_END  0xFE
+#define MIYOO_PAD_FRAME_LEN     6
+
+struct MIYOO_PAD_FRAME {
+    uint8_t magic;
+    uint8_t unused0;
+    uint8_t unused1;
+    uint8_t axis0;
+    uint8_t axis1;
+    uint8_t magicEnd;
+};
+
+int g_lastX = 0;
+int g_lastY = 0;
 
-static int MMIYOO_JoystickInit(void)
+static int s_fd = -1;
+static struct MIYOO_PAD_FRAME s_frame = {0};
+static int32_t s_miyoo_axis[MIYOO_AXIS_MAX_COUNT] = {0};
+static int32_t s_miyoo_axis_last[MIYOO_AXIS_MAX_COUNT] = {0};
+
+static int running = 0;
+static SDL_Thread *thread = NULL;
+
+extern NDS nds;
+extern MMIYOO_VideoInfo vid;
+
+int uart_open(const char *port)
 {
-    return 1;
+    int fd = -1;
+
+    fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);
+    if (-1 == fd) {
+        printf("Failed to open uart\n");
+        return -1;
+    }
+
+    if (fcntl(fd, F_SETFL, 0) < 0) {
+        printf("Failed to call fcntl\n");
+        return -1;
+    }
+    return fd;
+}
+
+static void uart_close(int fd)
+{
+    close(fd);
+}
+
+static int uart_set(int fd, int speed, int flow_ctrl, int databits, int stopbits, int parity)
+{
+    int i = 0;
+    int speed_arr[] = {B115200, B19200, B9600, B4800, B2400, B1200, B300};
+    int name_arr[] = {115200, 19200, 9600, 4800, 2400, 1200, 300};
+    struct termios options = {0};
+
+    if (tcgetattr(fd, &options) != 0) {
+        printf("Failed to get uart attributes\n");
+        return -1;
+    }
+
+    for (i = 0; i < sizeof(speed_arr) / sizeof(int); i++) {
+        if (speed == name_arr[i]) {
+            cfsetispeed(&options, speed_arr[i]);
+            cfsetospeed(&options, speed_arr[i]);
+        }
+    }
+
+    options.c_cflag |= CLOCAL;
+    options.c_cflag |= CREAD;
+    switch (flow_ctrl) {
+    case 0:
+        options.c_cflag &= ~CRTSCTS;
+        break;
+    case 1:
+        options.c_cflag |= CRTSCTS;
+        break;
+    case 2:
+        options.c_cflag |= IXON | IXOFF | IXANY;
+        break;
+    }
+
+    options.c_cflag &= ~CSIZE;
+    switch (databits) {
+    case 5:
+        options.c_cflag |= CS5;
+        break;
+    case 6:
+        options.c_cflag |= CS6;
+        break;
+    case 7:
+        options.c_cflag |= CS7;
+        break;
+    case 8:
+        options.c_cflag |= CS8;
+        break;
+    default:
+        return -1;
+    }
+
+    switch (parity) {
+    case 'n':
+    case 'N':
+        options.c_cflag &= ~PARENB;
+        options.c_iflag &= ~INPCK;
+        break;
+    case 'o':
+    case 'O':
+        options.c_cflag |= (PARODD | PARENB);
+        options.c_iflag |= INPCK;
+        break;
+    case 'e':
+    case 'E':
+        options.c_cflag |= PARENB;
+        options.c_cflag &= ~PARODD;
+        options.c_iflag |= INPCK;
+        break;
+    case 's':
+    case 'S':
+        options.c_cflag &= ~PARENB;
+        options.c_cflag &= ~CSTOPB;
+        break;
+    default:
+        return -1;
+    }
+
+    switch (stopbits) {
+    case 1:
+        options.c_cflag &= ~CSTOPB;
+        break;
+    case 2:
+        options.c_cflag |= CSTOPB;
+        break;
+    default:
+        return -1;
+    }
+
+    options.c_oflag &= ~OPOST;
+    options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
+    options.c_iflag &= ~(INLCR | ICRNL | IGNCR);
+    options.c_oflag &= ~(ONLCR | OCRNL);
+    options.c_cc[VTIME] = 1;
+    options.c_cc[VMIN] = 1;
+
+    tcflush(fd, TCIFLUSH);
+    if (tcsetattr(fd, TCSANOW, &options) != 0) {
+        return -1;
+    }
+    return 0;
+}
+
+static int uart_init(int fd, int speed, int flow_ctrl, int databits, int stopbits, int parity)
+{
+    if (uart_set(fd, speed, flow_ctrl, databits, stopbits, parity) == -1) {
+        return -1;
+    }
+    return 0;
+}
+
+static int uart_read(int fd, char *rcv_buf, int data_len)
+{
+    int f_sel;
+    fd_set f_read;
+    struct timeval time = {0};
+
+    FD_ZERO(&f_read);
+    FD_SET(fd, &f_read);
+
+    time.tv_sec = 10;
+    time.tv_usec = 0;
+    f_sel = select(fd + 1, &f_read, NULL, NULL, &time);
+    if (f_sel) {
+        return read(fd, rcv_buf, data_len);
+    }
+    return 0;
+}
+
+static int filterDeadzone(int newAxis, int oldAxis)
+{
+    if (abs(newAxis - oldAxis) < nds.joy.dzone) {
+        return 1;
+    }
+    return 0;
+}
+
+static int limitValue8(int value)
+{
+    if (value > 127) {
+        value = 127;
+    }
+    else if (value < -128) {
+        value = -128;
+    }
+    return value;
+}
+
+static void check_axis_event(void)
+{
+    int i = 0;
+
+    for (i = 0; i < MIYOO_AXIS_MAX_COUNT; i++) {
+        if (s_miyoo_axis[i] != s_miyoo_axis_last[i]) {
+            if (!filterDeadzone(s_miyoo_axis[i], s_miyoo_axis_last[i])) {
+                if (i == 0) {
+                    g_lastX = limitValue8(s_miyoo_axis[i]);
+                    //printf("X %d\n", g_lastX);
+                }
+                else if (i == 1) {
+                    g_lastY = limitValue8(s_miyoo_axis[i]);
+                    //printf("Y %d\n", g_lastY);
+                }
+            }
+        }
+        s_miyoo_axis_last[i] = s_miyoo_axis[i];
+    }
+}
+
+static int miyoo_frame_to_axis_x(uint8_t rawX)
+{
+    int value = 0;
+
+    if (rawX > nds.joy.zero_x) {
+        value = (rawX - nds.joy.zero_x) * 126 / (nds.joy.max_x - nds.joy.zero_x);
+    }
+
+    if (rawX < nds.joy.zero_x) {
+        value = (rawX - nds.joy.zero_x) * 126 / (nds.joy.zero_x - nds.joy.min_x);
+    }
+
+    if (value > 0 && value < nds.joy.dzone) {
+        return 0;
+    }
+
+    if (value < 0 && value > -(nds.joy.dzone)) {
+        return 0;
+    }
+    return value;
+}
+
+static int miyoo_frame_to_axis_y(uint8_t rawY)
+{
+    int value = 0;
+
+    if (rawY > nds.joy.zero_y) {
+        value = (rawY - nds.joy.zero_y) * 126 / (nds.joy.max_y - nds.joy.zero_y);
+    }
+
+    if (rawY < nds.joy.zero_y) {
+        value = (rawY - nds.joy.zero_y) * 126 / (nds.joy.zero_y - nds.joy.min_y);
+    }
+
+    if (value > 0 && value < nds.joy.dzone) {
+        return 0;
+    }
+
+    if (value < 0 && value > -(nds.joy.dzone)) {
+        return 0;
+    }
+    return value;
+}
+
+static int parser_miyoo_input(const char *cmd, int len)
+{
+    int i = 0;
+    int p = 0;
+
+    if ((!cmd) || (len < MIYOO_PAD_FRAME_LEN)) {
+        return - 1;
+    }
+
+    for (i = 0; i < len - MIYOO_PAD_FRAME_LEN + 1; i += MIYOO_PAD_FRAME_LEN) {
+        for (p = 0; p < MIYOO_PAD_FRAME_LEN - 1; p++) {
+            if ((cmd[i] == MIYOO_PLAYER_MAGIC) && (cmd[i + MIYOO_PAD_FRAME_LEN - 1] == MIYOO_PLAYER_MAGIC_END)) {
+                memcpy(&s_frame, cmd + i, sizeof(s_frame));
+                break;
+            }
+            else {
+                i++;
+            }
+        }
+    }
+    s_miyoo_axis[ABS_X] = miyoo_frame_to_axis_x(s_frame.axis0);
+    s_miyoo_axis[ABS_Y] = miyoo_frame_to_axis_y(s_frame.axis1);
+    check_axis_event();
+    return 0;
+}
+
+static int miyoo_init_serial_input(void)
+{
+    memset(&s_frame, 0, sizeof(s_frame));
+    memset(s_miyoo_axis, 0, sizeof(s_miyoo_axis));
+    memset(s_miyoo_axis_last, 0, sizeof(s_miyoo_axis_last));
+    s_fd = uart_open(SERIAL_GAMEDECK);
+    uart_init(s_fd, 9600, 0, 8, 1, 'N');
+    if (s_fd <= 0) {
+        return -1;
+    }
+    return 0;
+}
+
+static void miyoo_close_serial_input(void)
+{
+}
+
+static int chk_str(const char *src, const char *dst)
+{
+    int len = strlen(dst);
+    return (memcmp(src, dst, len) == 0) ? 1 : 0;
+}
+
+static int miyoo_read_joystick_config(void)
+{
+    FILE *f = NULL;
+    char buf[255] = {0};
+    const char *path = "/config/joypad.config";
+
+    f = fopen(path, "r");
+    if (f) {
+        while (fgets(buf, sizeof(buf), f)) {
+            if (chk_str(buf, "x_min=")) {
+                printf(PREFIX"X_MIN %d\n", atoi(&buf[6]));
+            }
+            else if (chk_str(buf, "x_max=")) {
+                printf(PREFIX"X_MAX %d\n", atoi(&buf[6]));
+            }
+            else if (chk_str(buf, "x_zero=")) {
+                printf(PREFIX"X_ZERO %d\n", atoi(&buf[7]));
+            }
+            else if (chk_str(buf, "y_min=")) {
+                printf(PREFIX"Y_MIN %d\n", atoi(&buf[6]));
+            }
+            else if (chk_str(buf, "y_max=")) {
+                printf(PREFIX"Y_MAX %d\n", atoi(&buf[6]));
+            }
+            else if (chk_str(buf, "y_zero=")) {
+                printf(PREFIX"Y_ZERO %d\n", atoi(&buf[7]));
+            }
+        }
+        fclose(f);
+    }
+    return 0;
+}
+
+int joystick_handler(void *param)
+{
+    int len = 0;
+    char rcv_buf[255] = {0};
+
+    while (running) {
+        len = uart_read(s_fd, rcv_buf, 99);
+        if (len > 0) {
+            rcv_buf[len] = '\0';
+            parser_miyoo_input(rcv_buf, len);
+        }
+        usleep(10000);
+    }
+    return 0;
+}
+#endif
+
+int MMIYOO_JoystickInit(void)
+{
+    printf(PREFIX"%s\n", __func__);
+
+#ifdef A30
+    running = 1;
+    miyoo_read_joystick_config();
+    miyoo_init_serial_input();
+    if((thread = SDL_CreateThreadInternal(joystick_handler, "a30_joystick_thread", 4096, NULL)) == NULL) {
+        printf(PREFIX"Failed to create joystick thread");
+    }
+#endif
+    return 0;
+}
+
+void MMIYOO_JoystickQuit(void)
+{
+    printf(PREFIX"%s\n", __func__);
+
+#ifdef A30
+    running = 0;
+    miyoo_close_serial_input();
+    SDL_WaitThread(thread, NULL);
+    uart_close(s_fd);
+    s_fd = -1;
+#endif
 }
 
 static int MMIYOO_JoystickGetCount(void)
@@ -46,7 +450,7 @@ static void MMIYOO_JoystickDetect(void)
 
 static const char* MMIYOO_JoystickGetDeviceName(int device_index)
 {
-    return "MMiyoo Joystick";
+    return "Miyoo MMIYOO Joystick";
 }
 
 static int MMIYOO_JoystickGetDevicePlayerIndex(int device_index)
@@ -62,6 +466,7 @@ static SDL_JoystickGUID MMIYOO_JoystickGetDeviceGUID(int device_index)
 {
     SDL_JoystickGUID guid;
     const char *name = MMIYOO_JoystickGetDeviceName(device_index);
+
     SDL_zero(guid);
     SDL_memcpy(&guid, name, SDL_min(sizeof(guid), SDL_strlen(name)));
     return guid;
@@ -72,14 +477,23 @@ static SDL_JoystickID MMIYOO_JoystickGetDeviceInstanceID(int device_index)
     return device_index;
 }
 
-static int MMIYOO_JoystickOpen(SDL_Joystick *joystick, int device_index)
+int MMIYOO_JoystickOpen(SDL_Joystick *joystick, int device_index)
 {
-    joystick->nbuttons = 14;
-    joystick->naxes = 2;
-    joystick->nhats = 0;
+    printf(PREFIX"%s\n", __func__);
+    if (joystick) {
+        joystick->nbuttons = 18;
+        joystick->naxes = 2;
+        joystick->nhats = 0;
+        joystick->instance_id = device_index;
+    }
     return 0;
 }
 
+void MMIYOO_JoystickClose(SDL_Joystick *joystick)
+{
+    printf(PREFIX"%s\n", __func__);
+}
+
 static int MMIYOO_JoystickRumble(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble)
 {
     return SDL_Unsupported();
@@ -92,7 +506,7 @@ static int MMIYOO_JoystickRumbleTriggers(SDL_Joystick *joystick, Uint16 left_rum
 
 static Uint32 MMIYOO_JoystickGetCapabilities(SDL_Joystick *joystick)
 {
-    return 0;
+    return SDL_Unsupported();
 }
 
 static int MMIYOO_JoystickSetLED(SDL_Joystick *joystick, Uint8 red, Uint8 green, Uint8 blue)
@@ -110,16 +524,22 @@ static int MMIYOO_JoystickSetSensorsEnabled(SDL_Joystick *joystick, SDL_bool ena
     return SDL_Unsupported();
 }
 
-static void MMIYOO_JoystickUpdate(SDL_Joystick *joystick)
+void MMIYOO_JoystickUpdate(SDL_Joystick *joystick)
 {
-}
+#ifdef A30
+    static int pre_x = -1;
+    static int pre_y = -1;
 
-static void MMIYOO_JoystickClose(SDL_Joystick *joystick)
-{
-}
+    if (g_lastX != pre_x) {
+        pre_x = g_lastX;
+        SDL_PrivateJoystickAxis(joystick, 0, pre_x);
+    }
 
-static void MMIYOO_JoystickQuit(void)
-{
+    if (g_lastY != pre_y) {
+        pre_y = g_lastY;
+        SDL_PrivateJoystickAxis(joystick, 1, pre_x);
+    }
+#endif
 }
 
 static SDL_bool MMIYOO_JoystickGetGamepadMapping(int device_index, SDL_GamepadMapping *out)
@@ -149,5 +569,3 @@ SDL_JoystickDriver SDL_MMIYOO_JoystickDriver = {
     MMIYOO_JoystickGetGamepadMapping
 };
 
-#endif
-
diff --git a/sdl2/src/render/mmiyoo/SDL_render_mmiyoo.c b/sdl2/src/render/mmiyoo/SDL_render_mmiyoo.c
index d154a51..7ae6fec 100644
--- a/sdl2/src/render/mmiyoo/SDL_render_mmiyoo.c
+++ b/sdl2/src/render/mmiyoo/SDL_render_mmiyoo.c
@@ -1,9 +1,9 @@
 /*
-  Customized version for Miyoo-Mini handheld.
-  Only tested under Miyoo-Mini stock OS (original firmware) with Parasyte compatible layer.
+  Special customized version for the DraStic emulator that runs on
+  Miyoo Mini (Plus), TRIMUI-SMART and Miyoo A30 handhelds.
 
   Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
-  Copyright (C) 2022-2022 Steward Fu <steward.fu@gmail.com>
+  Copyright (C) 2022-2024 Steward Fu <steward.fu@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -21,17 +21,15 @@
      misrepresented as being the original software.
   3. This notice may not be removed or altered from any source distribution.
 */
-#include "../../SDL_internal.h"
-
-#if SDL_VIDEO_RENDER_MMIYOO
 
 #include <unistd.h>
 #include <stdbool.h>
 
-#include "SDL_hints.h"
-#include "../SDL_sysrender.h"
+#include "../../SDL_internal.h"
 #include "../../video/mmiyoo/SDL_video_mmiyoo.h"
 #include "../../video/mmiyoo/SDL_event_mmiyoo.h"
+#include "../SDL_sysrender.h"
+#include "SDL_hints.h"
 
 typedef struct MMIYOO_TextureData {
     void *data;
@@ -179,8 +177,12 @@ static int MMIYOO_QueueCopy(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_
     }
 #endif
     show_fps = 0;
+
+    // acquire a lock
+    pthread_mutex_lock(&lock);
     nds.menu.drastic.enable = 1;
-    usleep(100000);
+
+    //usleep(100000);
 
 #ifdef TRIMUI
     if (nds.dis_mode != NDS_DIS_MODE_S0) {
@@ -192,6 +194,14 @@ static int MMIYOO_QueueCopy(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_
 #endif
 
     process_drastic_menu();
+
+    pthread_cond_signal(&request_update_screen_cond);
+
+    pthread_cond_wait(&response_update_screen_cond, &lock);
+
+    // release lock
+    pthread_mutex_unlock(&lock);
+
     return 0;
 }
 
@@ -333,10 +343,8 @@ SDL_RenderDriver MMIYOO_RenderDriver = {
     }
 };
 
-#endif
-
 #ifdef UNITTEST
-    #include "unity_fixture.h"
+#include "unity_fixture.h"
 
 TEST_GROUP(sdl2_render_mmiyoo);
 
diff --git a/sdl2/src/video/SDL_stretch.c b/sdl2/src/video/SDL_stretch.c
index dad3eb5..d608a2e 100644
--- a/sdl2/src/video/SDL_stretch.c
+++ b/sdl2/src/video/SDL_stretch.c
@@ -296,7 +296,7 @@ INTERPOL_BILINEAR(const Uint32 *s0, const Uint32 *s1, int frac_w0, int frac_h0,
     INTERPOL(tmp,   tmp + 1, frac_w0, frac_w1, dst);
 }
 
-static int
+int
 scale_mat(const Uint32 *src, int src_w, int src_h, int src_pitch,
           Uint32 *dst, int dst_w, int dst_h, int dst_pitch)
 {
@@ -595,7 +595,7 @@ INTERPOL_BILINEAR_NEON(const Uint32 *s0, const Uint32 *s1, int frac_w, uint8x8_t
     *dst = vget_lane_u32(CAST_uint32x2_t e0, 0);
 }
 
-static int
+int
 scale_mat_NEON(const Uint32 *src, int src_w, int src_h, int src_pitch, Uint32 *dst, int dst_w, int dst_h, int dst_pitch)
 {
     BILINEAR___START
diff --git a/sdl2/src/video/SDL_video.c b/sdl2/src/video/SDL_video.c
index 31dcb83..946a882 100644
--- a/sdl2/src/video/SDL_video.c
+++ b/sdl2/src/video/SDL_video.c
@@ -479,6 +479,7 @@ SDL_VideoInit(const char *driver_name)
     SDL_bool init_mouse = SDL_FALSE;
     SDL_bool init_touch = SDL_FALSE;
 
+    printf("[trngaje] SDL_VideoInit:driver_name=%s\n", driver_name);
     /* Check to make sure we don't overwrite '_this' */
     if(_this != NULL) {
         SDL_VideoQuit();
@@ -512,6 +513,7 @@ SDL_VideoInit(const char *driver_name)
     if(driver_name == NULL) {
         driver_name = SDL_getenv("SDL_VIDEODRIVER");
     }
+	printf("[trngaje] SDL_VideoInit:SDL_VIDEODRIVER=%s\n", driver_name);
     if(driver_name != NULL && *driver_name != 0) {
         const char *driver_attempt = driver_name;
         while(driver_attempt != NULL && *driver_attempt != 0 && video == NULL) {
diff --git a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c
index 9ce76ee..0d73cbd 100644
--- a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c
+++ b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.c
@@ -1,9 +1,9 @@
 /*
-  Customized version for Miyoo-Mini handheld.
-  Only tested under Miyoo-Mini stock OS (original firmware) with Parasyte compatible layer.
+  Special customized version for the DraStic emulator that runs on
+  Miyoo Mini (Plus), TRIMUI-SMART and Miyoo A30 handhelds.
 
   Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
-  Copyright (C) 2022-2022 Steward Fu <steward.fu@gmail.com>
+  Copyright (C) 2022-2024 Steward Fu <steward.fu@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -21,9 +21,6 @@
      misrepresented as being the original software.
   3. This notice may not be removed or altered from any source distribution.
 */
-#include "../../SDL_internal.h"
-
-#if SDL_VIDEO_DRIVER_MMIYOO
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -33,6 +30,7 @@
 #include <dirent.h>
 #include <linux/input.h>
 
+#include "../../SDL_internal.h"
 #include "../../events/SDL_events_c.h"
 #include "../../core/linux/SDL_evdev.h"
 #include "../../thread/SDL_systhread.h"
@@ -42,13 +40,18 @@
 
 #if defined(PANDORA)
     #define INPUT_DEV "/dev/input/event4"
-#elif defined(QX1000)
+#elif defined(QX1000) || defined(A30)
     #define INPUT_DEV "/dev/input/event3"
+#elif defined(RG35XXH)
+    #define INPUT_DEV "/dev/input/event1" /* RG35XXH */
+//    #define INPUT_DEV "/dev/input/event2" /* RG35XXH evmapy*/
 #else
     #define INPUT_DEV "/dev/input/event0"
 #endif
 
-#ifdef MMIYOO
+#ifdef RG35XXH
+/*
+// for evmapy 
     #define UP      103
     #define DOWN    108
     #define LEFT    105
@@ -67,9 +70,30 @@
     #define POWER   116
     #define VOLUP   115
     #define VOLDOWN 114
+	*/
+    #define UP      -1	/* not defined */
+    #define DOWN    -1 /* not defined */
+    #define LEFT    -1 /* not defined */
+    #define RIGHT   -1 /* not defined */
+    #define A       BTN_SOUTH
+    #define B       BTN_EAST
+    #define X       BTN_NORTH
+    #define Y       BTN_C
+    #define L1      BTN_WEST
+    #define L2      BTN_SELECT
+    #define R1      BTN_Z
+    #define R2      BTN_START
+    #define START   BTN_TR
+    #define SELECT  BTN_TL
+    #define MENU    BTN_TL2
+    #define POWER   116 /* not defined */
+    #define VOLUP   115 /* not defined */
+    #define VOLDOWN 114	/* not defined */
+	#define L3		BTN_TR2
+	#define R3		BTN_MODE
 #endif
 
-#ifdef TRIMUI
+#ifdef A30
     #define UP      103
     #define DOWN    108
     #define LEFT    105
@@ -79,26 +103,51 @@
     #define X       42
     #define Y       56
     #define L1      15
+    #define L2      18
     #define R1      14
+    #define R2      20
     #define START   28
     #define SELECT  97
     #define MENU    1
+    #define VOLUP   115
+    #define VOLDOWN 114
+#endif
+
+#ifdef MMIYOO
+    #define UP      103
+    #define DOWN    108
+    #define LEFT    105
+    #define RIGHT   106
+    #define A       57
+    #define B       29
+    #define X       42
+    #define Y       56
+    #define L1      18
+    #define L2      15
+    #define R1      20
+    #define R2      14
+    #define START   28
+    #define SELECT  97
+    #define MENU    1
+    #define POWER   116
+    #define VOLUP   115
+    #define VOLDOWN 114
 #endif
 
-#ifdef FUNKEYS
-    #define UP      22
-    #define DOWN    32
-    #define LEFT    38
-    #define RIGHT   19
-    #define A       30
-    #define B       48
-    #define X       45
-    #define Y       21
-    #define L1      50
-    #define R1      49
-    #define START   31
-    #define SELECT  37
-    #define MENU    16
+#ifdef TRIMUI
+    #define UP      103
+    #define DOWN    108
+    #define LEFT    105
+    #define RIGHT   106
+    #define A       57
+    #define B       29
+    #define X       42
+    #define Y       56
+    #define L1      15
+    #define R1      14
+    #define START   28
+    #define SELECT  97
+    #define MENU    1
 #endif
 
 #ifdef PANDORA
@@ -155,11 +204,13 @@ static int is_stock_os = 0;
 #endif
 static SDL_sem *event_sem = NULL;
 static SDL_Thread *thread = NULL;
-static uint32_t hotkey = 0;
+static uint32_t cur_keypad_bitmaps = 0;
 static uint32_t pre_keypad_bitmaps = 0;
 
 extern int FB_W;
 extern int FB_H;
+extern int g_lastX;
+extern int g_lastY;
 
 #ifdef TRIMUI
 typedef struct _cust_key_t {
@@ -185,6 +236,8 @@ const SDL_Scancode code[]={
     SDLK_t,             // R1
     SDLK_TAB,           // L2
     SDLK_BACKSPACE,     // R2
+	SDLK_4,	// L3
+	SDLK_5, 	// R3
     SDLK_RCTRL,         // SELECT
     SDLK_RETURN,        // START
     SDLK_HOME,          // MENU
@@ -252,7 +305,7 @@ static void release_all_keys(void)
 
 static int hit_hotkey(uint32_t bit)
 {
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     uint32_t mask = (1 << bit) | (1 << ((nds.hotkey == HOTKEY_BIND_SELECT) ? MYKEY_SELECT : MYKEY_MENU));
 #endif
 
@@ -260,61 +313,558 @@ static int hit_hotkey(uint32_t bit)
     uint32_t mask = (1 << bit) | (1 << MYKEY_MENU);
 #endif
 
-#ifdef FUNKEYS
-    uint32_t mask = (1 << bit) | (1 << MYKEY_START);
-#endif
-
 #ifdef QX1000
     uint32_t mask = (1 << bit) | (1 << MYKEY_MENU);
 #endif
 
-    return (hotkey ^ mask) ? 0 : 1;
+    return (cur_keypad_bitmaps ^ mask) ? 0 : 1;
 }
 
 static void set_key(uint32_t bit, int val)
 {
     if (val) {
-        hotkey|= (1 << bit);
+        cur_keypad_bitmaps|= (1 << bit);
         evt.keypad.bitmaps|= (1 << bit);
 
 #if defined(TRIMUI) || defined(PANDORA) || defined(QX1000)
         if (bit == MYKEY_MENU) {
-            hotkey = (1 << MYKEY_MENU);
+            cur_keypad_bitmaps = (1 << MYKEY_MENU);
         }
 #endif
 
-#ifdef FUNKEYS
-        if (bit == MYKEY_START) {
-            hotkey = (1 << MYKEY_START);
-        }
-#endif
-
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
         if (nds.hotkey == HOTKEY_BIND_SELECT) {
             if (bit == MYKEY_SELECT) {
-                hotkey = (1 << MYKEY_SELECT);
+                cur_keypad_bitmaps = (1 << MYKEY_SELECT);
             }
         }
         else {
             if (bit == MYKEY_MENU) {
-                hotkey = (1 << MYKEY_MENU);
+                cur_keypad_bitmaps = (1 << MYKEY_MENU);
             }
         }
 #endif
     }
     else {
-        hotkey&= ~(1 << bit);
-        evt.keypad.bitmaps&= ~(1 << bit);
+        cur_keypad_bitmaps &= ~(1 << bit);
+        evt.keypad.bitmaps &= ~(1 << bit);
     }
 }
 
+#if defined(A30) && USE_MYJOY
+static int update_joystick(void)
+{
+    const int LTH = -30;
+    const int RTH = 30;
+    const int UTH = -30;
+    const int DTH = 30;
+
+    static int pre_x = -1;
+    static int pre_y = -1;
+
+    int r = 0;
+
+    if (nds.joy.mode == MYJOY_MODE_KEYPAD) {
+        static int pre_up = 0;
+        static int pre_down = 0;
+        static int pre_left = 0;
+        static int pre_right = 0;
+
+        uint32_t u_key = MYKEY_UP;
+        uint32_t d_key = MYKEY_DOWN;
+        uint32_t l_key = MYKEY_LEFT;
+        uint32_t r_key = MYKEY_RIGHT;
+
+        if (g_lastX != pre_x) {
+            pre_x = g_lastX;
+            if (pre_x < LTH) {
+                if (pre_left == 0) {
+                    r = 1;
+                    pre_left = 1;
+                    set_key(l_key, 1);
+                }
+            }
+            else if (pre_x > RTH){
+                if (pre_right == 0) {
+                    r = 1;
+                    pre_right = 1;
+                    set_key(r_key, 1);
+                }
+            }
+            else {
+                if (pre_left != 0) {
+                    r = 1;
+                    pre_left = 0;
+                    set_key(l_key, 0);
+                }
+                if (pre_right != 0) {
+                    r = 1;
+                    pre_right = 0;
+                    set_key(r_key, 0);
+                }
+            }
+        }
+
+        if (g_lastY != pre_y) {
+            pre_y = g_lastY;
+            if (pre_y < UTH) {
+                if (pre_up == 0) {
+                    r = 1;
+                    pre_up = 1;
+                    set_key(u_key, 1);
+                }
+            }
+            else if (pre_y > DTH){
+                if (pre_down == 0) {
+                    r = 1;
+                    pre_down = 1;
+                    set_key(d_key, 1);
+                }
+            }
+            else {
+                if (pre_up != 0) {
+                    r = 1;
+                    pre_up = 0;
+                    set_key(u_key, 0);
+                }
+                if (pre_down != 0) {
+                    r = 1;
+                    pre_down = 0;
+                    set_key(d_key, 0);
+                }
+            }
+        }
+    }
+    else if (nds.joy.mode == MYJOY_MODE_MOUSE) {
+        static int pre_up = 0;
+        static int pre_down = 0;
+        static int pre_left = 0;
+        static int pre_right = 0;
+
+        if (g_lastX != pre_x) {
+            pre_x = g_lastX;
+            if (pre_x < LTH) {
+                if (pre_left == 0) {
+                    pre_left = 1;
+                }
+            }
+            else if (pre_x > RTH){
+                if (pre_right == 0) {
+                    pre_right = 1;
+                }
+            }
+            else {
+                if (pre_left != 0) {
+                    pre_left = 0;
+                }
+                if (pre_right != 0) {
+                    pre_right = 0;
+                }
+            }
+        }
+
+        if (g_lastY != pre_y) {
+            pre_y = g_lastY;
+            if (pre_y < UTH) {
+                if (pre_up == 0) {
+                    pre_up = 1;
+                }
+            }
+            else if (pre_y > DTH){
+                if (pre_down == 0) {
+                    pre_down = 1;
+                }
+            }
+            else {
+                if (pre_up != 0) {
+                    pre_up = 0;
+                }
+                if (pre_down != 0) {
+                    pre_down = 0;
+                }
+            }
+        }
+
+        if (pre_up || pre_down || pre_left || pre_right) {
+            if (cur_keypad_bitmaps &  (1 << MYKEY_Y)) {
+                if (pre_right) {
+                    static int cc = 0;
+
+                    if (cc == 0) {
+                        nds.pen.sel+= 1;
+                        if (nds.pen.sel >= nds.pen.max) {
+                            nds.pen.sel = 0;
+                        }
+                        reload_pen();
+                        cc = 30;
+                    }
+                    else {
+                        cc -= 1;
+                    }
+                }
+            }
+            else {
+                const int v = MYJOY_MOVE_SPEED;
+
+                if (((nds.dis_mode == NDS_DIS_MODE_HH0) || (nds.dis_mode == NDS_DIS_MODE_HH1)) && (nds.keys_rotate == 0)) {
+                    if (pre_down) {
+                        evt.mouse.x -= v;
+                    }
+                    if (pre_up) {
+                        evt.mouse.x += v;
+                    }
+                    if (pre_left) {
+                        evt.mouse.y -= v;
+                    }
+                    if (pre_right) {
+                        evt.mouse.y += v;
+                    }
+                }
+                else {
+                    if (pre_left) {
+                        evt.mouse.x -= v;
+                    }
+                    if (pre_right) {
+                        evt.mouse.x += v;
+                    }
+                    if (pre_up) {
+                        evt.mouse.y -= v;
+                    }
+                    if (pre_down) {
+                        evt.mouse.y += v;
+                    }
+                }
+                check_mouse_pos();
+            }
+            nds.joy.show_cnt = MYJOY_SHOW_CNT;
+        }
+    }
+    return r;
+}
+#endif
+
+static int handle_hotkey(void)
+{
+    int hotkey_mask = 0;
+#ifdef TRIMUI
+    char buf[MAX_PATH << 1] = {0};
+#endif
+
+    hotkey_mask = 1;
+    if (nds.menu.enable || nds.menu.drastic.enable) {
+        hotkey_mask = 0;
+    }
+/*
+    if (hotkey_mask && hit_hotkey(MYKEY_UP)) {
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
+        if (evt.mode == MMIYOO_MOUSE_MODE) {
+            switch (nds.dis_mode) {
+            case NDS_DIS_MODE_VH_T0:
+            case NDS_DIS_MODE_VH_T1:
+            case NDS_DIS_MODE_S0:
+            case NDS_DIS_MODE_S1:
+                break;
+            default:
+                nds.pen.pos = 1;
+                break;
+            }
+        }
+#ifdef A30
+        if (nds.joy.mode == MYJOY_MODE_MOUSE) {
+            nds.pen.pos = 1;
+        }
+#endif
+#endif
+        set_key(MYKEY_UP, 0);
+    }
+
+    if (hotkey_mask && hit_hotkey(MYKEY_DOWN)) {
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
+        if (evt.mode == MMIYOO_MOUSE_MODE) {
+            switch (nds.dis_mode) {
+            case NDS_DIS_MODE_VH_T0:
+            case NDS_DIS_MODE_VH_T1:
+            case NDS_DIS_MODE_S0:
+            case NDS_DIS_MODE_S1:
+                break;
+            default:
+                nds.pen.pos = 0;
+                break;
+            }
+        }
+#ifdef A30
+        if (nds.joy.mode == MYJOY_MODE_MOUSE) {
+            nds.pen.pos = 0;
+        }
+#endif
+#endif
+        set_key(MYKEY_DOWN, 0);
+    }
+*/
+    if (hotkey_mask && hit_hotkey(MYKEY_LEFT)) {
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
+        if (nds.hres_mode == 0) {
+            if (nds.dis_mode > 0) {
+                nds.dis_mode -= 1;
+            }
+        }
+        else {
+            nds.dis_mode = NDS_DIS_MODE_HRES0;
+        }
+#endif
+
+#if defined(TRIMUI) || defined(PANDORA)
+        if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0)) {
+            evt.mode = (evt.mode == MMIYOO_KEYPAD_MODE) ? MMIYOO_MOUSE_MODE : MMIYOO_KEYPAD_MODE;
+
+            if (evt.mode == MMIYOO_MOUSE_MODE) {
+                release_all_keys();
+            }
+            lower_speed = 0;
+        }
+#endif
+        set_key(MYKEY_LEFT, 0);
+    }
+
+    if (hotkey_mask && hit_hotkey(MYKEY_RIGHT)) {
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
+        if (nds.hres_mode == 0) {
+            if (nds.dis_mode < NDS_DIS_MODE_LAST) {
+                nds.dis_mode += 1;
+            }
+        }
+        else {
+            nds.dis_mode = NDS_DIS_MODE_HRES1;
+        }
+#endif
+
+#if defined(TRIMUI) || defined(PANDORA)
+        set_key(MYKEY_R2, 1);
+#endif
+        set_key(MYKEY_RIGHT, 0);
+    }
+
+    if (hotkey_mask && hit_hotkey(MYKEY_A)) {
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
+        if ((evt.mode == MMIYOO_KEYPAD_MODE) && (nds.hres_mode == 0)) {
+            uint32_t tmp = nds.alt_mode;
+            nds.alt_mode = nds.dis_mode;
+            nds.dis_mode = tmp;
+        }
+#endif
+
+#ifdef TRIMUI
+        nds.dis_mode = (nds.dis_mode == NDS_DIS_MODE_S0) ? NDS_DIS_MODE_S1 : NDS_DIS_MODE_S0;
+        disp_resize();
+#endif
+        set_key(MYKEY_A, 0);
+    }
+
+    if (hotkey_mask && hit_hotkey(MYKEY_B)) {
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
+        pixel_filter = pixel_filter ? 0 : 1;
+#endif
+        set_key(MYKEY_B, 0);
+    }
+
+    if (hit_hotkey(MYKEY_X)) {
+#ifdef TRIMUI
+        int w = FB_W;
+        int h = FB_H;
+        int pitch = FB_W * FB_BPP;
+        uint32_t *dst = NULL;
+        SDL_Surface *p = NULL;
+        time_t t = time(NULL);
+        struct tm tm = *localtime(&t);
+
+        // for MMIYOO
+        // dst = (uint32_t *)gfx.fb.virAddr + (w * (gfx.vinfo.yoffset ? 0 : h));
+        dst = (uint32_t *)gfx.hw.ion.vadd + (w * h * (gfx.fb.flip ? 0 : 1));
+
+        if (nds.dis_mode == NDS_DIS_MODE_S0) {
+            w = NDS_H;
+            h = NDS_W;
+        }
+        else {
+            w = FB_H;
+            h = FB_W;
+        }
+        pitch = FB_H * FB_BPP;
+
+        if (dst) {
+            p = SDL_CreateRGBSurfaceFrom(dst, w, h, 32, pitch, 0, 0, 0, 0);
+            if (p) {
+                sprintf(buf, "%s/%02d%02d%02d.png", nds.shot.path, tm.tm_hour, tm.tm_min, tm.tm_sec);
+                IMG_SavePNG(p, buf);
+                SDL_FreeSurface(p);
+                printf(PREFIX"Saved \'%s\'\n", buf);
+            }
+        }
+        nds.shot.take = 1;
+#endif
+        set_key(MYKEY_X, 0);
+    }
+
+    if (hit_hotkey(MYKEY_Y)) {
+        if (hotkey_mask) {
+            if (evt.mode == MMIYOO_KEYPAD_MODE) {
+                if ((nds.overlay.sel >= nds.overlay.max) &&
+                    (nds.dis_mode != NDS_DIS_MODE_VH_T0) &&
+                    (nds.dis_mode != NDS_DIS_MODE_VH_T1) &&
+                    (nds.dis_mode != NDS_DIS_MODE_S1) &&
+                    (nds.dis_mode != NDS_DIS_MODE_HRES1))
+                {
+                    nds.theme.sel+= 1;
+                    if (nds.theme.sel > nds.theme.max) {
+                        nds.theme.sel = 0;
+                    }
+                }
+            }
+            else {
+                nds.pen.sel+= 1;
+                if (nds.pen.sel >= nds.pen.max) {
+                    nds.pen.sel = 0;
+                }
+                reload_pen();
+            }
+        }
+        else {
+            nds.menu.sel+= 1;
+            if (nds.menu.sel >= nds.menu.max) {
+                nds.menu.sel = 0;
+            }
+            reload_menu();
+
+            if (nds.menu.drastic.enable) {
+                SDL_SendKeyboardKey(SDL_PRESSED, SDLK_e);
+                usleep(100000);
+                SDL_SendKeyboardKey(SDL_RELEASED, SDLK_e);
+            }
+        }
+        set_key(MYKEY_Y, 0);
+    }
+
+    if (hotkey_mask && hit_hotkey(MYKEY_START)) {
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
+        if (nds.menu.enable == 0) {
+#ifdef QX1000
+            update_wayland_res(640, 480);
+#endif
+            // acquire a lock
+            pthread_mutex_lock(&lock);
+
+            nds.menu.enable = 1;
+            handle_menu(-1);
+
+            pthread_cond_signal(&request_update_screen_cond);
+
+            pthread_cond_wait(&response_update_screen_cond, &lock);
+
+            // release lock
+            pthread_mutex_unlock(&lock);
+//            nds.menu.enable = 1;
+//            usleep(100000);
+//            handle_menu(-1);
+            cur_keypad_bitmaps = 0;
+            pre_keypad_bitmaps = evt.keypad.bitmaps = 0;
+        }
+#endif
+
+#if defined(TRIMUI) || defined(PANDORA) || defined(QX1000)
+        set_key(MYKEY_EXIT, 1);
+#endif
+        set_key(MYKEY_START, 0);
+    }
+
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
+    if (nds.hotkey == HOTKEY_BIND_MENU) {
+        if (hotkey_mask && hit_hotkey(MYKEY_SELECT)) {
+            set_key(MYKEY_MENU_ONION, 1);
+            set_key(MYKEY_SELECT, 0);
+        }
+    }
+#endif
+
+#if defined(TRIMUI) || defined(PANDORA) || defined(QX1000)
+    if (hotkey_mask && hit_hotkey(MYKEY_SELECT)) {
+        set_key(MYKEY_MENU_ONION, 1);
+        set_key(MYKEY_SELECT, 0);
+    }
+#endif
+
+    if (hotkey_mask && hit_hotkey(MYKEY_R1)) {
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
+        static int pre_ff = 0;
+
+        if (pre_ff != nds.fast_forward) {
+            pre_ff = nds.fast_forward;
+            //dtr_fastforward(nds.fast_forward);
+        }
+        set_key(MYKEY_FF, 1);
+#endif
+
+#if defined(TRIMUI) || defined(PANDORA)
+        set_key(MYKEY_QSAVE, 1);
+#endif
+        set_key(MYKEY_R1, 0);
+    }
+
+    if (hotkey_mask && hit_hotkey(MYKEY_L1)) {
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
+        set_key(MYKEY_EXIT, 1);
+#endif
+
+#if defined(TRIMUI) || defined(PANDORA)
+        set_key(MYKEY_QLOAD, 1);
+#endif
+        set_key(MYKEY_L1, 0);
+    }
+
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
+    if (hotkey_mask && hit_hotkey(MYKEY_R2)) {
+#if defined(MMIYOO) || defined(A30)
+        set_key(MYKEY_QLOAD, 1);
+#else
+        set_key(MYKEY_QSAVE, 1);
+#endif
+        set_key(MYKEY_R2, 0);
+    }
+
+    if (hotkey_mask && hit_hotkey(MYKEY_L2)) {
+#if defined(MMIYOO) || defined(A30)
+        set_key(MYKEY_QSAVE, 1);
+#else
+        set_key(MYKEY_QLOAD, 1);
+#endif
+        set_key(MYKEY_L2, 0);
+    }
+    else if (evt.keypad.bitmaps & (1 << MYKEY_L2)) {
+        if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0)) {
+            evt.mode = (evt.mode == MMIYOO_KEYPAD_MODE) ? MMIYOO_MOUSE_MODE : MMIYOO_KEYPAD_MODE;
+            set_key(MYKEY_L2, 0);
+
+            if (evt.mode == MMIYOO_MOUSE_MODE) {
+                release_all_keys();
+            }
+            lower_speed = 0;
+        }
+    }
+#endif
+
+    if (!(evt.keypad.bitmaps & 0x0f)) {
+        nds.pen.pre_ticks = clock();
+    }
+
+    return 0;
+}
+
 int EventUpdate(void *data)
 {
     struct input_event ev = {0};
 
     uint32_t l1 = L1;
     uint32_t r1 = R1;
-#if defined(MMIYOO) || defined(QX1000)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
     uint32_t l2 = L2;
     uint32_t r2 = R2;
 #endif
@@ -329,14 +879,59 @@ int EventUpdate(void *data)
     uint32_t left = LEFT;
     uint32_t right = RIGHT;
 
-    int hotkey_mask = 0;
-#ifdef TRIMUI
-    char buf[MAX_PATH << 1] = {0};
+#ifdef RG35XXH
+	int i;
+	int input[NUM_OF_MYKEY] = {UP, DOWN, LEFT, RIGHT, A, B, X, Y, L1, R1, L2, R2, L3, R3,SELECT, START, MENU,-1, -1, -1, -1};
+
+	for (i=0; i < NUM_OF_MYKEY; i++) {
+		if (nds.input.key[i] != -1) {
+			printf(PREFIX"nds.input.key[%d]=%d\n", i, nds.input.key[i] );
+			input[i] = nds.input.key[i];
+		}
+	}
+	
 #endif
 
     while (running) {
         SDL_SemWait(event_sem);
 
+#ifdef RG35XXH
+        if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0) && nds.keys_rotate) {
+            if (nds.keys_rotate == 1) {
+                up = input[MYKEY_LEFT];
+                down = input[MYKEY_RIGHT];
+                left = input[MYKEY_DOWN];
+                right = input[MYKEY_UP];
+
+                a = input[MYKEY_X];
+                b = input[MYKEY_A];
+                x = input[MYKEY_Y];
+                y = input[MYKEY_B];
+            }
+            else {
+                up = input[MYKEY_RIGHT];
+                down = input[MYKEY_LEFT];
+                left = input[MYKEY_UP];
+                right = input[MYKEY_DOWN];
+
+                a = input[MYKEY_B];
+                b = input[MYKEY_Y];
+                x = input[MYKEY_A];
+                y = input[MYKEY_X];
+            }
+        }
+        else {
+            up = input[MYKEY_UP];
+            down = input[MYKEY_DOWN];
+            left = input[MYKEY_LEFT];
+            right = input[MYKEY_RIGHT];
+
+            a = input[MYKEY_A];
+            b = input[MYKEY_B];
+            x = input[MYKEY_X];
+            y = input[MYKEY_Y];
+        }
+#else
         if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0) && nds.keys_rotate) {
             if (nds.keys_rotate == 1) {
                 up = LEFT;
@@ -372,8 +967,27 @@ int EventUpdate(void *data)
             x = X;
             y = Y;
         }
+#endif
+
+#if defined(RG35XXH)
+        if (nds.swap_l1l2) {
+            l1 = input[MYKEY_L2];
+            l2 = input[MYKEY_L1];
+        }
+        else {
+            l1 = input[MYKEY_L1];
+            l2 = input[MYKEY_L2];
+        }
 
-#if defined(MMIYOO) || defined(QX1000)
+        if (nds.swap_r1r2) {
+            r1 = input[MYKEY_R2];
+            r2 = input[MYKEY_R1];
+        }
+        else {
+            r1 = input[MYKEY_R1];
+            r2 = input[MYKEY_R2];
+        }
+#elif defined(MMIYOO) || defined(QX1000) || defined(A30)
         if (nds.swap_l1l2) {
             l1 = L2;
             l2 = L1;
@@ -406,27 +1020,375 @@ int EventUpdate(void *data)
 #endif
 
         if (event_fd > 0) {
+            int r = 0;
+
             if (read(event_fd, &ev, sizeof(struct input_event))) {
-                if ((ev.type == EV_KEY) && (ev.value != 2)) {
+				if (ev.type == EV_ABS) {
+					if (ev.code == ABS_HAT0X) {
+						 if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0) && nds.keys_rotate) {
+							if (nds.keys_rotate == 1) {
+								// degree 270
+								if (ev.value < 0) { 
+									// up 
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+									set_key(MYKEY_UP,    1); 
+								}  
+								else if (ev.value > 0) { 
+									// down 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+										set_key(MYKEY_UP, 0); 
+									} 
+									set_key(MYKEY_DOWN,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+										set_key(MYKEY_UP, 0); 
+									} 
+
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+								}
+							}
+							else {
+								// degree 90
+								if (ev.value > 0) { 
+									// up 
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+									set_key(MYKEY_UP,    1); 
+								}  
+								else if (ev.value < 0) { 
+									// down 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+										set_key(MYKEY_UP, 0); 
+									} 
+									set_key(MYKEY_DOWN,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+										set_key(MYKEY_UP, 0); 
+									} 
+
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+								} 
+							}
+						 }
+						else {
+							// degree 0
+				
+							if (ev.value < 0) {
+								// left
+								if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+									set_key(MYKEY_RIGHT, 0);
+								}
+								set_key(MYKEY_LEFT,    1); 
+							} 
+							else if (ev.value > 0) {
+								// right
+								if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+									set_key(MYKEY_LEFT, 0);
+								} 
+								set_key(MYKEY_RIGHT,    1); 
+							} 
+							else { 
+								// center 
+								if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+									set_key(MYKEY_LEFT, 0); 
+								} 
+								if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+									set_key(MYKEY_RIGHT, 0); 
+								} 
+							} 
+						}
+					} 
+					else if (ev.code == ABS_HAT0Y) { 
+						if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0) && nds.keys_rotate) {
+							if (nds.keys_rotate == 1) {
+								// degree 270
+								if (ev.value > 0) {
+									// left
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+										set_key(MYKEY_RIGHT, 0);
+									}
+									set_key(MYKEY_LEFT,    1); 
+								} 
+								else if (ev.value < 0) {
+									// right
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+										set_key(MYKEY_LEFT, 0);
+									} 
+									set_key(MYKEY_RIGHT,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+										set_key(MYKEY_LEFT, 0); 
+									} 
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+										set_key(MYKEY_RIGHT, 0); 
+									} 
+								} 
+							}
+							else {
+								// degree 90
+								if (ev.value < 0) {
+									// left
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+										set_key(MYKEY_RIGHT, 0);
+									}
+									set_key(MYKEY_LEFT,    1); 
+								} 
+								else if (ev.value > 0) {
+									// right
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+										set_key(MYKEY_LEFT, 0);
+									} 
+									set_key(MYKEY_RIGHT,    1); 
+								} 
+								else { 
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+										set_key(MYKEY_LEFT, 0); 
+									} 
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+										set_key(MYKEY_RIGHT, 0); 
+									} 
+								} 
+							}
+						}
+						else {
+							// degree 0
+							
+							if (ev.value < 0) { 
+								// up 
+								if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+									set_key(MYKEY_DOWN, 0); 
+								} 
+								set_key(MYKEY_UP,    1); 
+							}  
+							else if (ev.value > 0) { 
+								// down 
+								if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+									set_key(MYKEY_UP, 0); 
+								} 
+								set_key(MYKEY_DOWN,    1); 
+							} 
+							else { 
+								// center 
+								if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+									set_key(MYKEY_UP, 0); 
+								} 
+
+								if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+									set_key(MYKEY_DOWN, 0); 
+								} 
+							} 
+						}
+					} 
+					else if (ev.code == ABS_Z) {
+						// left analog x
+						if (ev.value < -100) {
+							// left
+							evt.analogstick_left_x = ev.value / 1024;;
+						}
+						else if (ev.value > 100) {
+							// right
+							evt.analogstick_left_x = ev.value / 1024;;
+						}
+						else {
+							// center 
+							evt.analogstick_left_x = 0;
+						}						
+					}
+					else if (ev.code == ABS_RX) {
+						// left analog y
+						if (ev.value < -100) {
+							// up
+							evt.analogstick_left_y = ev.value / 1024;
+						}
+						else if (ev.value > 100) {
+							// down
+							evt.analogstick_left_y = ev.value / 1024;
+						}
+						else {
+							// center 
+							evt.analogstick_left_y = 0;
+						}		
+					}					
+					else if (ev.code == ABS_RY) {
+						if (nds.dis_mode == NDS_DIS_MODE_HH1) {
+							if (evt.mode == MMIYOO_KEYPAD_MODE) {
+								// right analog x -> dpad
+								// left -> up
+								// right -> down
+								if (ev.value < -100) {
+									// up 
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 
+									set_key(MYKEY_UP,    1); 							
+								}
+								else if (ev.value > 100) {
+									// down 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) {
+										set_key(MYKEY_UP, 0); 
+									} 
+									set_key(MYKEY_DOWN,    1); 							
+								}
+								else {
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_UP)) { 
+										set_key(MYKEY_UP, 0); 
+									} 
+
+									if (evt.keypad.bitmaps & (1 << MYKEY_DOWN)) { 
+										set_key(MYKEY_DOWN, 0); 
+									} 							
+								}
+							}
+							else {
+								// right analog x -> touch
+								// left -> up
+								// right -> down
+								if (ev.value < -100) {
+									// up 
+									evt.analogstick_right_y = ev.value / 1024;
+								}
+								else if (ev.value > 100) {
+									// down 
+									evt.analogstick_right_y= ev.value / 1024;
+								}
+								else {
+									// center 
+									evt.analogstick_right_y = 0;
+								}								
+							}
+						}
+					}
+					else if (ev.code ==  ABS_RZ) {
+						if (nds.dis_mode == NDS_DIS_MODE_HH1) {
+							if (evt.mode == MMIYOO_KEYPAD_MODE) {
+								// right analog y to dpad
+								// down ->left
+								// up -> right
+								if (ev.value < -100) {
+									// right
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) {
+										set_key(MYKEY_LEFT, 0);
+									} 
+									set_key(MYKEY_RIGHT,    1); 					
+								}
+								else if (ev.value > 100) {
+									// left
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) {
+										set_key(MYKEY_RIGHT, 0);
+									}
+									set_key(MYKEY_LEFT,    1); 									
+								}
+								else {
+									// center 
+									if (evt.keypad.bitmaps & (1 << MYKEY_LEFT)) { 
+										set_key(MYKEY_LEFT, 0); 
+									} 
+									if (evt.keypad.bitmaps & (1 << MYKEY_RIGHT)) { 
+										set_key(MYKEY_RIGHT, 0); 
+									} 							
+								}
+							}
+							else {
+								// right analog y to touch
+								// down ->left
+								// up -> right
+								if (ev.value < -100) {
+									// up 
+									evt.analogstick_right_x= ev.value  *  (-1) / 1024;
+								}
+								else if (ev.value > 100) {
+									// down 
+									evt.analogstick_right_x= ev.value  * (-1) / 1024;
+								}
+								else {
+									// center 
+									evt.analogstick_right_x  = 0;
+								}										
+							}
+						}
+					}
+				}
+                else if ((ev.type == EV_KEY) && (ev.value != 2)) {
+                    r = 1;
                     //printf(PREFIX"code:%d, value:%d\n", ev.code, ev.value);
                     if (ev.code == l1)      { set_key(MYKEY_L1,    ev.value); }
                     if (ev.code == r1)      { set_key(MYKEY_R1,    ev.value); }
-                    if (ev.code == up)      { set_key(MYKEY_UP,    ev.value); }
-                    if (ev.code == down)    { set_key(MYKEY_DOWN,  ev.value); }
-                    if (ev.code == left)    { set_key(MYKEY_LEFT,  ev.value); }
-                    if (ev.code == right)   { set_key(MYKEY_RIGHT, ev.value); }
+
+                    if (up != -1 && ev.code == up)      { set_key(MYKEY_UP,    ev.value); }
+                    if (down != -1 && ev.code == down)    { set_key(MYKEY_DOWN,  ev.value); }
+                    if (left != -1 && ev.code == left)    { set_key(MYKEY_LEFT,  ev.value); }
+                    if (right != -1 && ev.code == right)   { set_key(MYKEY_RIGHT, ev.value); }
+
                     if (ev.code == a)       { set_key(MYKEY_A,     ev.value); }
                     if (ev.code == b)       { set_key(MYKEY_B,     ev.value); }
                     if (ev.code == x)       { set_key(MYKEY_X,     ev.value); }
                     if (ev.code == y)       { set_key(MYKEY_Y,     ev.value); }
-#if defined(MMIYOO) || defined(QX1000)
-                    if (ev.code == l2)      { set_key(MYKEY_L2,    ev.value); }
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
+#ifdef A30
+                    if (ev.code == r2) {
+                        if (nds.joy.mode == MYJOY_MODE_MOUSE) {
+                            if (cur_keypad_bitmaps & (1 << ((nds.hotkey == HOTKEY_BIND_SELECT) ? MYKEY_SELECT : MYKEY_MENU))) {
+                                set_key(MYKEY_L2, ev.value);
+                            }
+                            else {
+                                int x = 0;
+                                int y = 0;
+
+                                nds.joy.show_cnt = MYJOY_SHOW_CNT;
+                                x = (evt.mouse.x * 160) / evt.mouse.maxx;
+                                y = (evt.mouse.y * 120) / evt.mouse.maxy;
+                                SDL_SendMouseMotion(vid.window, 0, 0, x + 80, y + (nds.pen.pos ? 120 : 0));
+                                SDL_SendMouseButton(vid.window, 0, ev.value ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_LEFT);
+                            }
+                        }
+                        else {
+                            set_key(MYKEY_L2, ev.value);
+                        }
+                    }
+                    if (ev.code == l2)      { set_key(MYKEY_R2,    ev.value); }
+#elif defined(RG35XXH)
                     if (ev.code == r2)      { set_key(MYKEY_R2,    ev.value); }
+                    if (ev.code == l2)      { set_key(MYKEY_L2,    ev.value); }
+#else
+                    if (ev.code == r2)      { set_key(MYKEY_L2,    ev.value); }
+                    if (ev.code == l2)      { set_key(MYKEY_R2,    ev.value); }
+#endif
 #endif
+
+#if defined(RG35XXH)
+                    if (ev.code == input[MYKEY_L3])      { set_key(MYKEY_L3,    ev.value);}
+                    if (ev.code == input[MYKEY_R3])      { set_key(MYKEY_R3,    ev.value);}
+					if (input[MYKEY_QSAVE] != -1 && ev.code == input[MYKEY_QSAVE])      { set_key(MYKEY_QSAVE,    ev.value); }
+					if (input[MYKEY_QLOAD] != -1 && ev.code == input[MYKEY_QLOAD])      { set_key(MYKEY_QLOAD,    ev.value); }
+					if (input[MYKEY_EXIT] != -1 && ev.code == input[MYKEY_EXIT])      { set_key(MYKEY_EXIT,    ev.value); }
+	
+                    if (ev.code == input[MYKEY_START])      { set_key(MYKEY_START,    ev.value); }
+                    if (ev.code == input[MYKEY_SELECT])      { set_key(MYKEY_SELECT,    ev.value); }
+                    if (ev.code == input[MYKEY_MENU])      { set_key(MYKEY_MENU,    ev.value); }					
+					
+#endif
+
 #ifdef QX1000
                     if (ev.code == L10)     { set_key(MYKEY_L1,    ev.value); }
                     if (ev.code == R10)     { set_key(MYKEY_R1,    ev.value); }
 #endif
+
+#ifndef RG35XXH
                     switch (ev.code) {
                     case START:  set_key(MYKEY_START, ev.value);  break;
                     case SELECT: set_key(MYKEY_SELECT, ev.value); break;
@@ -461,296 +1423,37 @@ int EventUpdate(void *data)
                         }
                         break;
 #endif
-                    }
-
-                    hotkey_mask = 1;
-                    if (nds.menu.enable || nds.menu.drastic.enable) {
-                        hotkey_mask = 0;
-                    }
-
-                    if (hotkey_mask && hit_hotkey(MYKEY_UP)) {
-#if defined(MMIYOO) || defined(QX1000)
-                        if (evt.mode == MMIYOO_MOUSE_MODE) {
-                            switch (nds.dis_mode) {
-                            case NDS_DIS_MODE_VH_T0:
-                            case NDS_DIS_MODE_VH_T1:
-                            case NDS_DIS_MODE_S0:
-                            case NDS_DIS_MODE_S1:
-                                break;
-                            default:
-                                nds.pen.pos = 1;
-                                break;
-                            }
-                        }
-#endif
-                        set_key(MYKEY_UP, 0);
-                    }
-
-                    if (hotkey_mask && hit_hotkey(MYKEY_DOWN)) {
-#if defined(MMIYOO) || defined(QX1000)
-                        if (evt.mode == MMIYOO_MOUSE_MODE) {
-                            switch (nds.dis_mode) {
-                            case NDS_DIS_MODE_VH_T0:
-                            case NDS_DIS_MODE_VH_T1:
-                            case NDS_DIS_MODE_S0:
-                            case NDS_DIS_MODE_S1:
-                                break;
-                            default:
-                                nds.pen.pos = 0;
-                                break;
-                            }
-                        }
-#endif
-                        set_key(MYKEY_DOWN, 0);
-                    }
-
-                    if (hotkey_mask && hit_hotkey(MYKEY_LEFT)) {
-#ifdef MMIYOO
-                        if (nds.hres_mode == 0) {
-                            if (nds.dis_mode > 0) {
-                                nds.dis_mode-= 1;
-                            }
-                        }
-                        else {
-                            nds.dis_mode = NDS_DIS_MODE_HRES0;
-                        }
-#endif
-
-#if defined(TRIMUI) || defined(FUNKEYS) || defined(PANDORA)
-                        if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0)) {
-                            evt.mode = (evt.mode == MMIYOO_KEYPAD_MODE) ? MMIYOO_MOUSE_MODE : MMIYOO_KEYPAD_MODE;
-
-                            if (evt.mode == MMIYOO_MOUSE_MODE) {
-                                release_all_keys();
-                            }
-                            lower_speed = 0;
-                        }
-#endif
-                        set_key(MYKEY_LEFT, 0);
-                    }
-
-                    if (hotkey_mask && hit_hotkey(MYKEY_RIGHT)) {
-#ifdef MMIYOO
-                        if (nds.hres_mode == 0) {
-                            if (nds.dis_mode < NDS_DIS_MODE_LAST) {
-                                nds.dis_mode+= 1;
-                            }
-                        }
-                        else {
-                            nds.dis_mode = NDS_DIS_MODE_HRES1;
-                        }
-#endif
-
-#if defined(TRIMUI) || defined(FUNKEYS) || defined(PANDORA)
-                        set_key(MYKEY_R2, 1);
-#endif
-                        set_key(MYKEY_RIGHT, 0);
-                    }
-
-                    if (hotkey_mask && hit_hotkey(MYKEY_A)) {
-#ifdef MMIYOO
-                        if ((evt.mode == MMIYOO_KEYPAD_MODE) && (nds.hres_mode == 0)) {
-                            uint32_t tmp = nds.alt_mode;
-                            nds.alt_mode = nds.dis_mode;
-                            nds.dis_mode = tmp;
-                        }
-#endif
 
-#ifdef TRIMUI
-                        nds.dis_mode = (nds.dis_mode == NDS_DIS_MODE_S0) ? NDS_DIS_MODE_S1 : NDS_DIS_MODE_S0;
-                        disp_resize();
-#endif
-                        set_key(MYKEY_A, 0);
-                    }
-
-                    if (hotkey_mask && hit_hotkey(MYKEY_B)) {
-#ifdef MMIYOO
-                        pixel_filter = pixel_filter ? 0 : 1;
-#endif
-                        set_key(MYKEY_B, 0);
-                    }
-
-                    if (hit_hotkey(MYKEY_X)) {
-#ifdef MMIYOO
-#endif
-
-#ifdef TRIMUI
-                        int w = FB_W;
-                        int h = FB_H;
-                        int pitch = FB_W * FB_BPP;
-                        uint32_t *dst = NULL;
-                        SDL_Surface *p = NULL;
-                        time_t t = time(NULL);
-                        struct tm tm = *localtime(&t);
-
-                        // for MMIYOO
-                        // dst = (uint32_t *)gfx.fb.virAddr + (w * (gfx.vinfo.yoffset ? 0 : h));
-                        dst = (uint32_t *)gfx.hw.ion.vadd + (w * h * (gfx.fb.flip ? 0 : 1));
-
-                        if (nds.dis_mode == NDS_DIS_MODE_S0) {
-                            w = NDS_H;
-                            h = NDS_W;
-                        }
-                        else {
-                            w = FB_H;
-                            h = FB_W;
-                        }
-                        pitch = FB_H * FB_BPP;
-
-                        if (dst) {
-                            p = SDL_CreateRGBSurfaceFrom(dst, w, h, 32, pitch, 0, 0, 0, 0);
-                            if (p) {
-                                sprintf(buf, "%s/%02d%02d%02d.png", nds.shot.path, tm.tm_hour, tm.tm_min, tm.tm_sec);
-                                IMG_SavePNG(p, buf);
-                                SDL_FreeSurface(p);
-                                printf(PREFIX"Saved \'%s\'\n", buf);
-                            }
-                        }
-                        nds.shot.take = 1;
-#endif
-                        set_key(MYKEY_X, 0);
-                    }
-
-                    if (hit_hotkey(MYKEY_Y)) {
-                        if (hotkey_mask) {
-                            if (evt.mode == MMIYOO_KEYPAD_MODE) {
-                                if ((nds.overlay.sel >= nds.overlay.max) &&
-                                    (nds.dis_mode != NDS_DIS_MODE_VH_T0) &&
-                                    (nds.dis_mode != NDS_DIS_MODE_VH_T1) &&
-                                    (nds.dis_mode != NDS_DIS_MODE_S1) &&
-                                    (nds.dis_mode != NDS_DIS_MODE_HRES1))
-                                {
-                                    nds.theme.sel+= 1;
-                                    if (nds.theme.sel > nds.theme.max) {
-                                        nds.theme.sel = 0;
-                                    }
-                                }
-                            }
-                            else {
-                                nds.pen.sel+= 1;
-                                if (nds.pen.sel >= nds.pen.max) {
-                                    nds.pen.sel = 0;
-                                }
-                                reload_pen();
-                            }
-                        }
-                        else {
-                            nds.menu.sel+= 1;
-                            if (nds.menu.sel >= nds.menu.max) {
-                                nds.menu.sel = 0;
-                            }
-                            reload_menu();
-
-                            if (nds.menu.drastic.enable) {
-                                SDL_SendKeyboardKey(SDL_PRESSED, SDLK_e);
-                                usleep(100000);
-                                SDL_SendKeyboardKey(SDL_RELEASED, SDLK_e);
-                            }
-                        }
-                        set_key(MYKEY_Y, 0);
-                    }
-
-#ifndef FUNKEYS
-                    if (hotkey_mask && hit_hotkey(MYKEY_START)) {
-#if defined(MMIYOO) || defined(QX1000)
-                        if (nds.menu.enable == 0) {
-#ifdef QX1000
-                            update_wayland_res(640, 480);
-#endif
-                            nds.menu.enable = 1;
-                            usleep(100000);
-                            handle_menu(-1);
-                            hotkey = 0;
-                            pre_keypad_bitmaps = evt.keypad.bitmaps = 0;
-                        }
-#endif
-
-#if defined(TRIMUI) || defined(PANDORA) || defined(QX1000)
-                        set_key(MYKEY_EXIT, 1);
-#endif
-                        set_key(MYKEY_START, 0);
-                    }
-#endif
-
-#ifdef MMIYOO
-                    if (nds.hotkey == HOTKEY_BIND_MENU) {
-                        if (hotkey_mask && hit_hotkey(MYKEY_SELECT)) {
-                            set_key(MYKEY_MENU_ONION, 1);
-                            set_key(MYKEY_SELECT, 0);
+#ifdef A30
+                    case VOLUP:
+                        set_key(MYKEY_VOLUP, ev.value);
+                        if (ev.value == 0) {
+                            nds.volume = volume_inc();
                         }
-                    }
-#endif
-
-#if defined(TRIMUI) || defined(PANDORA) || defined(QX1000)
-                    if (hotkey_mask && hit_hotkey(MYKEY_SELECT)) {
-                        set_key(MYKEY_MENU_ONION, 1);
-                        set_key(MYKEY_SELECT, 0);
-                    }
-#endif
-
-#ifdef FUNKEYS
-                    if (hotkey_mask && hit_hotkey(MYKEY_SELECT)) {
-                        set_key(MYKEY_EXIT, 1);
-                        set_key(MYKEY_SELECT, 0);
-                    }
-#endif
-
-                    if (hotkey_mask && hit_hotkey(MYKEY_R1)) {
-#ifdef MMIYOO
-                        static int pre_ff = 0;
-
-                        if (pre_ff != nds.fast_forward) {
-                            pre_ff = nds.fast_forward;
-                            dtr_fastforward(nds.fast_forward);
+                        break;
+                    case VOLDOWN:
+                        set_key(MYKEY_VOLDOWN, ev.value);
+                        if (ev.value == 0) {
+                            nds.volume = volume_dec();
                         }
-                        set_key(MYKEY_FF, 1);
-#endif
-
-#if defined(TRIMUI) || defined(FUNKEYS) || defined(PANDORA)
-                        set_key(MYKEY_QSAVE, 1);
+                        break;
 #endif
-                        set_key(MYKEY_R1, 0);
                     }
-
-                    if (hotkey_mask && hit_hotkey(MYKEY_L1)) {
-#ifdef MMIYOO
-                        set_key(MYKEY_EXIT, 1);
 #endif
-
-#if defined(TRIMUI) || defined(FUNKEYS) || defined(PANDORA)
-                        set_key(MYKEY_QLOAD, 1);
+                }
+            }
+#if defined(A30) && USE_MYJOY
+            r |= update_joystick();
 #endif
-                        set_key(MYKEY_L1, 0);
-                    }
 
-#if defined(MMIYOO) || defined(QX1000)
-                    if (hotkey_mask && hit_hotkey(MYKEY_R2)) {
-                        set_key(MYKEY_QSAVE, 1);
-                        set_key(MYKEY_R2, 0);
-                    }
-
-                    if (hotkey_mask && hit_hotkey(MYKEY_L2)) {
-                        set_key(MYKEY_QLOAD, 1);
-                        set_key(MYKEY_L2, 0);
-                    }
-                    else if (evt.keypad.bitmaps & (1 << MYKEY_L2)) {
-                        if ((nds.menu.enable == 0) && (nds.menu.drastic.enable == 0)) {
-                            evt.mode = (evt.mode == MMIYOO_KEYPAD_MODE) ? MMIYOO_MOUSE_MODE : MMIYOO_KEYPAD_MODE;
-                            set_key(MYKEY_L2, 0);
-
-                            if (evt.mode == MMIYOO_MOUSE_MODE) {
-                                release_all_keys();
-                            }
-                            lower_speed = 0;
-                        }
-                    }
+#ifndef RG35XXH
+            if (r > 0) {
+                handle_hotkey();
 #endif
-                }
             
-                if (!(evt.keypad.bitmaps & 0x0f)) {
-                    nds.pen.pre_ticks = clock();
-                }
-            }
+#ifdef RG35XXH
+            handle_hotkey();
+#endif
         }
         SDL_SemPost(event_sem);
         usleep(1000000 / 60);
@@ -761,7 +1464,7 @@ int EventUpdate(void *data)
 
 void MMIYOO_EventInit(void)
 {
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(RG35XXH)
     DIR *dir = NULL;
 #endif
 
@@ -793,7 +1496,14 @@ void MMIYOO_EventInit(void)
 #endif
     evt.mode = MMIYOO_KEYPAD_MODE;
 
-    event_fd = open(INPUT_DEV, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
+	if (strlen(nds.input.dev) > 0) {
+		printf(PREFIX"nds.input.dev=%s\n", nds.input.dev);
+		event_fd = open(nds.input.dev, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
+	}
+	else {
+		event_fd = open(INPUT_DEV, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
+	}
+	
     if(event_fd < 0){
         printf(PREFIX"Failed to open event0\n");
     }
@@ -850,7 +1560,7 @@ void MMIYOO_PumpEvents(_THIS)
 {
     SDL_SemWait(event_sem);
     if (nds.menu.enable) {
-#if defined(MMIYOO) || defined(QX1000)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         int cc = 0;
         uint32_t bit = 0;
         uint32_t changed = pre_keypad_bitmaps ^ evt.keypad.bitmaps;
@@ -859,7 +1569,15 @@ void MMIYOO_PumpEvents(_THIS)
             bit = 1 << cc;
             if (changed & bit) {
                 if ((evt.keypad.bitmaps & bit) == 0) {
+                    // acquire a lock
+                    pthread_mutex_lock(&lock);
                     handle_menu(cc);
+                    pthread_cond_signal(&request_update_screen_cond);
+
+                    pthread_cond_wait(&response_update_screen_cond, &lock);
+
+                    // release lock
+                    pthread_mutex_unlock(&lock);
                 }
             }
         }
@@ -876,7 +1594,7 @@ void MMIYOO_PumpEvents(_THIS)
                 for (cc=0; cc<=MYKEY_LAST_BITS; cc++) {
                     bit = 1 << cc;
 
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                     if ((nds.hotkey == HOTKEY_BIND_MENU) && (cc == MYKEY_MENU)) {
                         continue;
                     }
@@ -892,8 +1610,14 @@ void MMIYOO_PumpEvents(_THIS)
                         SDL_SendKeyboardKey((evt.keypad.bitmaps & bit) ? SDL_PRESSED : SDL_RELEASED, SDL_GetScancodeFromKey(code[cc]));
                     }
                 }
+				
+#ifdef RG35XXH
+				if (changed & (1 << MYKEY_R3)) {
+                    SDL_SendMouseButton(vid.window, 0, (evt.keypad.bitmaps & (1 << MYKEY_R3)) ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_LEFT);
+                }
+#endif
 
-#if defined(TRIMUI) || defined(FUNKEYS) || defined(PANDORA)
+#if defined(TRIMUI) || defined(PANDORA)
                 if (pre_keypad_bitmaps & (1 << MYKEY_R2)) {
                     set_key(MYKEY_R2, 0);
                 }
@@ -934,6 +1658,12 @@ void MMIYOO_PumpEvents(_THIS)
                     SDL_SendMouseButton(vid.window, 0, (evt.keypad.bitmaps & (1 << MYKEY_A)) ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_LEFT);
                 }
 
+#ifdef RG35XXH
+				if (changed & (1 << MYKEY_R3)) {
+                    SDL_SendMouseButton(vid.window, 0, (evt.keypad.bitmaps & (1 << MYKEY_R3)) ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_LEFT);
+                }
+#endif
+
                 for (cc=0; cc<=MYKEY_LAST_BITS; cc++) {
                     bit = 1 << cc;
                     if ((cc == MYKEY_FF) || (cc == MYKEY_QSAVE) || (cc == MYKEY_QLOAD) || (cc == MYKEY_EXIT) || (cc == MYKEY_R2)) {
@@ -990,13 +1720,18 @@ void MMIYOO_PumpEvents(_THIS)
             if(updated){
                 int x = 0;
                 int y = 0;
-
+#ifdef RG35XXH
+                x = (evt.mouse.x * 320) / evt.mouse.maxx;
+                y = (evt.mouse.y * 240) / evt.mouse.maxy;
+               SDL_SendMouseMotion(vid.window, 0, 0, x + 160, y + (nds.pen.pos ? 240 : 0));
+#else
                 x = (evt.mouse.x * 160) / evt.mouse.maxx;
                 y = (evt.mouse.y * 120) / evt.mouse.maxy;
                 SDL_SendMouseMotion(vid.window, 0, 0, x + 80, y + (nds.pen.pos ? 120 : 0));
+#endif
             }
 
-#if defined(TRIMUI) || defined(FUNKEYS) || defined(PANDORA)
+#if defined(TRIMUI) || defined(PANDORA)
                 if (pre_keypad_bitmaps & (1 << MYKEY_R2)) {
                     set_key(MYKEY_R2, 0);
                 }
@@ -1019,13 +1754,53 @@ void MMIYOO_PumpEvents(_THIS)
             pre_keypad_bitmaps = evt.keypad.bitmaps;
         }
     }
-    SDL_SemPost(event_sem);
-}
 
+#ifdef RG35XXH
+	{
+		// check left analog stick	
+		 int updated = 0;
+		 if (evt.analogstick_left_y != 0) {
+			updated = 1;
+			evt.mouse.y+= evt.analogstick_left_y;
+			evt.pen_display_cnt = 180;
+		}
+
+		if (evt.analogstick_left_x != 0) {
+			updated = 1;
+			evt.mouse.x+= evt.analogstick_left_x;
+			evt.pen_display_cnt = 180;
+		}
+
+		// check right analog stick	
+		 if (evt.analogstick_right_y != 0) {
+			updated = 1;
+			evt.mouse.y+= evt.analogstick_right_y;
+			evt.pen_display_cnt = 180;
+		}
+
+		if (evt.analogstick_right_x != 0) {
+			updated = 1;
+			evt.mouse.x+= evt.analogstick_right_x;
+			evt.pen_display_cnt = 180;
+		}
+		
+		check_mouse_pos();
+
+		if(updated){
+			int x = 0;
+			int y = 0;
+
+			x = (evt.mouse.x * 320) / evt.mouse.maxx;
+			y = (evt.mouse.y * 240) / evt.mouse.maxy;
+		   SDL_SendMouseMotion(vid.window, 0, 0, x + 160, y + (nds.pen.pos ? 240 : 0));
+		}	
+	}
 #endif
+    SDL_SemPost(event_sem);
+}
 
 #ifdef UNITTEST
-    #include "unity_fixture.h"
+#include "unity_fixture.h"
 
 TEST_GROUP(sdl2_event_mmiyoo);
 
diff --git a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h
index 873780a..d8a22c7 100644
--- a/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h
+++ b/sdl2/src/video/mmiyoo/SDL_event_mmiyoo.h
@@ -1,9 +1,10 @@
 /*
-  Customized version for Miyoo-Mini handheld.
-  Only tested under Miyoo-Mini stock OS (original firmware) with Parasyte compatible layer.
+  Special customized version for the DraStic emulator that runs on
+  Miyoo Mini (Plus), TRIMUI-SMART and Miyoo A30 handhelds.
 
   Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
-  Copyright (C) 2022-2022 Steward Fu <steward.fu@gmail.com>
+  Copyright (C) 2022-2024 Steward Fu <steward.fu@gmail.com>
+
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
   arising from the use of this software.
@@ -25,8 +26,38 @@
 #define __SDL_EVENT_MMIYOO_H__
 
 #include "../../SDL_internal.h"
-#include "SDL_event_mmiyoo.h"
+//#include "SDL_event_mmiyoo.h"
+#ifdef RG35XXH
+enum {
+    MYKEY_UP = 0,
+	MYKEY_DOWN,
+    MYKEY_LEFT,
+    MYKEY_RIGHT,
+    MYKEY_A,
+    MYKEY_B,
+    MYKEY_X,
+    MYKEY_Y,
+    MYKEY_L1,
+    MYKEY_R1,
+    MYKEY_L2,
+    MYKEY_R2,
+    MYKEY_L3,
+    MYKEY_R3,	
+    MYKEY_SELECT,
+    MYKEY_START,
+    MYKEY_MENU,
+    MYKEY_QSAVE,
+    MYKEY_QLOAD,
+    MYKEY_FF,
+    MYKEY_EXIT,
+    MYKEY_MENU_ONION,
+
+	NUM_OF_MYKEY
+};
+
+#define MYKEY_LAST_BITS     21 // ignore POWER, VOL-, VOL+ keys
 
+#else
 #define MYKEY_UP            0
 #define MYKEY_DOWN          1
 #define MYKEY_LEFT          2
@@ -39,19 +70,23 @@
 #define MYKEY_R1            9
 #define MYKEY_L2            10
 #define MYKEY_R2            11
-#define MYKEY_SELECT        12
-#define MYKEY_START         13
-#define MYKEY_MENU          14
-#define MYKEY_QSAVE         15
-#define MYKEY_QLOAD         16
-#define MYKEY_FF            17
-#define MYKEY_EXIT          18
-#define MYKEY_MENU_ONION    19
-#define MYKEY_POWER         20
-#define MYKEY_VOLUP         21
-#define MYKEY_VOLDOWN       22
-
-#define MYKEY_LAST_BITS     19 // ignore POWER, VOL-, VOL+ keys
+#define MYKEY_L3       12
+#define MYKEY_R3       13
+#define MYKEY_SELECT        14
+#define MYKEY_START         15
+#define MYKEY_MENU          16
+#define MYKEY_QSAVE         17
+#define MYKEY_QLOAD         18
+#define MYKEY_FF            19
+#define MYKEY_EXIT          20
+#define MYKEY_MENU_ONION    21
+#define MYKEY_POWER         22
+#define MYKEY_VOLUP         23
+#define MYKEY_VOLDOWN       24
+
+
+#define MYKEY_LAST_BITS     21// ignore POWER, VOL-, VOL+ keys
+#endif
 
 #define MMIYOO_KEYPAD_MODE 0
 #define MMIYOO_MOUSE_MODE  1
@@ -69,6 +104,13 @@ typedef struct _MMIYOO_EventInfo {
     } mouse;
 
     int mode;
+    
+    // by trngaje
+    int analogstick_left_x;
+    int analogstick_left_y;
+    int analogstick_right_x;
+    int analogstick_right_y;
+	int pen_display_cnt;
 } MMIYOO_EventInfo;
 
 extern void MMIYOO_EventInit(void);
diff --git a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c
index 73c1528..fece3ab 100644
--- a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c
+++ b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.c
@@ -1,9 +1,9 @@
 /*
-  Customized version for Miyoo-Mini handheld.
-  Only tested under Miyoo-Mini stock OS (original firmware) with Parasyte compatible layer.
+  Special customized version for the DraStic emulator that runs on
+  Miyoo Mini (Plus), TRIMUI-SMART and Miyoo A30 handhelds.
 
   Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
-  Copyright (C) 2022-2022 Steward Fu <steward.fu@gmail.com>
+  Copyright (C) 2022-2024 Steward Fu <steward.fu@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -21,9 +21,6 @@
      misrepresented as being the original software.
   3. This notice may not be removed or altered from any source distribution.
 */
-#include "../../SDL_internal.h"
-
-#if SDL_VIDEO_DRIVER_MMIYOO
 
 #include <time.h>
 #include <dirent.h>
@@ -37,16 +34,20 @@
 #include <fcntl.h>
 #include <string.h>
 #include <pthread.h>
+#include <errno.h>
 #include <sys/mman.h>
 #include <sys/ioctl.h>
 #include <sys/time.h>
 #include <time.h>
 #include <json-c/json.h>
+#include <EGL/egl.h>
+#include <GLES2/gl2.h>
 
-#include "../../events/SDL_events_c.h"
+#include "../../SDL_internal.h"
 #include "../SDL_sysvideo.h"
 #include "../SDL_sysvideo.h"
 #include "../SDL_pixels_c.h"
+#include "../../events/SDL_events_c.h"
 
 #include "SDL_image.h"
 #include "SDL_version.h"
@@ -67,7 +68,7 @@
 
 NDS nds = {0};
 GFX gfx = {0};
-MMIYOO_VideoInfo vid={0};
+MMIYOO_VideoInfo vid = {0};
 
 int FB_W = 0;
 int FB_H = 0;
@@ -76,15 +77,31 @@ int LINE_H = 0;
 int TMP_SIZE = 0;
 int FONT_SIZE = 0;
 int show_fps = 0;
-int pixel_filter = 0;
+int pixel_filter = 1;
 int savestate_busy = 0;
 SDL_Surface *fps_info = NULL;
 
+// add by trngaje begin ---------------------------------------------------------
+unsigned int g_save_slot = 0;
+
+// Declaration of thread condition variable
+pthread_cond_t request_update_screen_cond = PTHREAD_COND_INITIALIZER;
+pthread_cond_t response_update_screen_cond = PTHREAD_COND_INITIALIZER;
+
+// declaring mutex
+pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
+// add by trngaje end ---------------------------------------------------------
+
+
 static pthread_t thread;
-static int is_running = 0;
+static volatile int is_running = 0;
 static int need_reload_bg = RELOAD_BG_COUNT;
 static SDL_Surface *cvt = NULL;
 
+//extern scale_mat_NEON(const Uint32 *src, int src_w, int src_h, int src_pitch, Uint32 *dst, int dst_w, int dst_h, int dst_pitch);
+extern scale_mat(const Uint32 *src, int src_w, int src_h, int src_pitch,
+          Uint32 *dst, int dst_w, int dst_h, int dst_pitch);
+		  
 extern MMIYOO_EventInfo evt;
 
 static int MMIYOO_VideoInit(_THIS);
@@ -104,6 +121,180 @@ int need_restore = 0;
 int pre_dismode = 0;
 #endif
 
+#if defined(A30) || defined(RG35XXH_GL)
+GLfloat bgVertices[] = {
+   -1.0f,  1.0f,  0.0f,  0.0f,  0.0f,
+   -1.0f, -1.0f,  0.0f,  0.0f,  1.0f,
+    1.0f, -1.0f,  0.0f,  1.0f,  1.0f,
+    1.0f,  1.0f,  0.0f,  1.0f,  0.0f
+};
+
+GLfloat vVertices[] = {
+   -1.0f,  1.0f,  0.0f,  0.0f,  0.0f,
+   -1.0f, -1.0f,  0.0f,  0.0f,  1.0f,
+    1.0f, -1.0f,  0.0f,  1.0f,  1.0f,
+    1.0f,  1.0f,  0.0f,  1.0f,  0.0f
+};
+GLushort indices[] = {0, 1, 2, 0, 2, 3};
+
+#ifdef RG35XXH_GL
+const char *vShaderSrc =
+    "attribute vec4 a_position;   \n"
+    "attribute vec2 a_texCoord;   \n"
+    "varying vec2 v_texCoord;     \n"
+    "void main()                  \n"
+    "{                            \n"
+    "   gl_Position = a_position; \n"
+    "   v_texCoord = a_texCoord;  \n"
+    "}                            \n";
+	
+const char *vShaderDegree90Src =
+    "attribute vec4 a_position;   \n"
+    "attribute vec2 a_texCoord;   \n"
+    "attribute float a_alpha;     \n"
+    "varying vec2 v_texCoord;     \n"
+    "void main()                  \n"
+    "{                            \n"
+    "    const float angle = 90.0 * (3.1415 * 2.0) / 360.0;                                                                            \n"
+    "    mat4 rot = mat4(cos(angle), -sin(angle), 0.0, 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0); \n"
+    "    gl_Position = a_position * rot; \n"
+    "    v_texCoord = a_texCoord;        \n"
+    "}                                   \n";
+	
+const char *vShaderDegree180Src =
+    "attribute vec4 a_position;   \n"
+    "attribute vec2 a_texCoord;   \n"
+    "attribute float a_alpha;     \n"
+    "varying vec2 v_texCoord;     \n"
+    "void main()                  \n"
+    "{                            \n"
+    "    const float angle = 180.0 * (3.1415 * 2.0) / 360.0;                                                                            \n"
+    "    mat4 rot = mat4(cos(angle), -sin(angle), 0.0, 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0); \n"
+    "    gl_Position = a_position * rot; \n"
+    "    v_texCoord = a_texCoord;        \n"
+    "}                                   \n";
+	
+const char *vShaderDegree270Src =
+    "attribute vec4 a_position;   \n"
+    "attribute vec2 a_texCoord;   \n"
+    "attribute float a_alpha;     \n"
+    "varying vec2 v_texCoord;     \n"
+    "void main()                  \n"
+    "{                            \n"
+    "    const float angle = 270.0 * (3.1415 * 2.0) / 360.0;                                                                            \n"
+    "    mat4 rot = mat4(cos(angle), -sin(angle), 0.0, 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0); \n"
+    "    gl_Position = a_position * rot; \n"
+    "    v_texCoord = a_texCoord;        \n"
+    "}                                   \n";
+#else
+const char *vShaderSrc =
+    "attribute vec4 a_position;   \n"
+    "attribute vec2 a_texCoord;   \n"
+    "attribute float a_alpha;     \n"
+    "varying vec2 v_texCoord;     \n"
+    "void main()                  \n"
+    "{                            \n"
+    "    const float angle = 90.0 * (3.1415 * 2.0) / 360.0;                                                                            \n"
+    "    mat4 rot = mat4(cos(angle), -sin(angle), 0.0, 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0); \n"
+    "    gl_Position = a_position * rot; \n"
+    "    v_texCoord = a_texCoord;        \n"
+    "}                                   \n";
+#endif
+    
+const char *fShaderSrc =
+    "precision mediump float;                                  \n"
+    "varying vec2 v_texCoord;                                  \n"
+    "uniform float s_alpha;                                    \n"
+    "uniform sampler2D s_texture;                              \n"
+    "void main()                                               \n"
+    "{                                                         \n"
+    "    if (s_alpha >= 2.0) {                                 \n"
+    "        gl_FragColor = texture2D(s_texture, v_texCoord);  \n"
+    "    }                                                     \n"
+    "    else if (s_alpha > 0.0) {                             \n"
+    "        vec3 tex = texture2D(s_texture, v_texCoord).bgr;  \n"
+    "        gl_FragColor = vec4(tex, s_alpha);                \n"
+    "    }                                                     \n"
+    "    else {                                                \n"
+    "        vec3 tex = texture2D(s_texture, v_texCoord).bgr;  \n"
+    "        gl_FragColor = vec4(tex, 1.0);                    \n"
+    "    }                                                     \n"
+    "}                                                         \n";
+
+#ifndef RG35XXH_GL
+static struct _cpu_clock cpu_clock[] = {
+    {96, 0x80000110},
+    {144, 0x80000120},
+    {192, 0x80000130},
+    {216, 0x80000220},
+    {240, 0x80000410},
+    {288, 0x80000230},
+    {336, 0x80000610},
+    {360, 0x80000420},
+    {384, 0x80000330},
+    {432, 0x80000520},
+    {480, 0x80000430},
+    {504, 0x80000620},
+    {528, 0x80000a10},
+    {576, 0x80000530},
+    {624, 0x80000c10},
+    {648, 0x80000820},
+    {672, 0x80000630},
+    {720, 0x80000920},
+    {768, 0x80000730},
+    {792, 0x80000a20},
+    {816, 0x80001010},
+    {864, 0x80000830},
+    {864, 0x80001110},
+    {912, 0x80001210},
+    {936, 0x80000c20},
+    {960, 0x80000930},
+    {1008, 0x80000d20},
+    {1056, 0x80000a30},
+    {1080, 0x80000e20},
+    {1104, 0x80001610},
+    {1152, 0x80000b30},
+    {1200, 0x80001810},
+    {1224, 0x80001020},
+    {1248, 0x80000c30},
+    {1296, 0x80001120},
+    {1344, 0x80000d30},
+    {1368, 0x80001220},
+    {1392, 0x80001c10},
+    {1440, 0x80000e30},
+    {1488, 0x80001e10},
+    {1512, 0x80001420},
+    {1536, 0x80000f30},
+    {1584, 0x80001520},
+    {1632, 0x80001030},
+    {1656, 0x80001620},
+    {1728, 0x80001130},
+    {1800, 0x80001820},
+    {1824, 0x80001230},
+    {1872, 0x80001920},
+    {1920, 0x80001330},
+    {1944, 0x80001a20},
+    {2016, 0x80001430},
+    {2088, 0x80001c20},
+    {2112, 0x80001530},
+    {2160, 0x80001d20},
+    {2208, 0x80001630},
+    {2232, 0x80001e20},
+    {2304, 0x80001730},
+    {2400, 0x80001830},
+    {2496, 0x80001930},
+    {2592, 0x80001a30},
+    {2688, 0x80001b30},
+    {2784, 0x80001c30},
+    {2880, 0x80001d30},
+    {2976, 0x80001e30},
+    {3072, 0x80001f30},
+};
+
+static int max_cpu_item = sizeof(cpu_clock) / sizeof(struct _cpu_clock);
+#endif
+#endif
+
 #ifdef QX1000
 static struct _wayland wl = {0};
 
@@ -382,6 +573,7 @@ void egl_create(void)
     glViewport(0, 0, LCD_W, LCD_H);
     glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
     glClear(GL_COLOR_BUFFER_BIT);
+
     glVertexAttribPointer(wl.egl.positionLoc, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), egl_bg_vertices);
     glVertexAttribPointer(wl.egl.texCoordLoc, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), &egl_bg_vertices[3]);
     glEnableVertexAttribArray(wl.egl.positionLoc);
@@ -419,7 +611,7 @@ static void* draw_thread(void *pParam)
 }
 #endif
 
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30)
 static void* sdl_malloc(size_t size)
 {
     static int idx = 0;
@@ -430,7 +622,7 @@ static void* sdl_malloc(size_t size)
     if ((size == (NDS_W * NDS_H * bpp)) ||
         (size == (NDS_Wx2 * NDS_Hx2 * bpp)))
     {
-        r = gfx.lcd.virAddr[idx];
+        r = gfx.lcd.virAddr[0][idx];
         idx += 1;
         idx %= 2;
     }
@@ -442,7 +634,20 @@ static void* sdl_malloc(size_t size)
 
 static void sdl_free(void *ptr)
 {
-    if ((ptr != gfx.lcd.virAddr[0]) && (ptr != gfx.lcd.virAddr[1])) {
+    int c0 = 0;
+    int c1 = 0;
+    int found = 0;
+
+    for (c0 = 0; c0 < 2; c0++) {
+        for (c1 = 0; c1 < 2; c1++) {
+            if (ptr == gfx.lcd.virAddr[c0][c1]) {
+                found = 1;
+                break;
+            }
+        }
+    }
+
+    if (found == 0) {
         free(ptr);
     }
 }
@@ -532,7 +737,7 @@ static int draw_drastic_menu_main(void)
     CUST_MENU_SUB *p = NULL;
     char buf[MAX_PATH << 1] = {0};
 
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
     div = 2;
 #endif
 
@@ -542,7 +747,7 @@ static int draw_drastic_menu_main(void)
         w = LINE_H / div;
         h = nds.enable_752x560 ? (115 / div) : (100 / div);
 
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
         x = 30 / div;
 #endif
 
@@ -550,19 +755,13 @@ static int draw_drastic_menu_main(void)
         p = &drastic_menu.item[cc];
         if (p->y == 201) {
             draw = 1;
-#if defined(MMIYOO) || defined(TRIMUI)
+#if defined(MMIYOO) || defined(TRIMUI) || defined(A30) || defined(RG35XXH)
             sprintf(buf, "NDS %s", &p->msg[8]);
-            x = FB_W - get_font_width(buf) - 10;
-            y = 10 / div;
 #else
             sprintf(buf, "%s", &p->msg[8]);
+#endif
             x = FB_W - get_font_width(buf) - 10;
             y = 10 / div;
-#endif
-
-#if defined(FUNKEYS)
-            y = 4 / div;
-#endif
         }
         else if (p->y == 280) {
             draw = 1;
@@ -640,6 +839,10 @@ static int draw_drastic_menu_main(void)
     }
 
     y = 10;
+#if defined(A30) || defined(RG35XXH)
+    sprintf(buf, "Rel "NDS_VER" Res %s", "640*480");
+#endif
+
 #ifdef MMIYOO
     sprintf(buf, "Rel "NDS_VER" Res %s", nds.enable_752x560 ? "752*560" : "640*480");
 #endif
@@ -648,11 +851,6 @@ static int draw_drastic_menu_main(void)
     sprintf(buf, "Rel "NDS_VER" Res %s", "320*240");
 #endif
 
-#ifdef FUNKEYS
-    y = 4;
-    sprintf(buf, "Rel "NDS_VER);
-#endif
-
 #ifdef PANDORA
     sprintf(buf, "Rel "NDS_VER" Res %s", "800*480");
 #endif
@@ -670,23 +868,18 @@ static int draw_drastic_menu_main(void)
 
         if (top && bottom) {
             SDL_Surface *t = NULL;
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
             SDL_Surface *sm = NULL;
 #endif
 
-#if defined(FUNKEYS)
-            const int SM_W = NDS_W >> 1;
-            const int SM_H = NDS_H >> 1;
-#endif
-
 #if defined(TRIMUI)
             const int SM_W = (float)NDS_W / 1.35;
             const int SM_H = (float)NDS_H / 1.35;
 #endif
-            uint32_t slot = *((uint32_t *)VAR_SYSTEM_SAVESTATE_NUM);
+            uint32_t slot = g_save_slot; //*((uint32_t *)VAR_SYSTEM_SAVESTATE_NUM);
             nds_load_state_index _func = (nds_load_state_index)FUN_LOAD_STATE_INDEX;
 
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
             sm = SDL_CreateRGBSurface(0, SM_W, SM_H, 16, 0, 0, 0, 0);
 #endif
 
@@ -695,7 +888,7 @@ static int draw_drastic_menu_main(void)
             _func((void*)VAR_SYSTEM, slot, top, bottom, 1);
             t = SDL_CreateRGBSurfaceFrom(top, NDS_W, NDS_H, 16, NDS_W * 2, 0, 0, 0, 0);
             if (t) {
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                 rt.x = FB_W - (NDS_W + (nds.enable_752x560 ? 30 : 10));
                 rt.y = nds.enable_752x560 ? h - 20 : 50;
                 rt.w = NDS_W;
@@ -707,7 +900,7 @@ static int draw_drastic_menu_main(void)
 
             t = SDL_CreateRGBSurfaceFrom(bottom, NDS_W, NDS_H, 16, NDS_W * 2, 0, 0, 0, 0);
             if (t) {
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                 rt.x = FB_W - (NDS_W + (nds.enable_752x560 ? 30 : 10));
                 rt.y = nds.enable_752x560 ? (h + NDS_H) - 20 : 50 + NDS_H;
                 rt.w = NDS_W;
@@ -724,20 +917,10 @@ static int draw_drastic_menu_main(void)
                 rt.h = SM_H;
                 SDL_BlitSurface(sm, NULL, nds.menu.drastic.main, &rt);
 #endif
-
-#if defined(FUNKEYS)
-                SDL_SoftStretch(t, NULL, sm, NULL);
-
-                rt.x = FB_W - (SM_W + 5);
-                rt.y = 110;
-                rt.w = SM_W;
-                rt.h = SM_H;
-                SDL_BlitSurface(sm, NULL, nds.menu.drastic.main, &rt);
-#endif
                 SDL_FreeSurface(t);
             }
 
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
             if (sm) {
                 SDL_FreeSurface(sm);
             }
@@ -774,7 +957,7 @@ static char* find_menu_string_tail(char *p)
     int cc = 0;
 
     for (cc=strlen(p) - 1; cc>=0; cc--) {
-        if (p[cc] == ' ') {
+        if (p[cc] == ' ' && p[cc-1] == ' ') {
             return &p[cc + 1];
         }
     }
@@ -796,7 +979,7 @@ static int draw_drastic_menu_option(void)
     CUST_MENU_SUB *p = NULL;
     char buf[MAX_PATH] = {0};
 
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
     div = 2;
 #endif
 
@@ -868,7 +1051,7 @@ static int draw_drastic_menu_controller(void)
     CUST_MENU_SUB *p = NULL;
     char buf[MAX_PATH] = {0};
 
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
     div = 2;
 #endif
 
@@ -972,13 +1155,13 @@ static int draw_drastic_menu_controller2(void)
     CUST_MENU_SUB *p = NULL;
     char buf[MAX_PATH] = {0};
 
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
     div = 2;
 #endif
 
     cursor = 0;
     for (cc=0; cc<drastic_menu.cnt;) {
-        if ((drastic_menu.item[cc].y >= 240) && (drastic_menu.item[cc].y <= NDS_Hx2)) {
+        if ((drastic_menu.item[cc].y >= 240) && (drastic_menu.item[cc].y <= 392 /*NDS_Hx2*/)) {
             if ((drastic_menu.item[cc + 1].bg > 0) || (drastic_menu.item[cc + 2].bg > 0)) {
                 break;
             }
@@ -1019,7 +1202,7 @@ static int draw_drastic_menu_controller2(void)
         if ((cnt >= s0) && (cnt < s1)) {
             y = (25 / div) + ((cnt - s0) * w);
 
-            if ((p->y >= 240) && (p->y <= NDS_Hx2)) {
+            if ((p->y >= 240) && (p->y <= 392/*NDS_Hx2*/)) {
                 if (drastic_menu.item[cc + 1].bg || drastic_menu.item[cc + 2].bg) {
                     int sum = drastic_menu.item[cc + 1].bg + drastic_menu.item[cc + 2].bg;
                     uint32_t c = sum > 500 ? 0xff0000 : nds.menu.c2;
@@ -1031,7 +1214,7 @@ static int draw_drastic_menu_controller2(void)
                     SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format, (c >> 16) & 0xff, (c >> 8) & 0xff, c & 0xff));
                 }
                 draw_info(nds.menu.drastic.main, p->msg, 20 / div, y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
-                if ((p->y >= 240) && (p->y <= NDS_Hx2)) {
+                if ((p->y >= 240) && (p->y <= 392/*NDS_Hx2*/)) {
                     if (nds.enable_752x560) {
                         draw_info(nds.menu.drastic.main, to_lang(drastic_menu.item[cc + 1].msg), 320 / div, y, drastic_menu.item[cc + 1].bg ? nds.menu.c0 : nds.menu.c1, 0);
                         draw_info(nds.menu.drastic.main, to_lang(drastic_menu.item[cc + 2].msg), 550 / div, y, drastic_menu.item[cc + 2].bg ? nds.menu.c0 : nds.menu.c1, 0);
@@ -1056,7 +1239,7 @@ static int draw_drastic_menu_controller2(void)
         }
 
         cnt+= 1;
-        if ((p->y >= 240) && (p->y <= NDS_Hx2)) {
+        if ((p->y >= 240) && (p->y <= 392/*NDS_Hx2*/)) {
             cc+= 2;
         }
     }
@@ -1077,7 +1260,7 @@ static int draw_drastic_menu_firmware(void)
     char buf[MAX_PATH] = {0};
     char name[MAX_PATH] = {0};
 
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
     div = 2;
 #endif
 
@@ -1155,7 +1338,7 @@ static int draw_drastic_menu_cheat(void)
     CUST_MENU_SUB *p = NULL;
     char buf[MAX_PATH] = {0};
 
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
     div = 2;
 #endif
     for (cc=0; cc<drastic_menu.cnt; cc++) {
@@ -1259,7 +1442,7 @@ static int draw_drastic_menu_rom(void)
     int s0 = 0, s1 = 0;
     CUST_MENU_SUB *p = NULL;
 
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
     div = 2;
 #endif
 
@@ -1388,10 +1571,14 @@ int process_drastic_menu(void)
         memset(&drastic_menu, 0, sizeof(drastic_menu));
         return 0;
     }
-    GFX_Copy(nds.menu.drastic.main->pixels, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->pitch, 0, E_MI_GFX_ROTATE_180);
+#if defined(A30) || defined(RG35XXH_GL)
+    nds.update_menu = 1;
+#else
+    GFX_Copy(-1, nds.menu.drastic.main->pixels, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->pitch, 0, E_MI_GFX_ROTATE_180);
     GFX_Flip();
-    GFX_Copy(nds.menu.drastic.main->pixels, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->pitch, 0, E_MI_GFX_ROTATE_180);
+    GFX_Copy(-1, nds.menu.drastic.main->pixels, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->pitch, 0, E_MI_GFX_ROTATE_180);
     GFX_Flip();
+#endif
     memset(&drastic_menu, 0, sizeof(drastic_menu));
     return 0;
 }
@@ -1400,7 +1587,7 @@ static int process_screen(void)
 {
     static int need_loadstate = 15;
     static int show_info_cnt = 0;
-    static int cur_fb_w = 0;
+    //static int cur_fb_w = 0;
     static int cur_volume = 0;
     static int cur_dis_mode = 0;
     static int cur_touchpad = 0;
@@ -1409,17 +1596,28 @@ static int process_screen(void)
     static int pre_dis_mode = NDS_DIS_MODE_VH_S0;
     static int pre_hres_mode = NDS_DIS_MODE_HRES0;
     static char show_info_buf[MAX_PATH << 1] = {0};
-
+    int swap_screens;
+	
     int idx = 0;
     int screen_cnt = 0;
     char buf[MAX_PATH] = {0};
 
-#if defined(MMIYOO) || defined(PANDORA) || defined(QX1000)
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
+    int cur_sel = gfx.lcd.cur_sel ^ 1;
+#endif
+
+#if defined(MMIYOO) || defined(PANDORA) || defined(QX1000) || defined(A30) || defined(RG35XXH)
     screen_cnt = 2;
 #else
     screen_cnt = 1;
 #endif
 
+#ifdef RG35XXH
+	swap_screens = (uint32_t *)(*((uint32_t *)VAR_SDL_SWAP_SCREENS));
+#endif
+
+ //   printf(PREFIX"process_screen++\n");
+
     if (nds.auto_state > 0) {
         if (need_loadstate > 0) {
             need_loadstate-= 1;
@@ -1442,26 +1640,29 @@ static int process_screen(void)
 #endif
     }
 
-    if ((cur_fb_w != FB_W) ||
+    if (//(cur_fb_w != FB_W) ||
         (nds.shot.take) ||
-        (cur_touchpad != nds.pen.pos) ||
+        /*(cur_touchpad != nds.pen.pos) ||*/
         (cur_dis_mode != nds.dis_mode) ||
         (cur_theme_sel != nds.theme.sel) ||
         (cur_pixel_filter != pixel_filter) ||
         (cur_volume != nds.volume))
     {
+/*
         if (cur_fb_w != FB_W) {
             show_info_cnt = 150;
             sprintf(show_info_buf, " %d x %d ", FB_W, FB_H);
         }
-        else if (cur_volume != nds.volume) {
+        else */if (cur_volume != nds.volume) {
             show_info_cnt = 50;
             sprintf(show_info_buf, " %s %d ", to_lang("Volume"), nds.volume);
         }
+/*
         else if (cur_touchpad != nds.pen.pos) {
             show_info_cnt = 50;
             sprintf(show_info_buf, " %s %d ", to_lang("Touchpad"), nds.pen.pos);
         }
+*/
         else if (cur_theme_sel != nds.theme.sel) {
             show_info_cnt = 50;
             if ((nds.theme.max > 0) && (nds.theme.sel < nds.theme.max)) {
@@ -1487,11 +1688,11 @@ static int process_screen(void)
             sprintf(show_info_buf, " %s ", to_lang("Take Screenshot"));
         }
 
-        cur_fb_w = FB_W;
+       // cur_fb_w = FB_W;
         cur_theme_sel = nds.theme.sel;
         cur_volume = nds.volume;
         cur_dis_mode = nds.dis_mode;
-        cur_touchpad = nds.pen.pos;
+        //cur_touchpad = nds.pen.pos;
         cur_pixel_filter = pixel_filter;
         need_reload_bg = RELOAD_BG_COUNT;
     }
@@ -1528,8 +1729,11 @@ static int process_screen(void)
     }
 
     nds.screen.bpp = *((uint32_t *)VAR_SDL_SCREEN_BPP);
+//printf(PREFIX"process_screen+bpp=%d\n", nds.screen.bpp);
     nds.screen.init = *((uint32_t *)VAR_SDL_SCREEN_NEED_INIT);
 
+//printf(PREFIX"process_screen+init=%d\n", nds.screen.init);
+
     if (need_reload_bg) {
         reload_bg();
         need_reload_bg -= 1;
@@ -1548,12 +1752,18 @@ static int process_screen(void)
             *((uint8_t *)VAR_SDL_SCREEN1_HRES_MODE):
             *((uint8_t *)VAR_SDL_SCREEN0_HRES_MODE);
 
-#ifndef MMIYOO
+#if 0 // defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
+        nds.screen.pixels[idx] = gfx.lcd.virAddr[cur_sel][idx];
+#else
         nds.screen.pixels[idx] = (idx == 0) ?
-            (uint32_t *)(*((uint32_t *)VAR_SDL_SCREEN0_PIXELS)):
-            (uint32_t *)(*((uint32_t *)VAR_SDL_SCREEN1_PIXELS));
+            (uint64_t *)(*((uint64_t *)VAR_SDL_SCREEN0_PIXELS)):
+            (uint64_t *)(*((uint64_t *)VAR_SDL_SCREEN1_PIXELS));
 #endif
 
+        screen0 = (idx == 0);
+        screen1 = (idx != 0);
+        show_pen = nds.pen.pos ? screen1 : screen0;
+            
         if (nds.screen.hres_mode[idx]) {
             srt.w = NDS_Wx2;
             srt.h = NDS_Hx2;
@@ -1574,9 +1784,7 @@ static int process_screen(void)
             nds.screen.pitch[idx] = nds.screen.bpp * srt.w;
 
             drt.y = idx * 120;
-            screen0 = (idx == 0);
-            screen1 = (idx != 0);
-            show_pen = nds.pen.pos ? screen1 : screen0;
+
             if (nds.hres_mode == 1) {
                 nds.hres_mode = 0;
                 pre_hres_mode = nds.dis_mode;
@@ -1590,8 +1798,140 @@ static int process_screen(void)
 #if defined(QX1000)
 #elif defined(TRIMUI)
 #elif defined(PANDORA)
-#elif defined(FUNKEYS)
-#elif defined(MMIYOO)
+#elif defined(RG35XXH) && !defined(RG35XXH_GL) //trngaje
+
+       switch (nds.dis_mode) {
+        case NDS_DIS_MODE_VH_T0:
+            if (screen0) {
+                drt.x = 0;
+                drt.y = 0;
+                drt.w = FB_W;
+                drt.h = FB_H;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_VH_T1:
+            if (screen0) {
+                drt.x = 0;
+                drt.y = 0;
+                drt.w = FB_W;
+                drt.h = FB_H;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_S0:
+            if (screen0) {
+                drt.w = NDS_W * 2;
+                drt.h = NDS_H * 2;
+                drt.x = (FB_W - drt.w) / 2;
+                drt.y = (FB_H - drt.h) / 2;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_S1:
+            if (screen0) {
+                drt.x = 0;
+                drt.y = 0;
+                drt.w = FB_W;
+                drt.h = FB_H;
+            }
+            else {
+                //show_pen = 0;
+                need_update = 0;
+            }
+            break;
+        case NDS_DIS_MODE_V0:
+            drt.w = NDS_W;
+            drt.h = NDS_H;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = screen0? 48 : 48 + drt.h;
+
+            break;
+        case NDS_DIS_MODE_V1:
+			drt.w = 320;
+			drt.h = 240;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = screen0 ? 0 : drt.h;
+            break;
+        case NDS_DIS_MODE_H0:
+            drt.w = NDS_W;
+            drt.h = NDS_H;
+            drt.x = screen0 ? 64 : 64 + drt.w;
+            drt.y = (FB_H - drt.h) / 2;
+            break;
+        case NDS_DIS_MODE_H1:
+			drt.w = 320;
+			drt.h = 240;
+			drt.x = screen0 ? 0 : drt.w;
+            drt.y = (FB_H - drt.h) / 2;
+            break;
+        case NDS_DIS_MODE_VH_S0:
+            drt.x = screen1 ? FB_W -160 : 0;
+            drt.y = screen1 ? FB_H-120 : 0;
+            drt.w = screen1 ? 160:(FB_W - 160);
+            drt.h = screen1 ? 120:(FB_H - 120) ;
+            break;
+        case NDS_DIS_MODE_VH_S1:
+            drt.x = screen0 ? 0:FB_W - NDS_W ;
+            drt.y = screen0 ? 0:FB_H - NDS_H ;
+            drt.w = screen0 ? (FB_W - NDS_W) : NDS_W;
+            drt.h = screen0 ? (FB_H - NDS_H) : NDS_H;
+            break;
+       case NDS_DIS_MODE_VH_S2:
+            drt.w = screen0 ? (FB_W - 160) : 160;
+            drt.h = screen0 ? (FB_H - 120):120;
+            drt.x = screen0 ? ((FB_W - drt.w) / 2) : ((FB_W - drt.w) / 2);
+            drt.y = screen0 ? 0:FB_H-120;
+            break;
+        case NDS_DIS_MODE_VH_C0:
+            drt.w = screen0 ?  (FB_W - NDS_W):NDS_W;
+            drt.h = screen0 ?  (FB_H - NDS_H):NDS_H;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = screen0 ?  0:FB_H - NDS_H;
+            break;
+        case NDS_DIS_MODE_VH_C1:
+            drt.w = screen0 ? (FB_W - NDS_W): NDS_W;
+            drt.h = screen0? (FB_H - NDS_H):NDS_H ;
+            drt.x = screen0 ? 0 : FB_W - NDS_W;
+            drt.y = screen0? ((FB_H - drt.h) / 2) : ((FB_H - drt.h) / 2);
+            break;
+        case NDS_DIS_MODE_HH0:
+			drt.x = screen0 ? 320 : 0;
+			drt.y = 26;
+			drt.w = 427;
+			drt.h = 320;
+            rotate = E_MI_GFX_ROTATE_270 ; /* not used  */
+            break;
+        case NDS_DIS_MODE_HH1:
+			drt.x = screen0 ? 0:320 ;
+			drt.y = 26;
+			drt.w = 427;
+			drt.h = 320;
+            rotate = E_MI_GFX_ROTATE_90 ;/* not used  */
+            break;
+        case NDS_DIS_MODE_HRES0:
+            drt.w = NDS_Wx2;
+            drt.h = NDS_Hx2;
+            drt.x = (FB_W - drt.w) / 2;
+            drt.y = (FB_H - drt.h) / 2;
+            break;
+        case NDS_DIS_MODE_HRES1:
+            drt.x = 0;
+            drt.y = 0;
+            drt.w = FB_W;
+            drt.h = FB_H;
+            break;
+        }
+#elif defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
         switch (nds.dis_mode) {
         case NDS_DIS_MODE_VH_T0:
             if (screen1) {
@@ -1599,11 +1939,11 @@ static int process_screen(void)
                 drt.y = 0;
                 drt.w = FB_W;
                 drt.h = FB_H;
-                show_pen = 1;
-                nds.pen.pos = 1;
+                //show_pen = 1;
+                //nds.pen.pos = 1;
             }
             else {
-                show_pen = 0;
+                //show_pen = 0;
                 need_update = 0;
             }
             break;
@@ -1613,11 +1953,11 @@ static int process_screen(void)
                 drt.y = 0;
                 drt.w = FB_W;
                 drt.h = FB_H;
-                show_pen = 1;
-                nds.pen.pos = 1;
+                //show_pen = 1;
+                //nds.pen.pos = 1;
             }
             else {
-                show_pen = 0;
+                //show_pen = 0;
                 need_update = 0;
             }
             break;
@@ -1627,11 +1967,11 @@ static int process_screen(void)
                 drt.h = NDS_H * 2;
                 drt.x = (FB_W - drt.w) / 2;
                 drt.y = (FB_H - drt.h) / 2;
-                show_pen = 1;
-                nds.pen.pos = 1;
+                //show_pen = 1;
+                //nds.pen.pos = 1;
             }
             else {
-                show_pen = 0;
+                //show_pen = 0;
                 need_update = 0;
             }
             break;
@@ -1641,11 +1981,11 @@ static int process_screen(void)
                 drt.y = 0;
                 drt.w = FB_W;
                 drt.h = FB_H;
-                show_pen = 1;
-                nds.pen.pos = 1;
+                //show_pen = 1;
+                //nds.pen.pos = 1;
             }
             else {
-                show_pen = 0;
+                //show_pen = 0;
                 need_update = 0;
             }
             break;
@@ -1760,32 +2100,204 @@ static int process_screen(void)
         return 0;
 #endif
 
-        if ((evt.mode == MMIYOO_MOUSE_MODE) && show_pen) {
+         nds.pen.pos = swap_screens ^ 1; // trngaje;
+
+#if defined(A30) || defined(RG35XXH_GL)
+        if (rotate == E_MI_GFX_ROTATE_180) {
+            drt.y = (DEF_FB_H - drt.y) - drt.h;
+            drt.x = (DEF_FB_W - drt.x) - drt.w;
+        }
+    #ifdef RG35XXH_GL
+        else if (rotate == E_MI_GFX_ROTATE_270) {
+    #else        
+        else if (rotate == E_MI_GFX_ROTATE_90) {
+    #endif
+            drt.x = (drt.x == 0) ? 320 : 0;
+        }
+#if defined(RG35XXH)
+        if ((evt.mode == MMIYOO_MOUSE_MODE || evt.pen_display_cnt > 0) && show_pen) {
+            if (evt.pen_display_cnt > 0) {
+                evt.pen_display_cnt--;
+            }  
+#else
+        if (show_pen && ((evt.mode == MMIYOO_MOUSE_MODE) || (nds.joy.show_cnt && (nds.joy.mode == MYJOY_MODE_MOUSE)))) {
+#endif
+#elif defined(RG35XXH)
+        if ((evt.mode == MMIYOO_MOUSE_MODE || evt.pen_display_cnt > 0) && show_pen) {
+            if (evt.pen_display_cnt > 0) {
+                evt.pen_display_cnt--;
+            }           
+#else
+        if (show_pen && (evt.mode == MMIYOO_MOUSE_MODE)) {
+#endif
             draw_pen(nds.screen.pixels[idx], srt.w, nds.screen.pitch[idx]);
+
+#ifdef A30
+            if (nds.joy.show_cnt && (nds.joy.mode == MYJOY_MODE_MOUSE)) {
+                nds.joy.show_cnt -= 1;
+            }
+#endif
+        }
+
+#if defined(A30) || defined(RG35XXH_GL)
+        if ((idx == 0) && (nds.alpha.border > 0) && ((nds.dis_mode == NDS_DIS_MODE_VH_T0) || (nds.dis_mode == NDS_DIS_MODE_VH_T1))) {
+            int c0 = 0;
+            uint32_t *p0 = NULL;
+            uint32_t *p1 = NULL;
+            uint32_t col[] = { 0, 0xffffff, 0xff0000, 0x00ff00, 0x0000ff, 0x000000, 0xffff00, 0x00ffff };
+
+            p0 = (uint32_t *)nds.screen.pixels[idx];
+            p1 = (uint32_t *)nds.screen.pixels[idx] + ((srt.h - 1) * srt.w);
+            for (c0 = 0; c0 < srt.w; c0++) {
+                *p0++ = col[nds.alpha.border];
+                *p1++ = col[nds.alpha.border];
+            }
+
+            p0 = (uint32_t *)nds.screen.pixels[idx];
+            p1 = (uint32_t *)nds.screen.pixels[idx] + (srt.w - 1);
+            for (c0 = 0; c0 < srt.h; c0++) {
+                *p0 = col[nds.alpha.border];
+                *p1 = col[nds.alpha.border];
+                p0 += srt.w;
+                p1 += srt.w;
+            }
+        }
+        glBindTexture(GL_TEXTURE_2D, vid.texID[idx]);
+        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+        if (pixel_filter) {
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
         }
+        else {
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        }
+        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, srt.w, srt.h, 0, GL_RGBA, GL_UNSIGNED_BYTE, nds.screen.pixels[idx]);
+#endif
 
         if (need_update) {
 #ifdef MMIYOO
             MI_SYS_FlushInvCache(nds.screen.pixels[idx], nds.screen.pitch[idx] * srt.h);
 #endif
 
-            GFX_Copy(nds.screen.pixels[idx], srt, drt, nds.screen.pitch[idx], 0, rotate);
+#if defined(A30) || defined(RG35XXH_GL)
+            GFX_Copy(idx, nds.screen.pixels[idx], srt, drt, nds.screen.pitch[idx], 0, rotate);
+#else
+            GFX_Copy(-1, nds.screen.pixels[idx], srt, drt, nds.screen.pitch[idx], 0, rotate);
+#endif
 
-#ifdef MMIYOO
+#if defined(RG35XXH) && ! defined(RG35XXH_GL)
+            switch (nds.dis_mode) {
+            case NDS_DIS_MODE_VH_T0:
+                drt.y = 0;
+                drt.w = 160;
+                drt.h = 120;
+                drt.x = FB_W - drt.w;	
+		switch (nds.alpha.pos % 4) {
+		case 2:
+		    drt.x = 0;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 3:
+		    drt.x = FB_W - drt.w;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 0:
+		    drt.x = FB_W - drt.w;
+		    drt.y = 0;
+		    break;
+		case 1:
+		    drt.x = 0;
+		    drt.y = 0;
+		    break;
+		}			
+                GFX_Copy(-1, nds.screen.pixels[1], srt, drt, nds.screen.pitch[1], 1, rotate);
+                break;
+            case NDS_DIS_MODE_VH_T1:
+                drt.y = 0;
+                drt.w = NDS_W;
+                drt.h = NDS_H;
+                drt.x = FB_W - drt.w;
+		switch (nds.alpha.pos % 4) {
+		case 2:
+		    drt.x = 0;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 3:
+		    drt.x = FB_W - drt.w;
+		    drt.y = FB_H - drt.h;
+		    break;
+		case 0:
+		    drt.x = FB_W - drt.w;
+		    drt.y = 0;
+		    break;
+		case 1:
+		    drt.x = 0;
+		    drt.y = 0;
+		    break;
+		}			
+                GFX_Copy(-1, nds.screen.pixels[1], srt, drt, nds.screen.pitch[1], 1, rotate);
+                break;
+            }
+#elif defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
             switch (nds.dis_mode) {
             case NDS_DIS_MODE_VH_T0:
                 drt.x = 0;
                 drt.y = 0;
                 drt.w = 160;
                 drt.h = 120;
-                GFX_Copy(nds.screen.pixels[0], srt, drt, nds.screen.pitch[0], 1, rotate);
+#if defined(A30) || defined(RG35XXH_GL)
+                switch (nds.alpha.pos) {
+                case 0:
+                    drt.x = DEF_FB_W - drt.w;
+                    drt.y = 0;
+                    break;
+                case 1:
+                    drt.x = 0;
+                    drt.y = 0;
+                    break;
+                case 2:
+                    drt.x = 0;
+                    drt.y = DEF_FB_H - drt.h;
+                    break;
+                case 3:
+                    drt.x = DEF_FB_W - drt.w;
+                    drt.y = DEF_FB_H - drt.h;
+                    break;
+                }
+                GFX_Copy(TEX_SCR0, nds.screen.pixels[0], srt, drt, nds.screen.pitch[0], 1, rotate);
+#else
+                GFX_Copy(-1, nds.screen.pixels[0], srt, drt, nds.screen.pitch[0], 1, rotate);
+#endif
                 break;
             case NDS_DIS_MODE_VH_T1:
                 drt.x = 0;
                 drt.y = 0;
                 drt.w = NDS_W;
                 drt.h = NDS_H;
-                GFX_Copy(nds.screen.pixels[0], srt, drt, nds.screen.pitch[0], 1, rotate);
+#if defined(A30) || defined(RG35XXH)
+                switch (nds.alpha.pos) {
+                case 0:
+                    drt.x = DEF_FB_W - drt.w;
+                    drt.y = 0;
+                    break;
+                case 1:
+                    drt.x = 0;
+                    drt.y = 0;
+                    break;
+                case 2:
+                    drt.x = 0;
+                    drt.y = DEF_FB_H - drt.h;
+                    break;
+                case 3:
+                    drt.x = DEF_FB_W - drt.w;
+                    drt.y = DEF_FB_H - drt.h;
+                    break;
+                }
+                GFX_Copy(TEX_SCR0, nds.screen.pixels[0], srt, drt, nds.screen.pitch[0], 1, rotate);
+#else 
+                GFX_Copy(-1, nds.screen.pixels[0], srt, drt, nds.screen.pitch[0], 1, rotate);
+#endif
                 break;
             }
 #endif
@@ -1807,7 +2319,7 @@ static int process_screen(void)
         rt.y = 0;
         rt.w = fps_info->w;
         rt.h = fps_info->h;
-        GFX_Copy(fps_info->pixels, fps_info->clip_rect, rt, fps_info->pitch, 0, E_MI_GFX_ROTATE_180);
+        GFX_Copy(-1, fps_info->pixels, fps_info->clip_rect, rt, fps_info->pitch, 0, E_MI_GFX_ROTATE_180);
     }
 
 #ifdef TRIMUI
@@ -1822,7 +2334,9 @@ static int process_screen(void)
         nds_set_screen_menu_off _func = (nds_set_screen_menu_off)FUN_SET_SCREEN_MENU_OFF;
         _func();
     }
+//printf(PREFIX"process_screen+step5\n");
     GFX_Flip();
+//printf(PREFIX"process_screen--\n");
     return 0;
 }
 
@@ -1830,56 +2344,167 @@ void sdl_blit_screen_menu(uint16_t *src, uint32_t x, uint32_t y, uint32_t w, uin
 {
 }
 
-void sdl_update_screen(void)
+void sdl_update_screen(ulong param_1)
+{
+
+}
+
+// [trngaje] save_state_num=0x47b9c0
+void sdl_draw_menu_bg(unsigned long *param_1) // draw_menu_bg(&local_578); 이라 어드레스 접근이 어려움
 {
-    static int prepare_time = 30;
+    void *__s;
+    void *__s_00;
+    char *pcVar1;
+    unsigned int uVar2;
+    long local_10;
 
-    if (prepare_time) {
-        process_screen();
-        prepare_time -= 1;
+    nds_savestate_index_timestamp savestate_index_timestamp;
+    
+    //printf("[trngaje] sdl_draw_menu_bg:param_1=%p\n", param_1 - base_addr_rx);
+    //printf("[trngaje] save_state_num=%p\n", param_1[1] + 0x458 - base_addr_rx);
+    printf("[trngaje] %d\n", *(unsigned int *)(param_1[1] + 0x458));
+    g_save_slot = *(unsigned int *)(param_1[1] + 0x458);
+
+
+    savestate_index_timestamp = (nds_savestate_index_timestamp)FUN_SAVESTATE_INDEX_TIMESTAMP;
+
+  //clear_screen_menu(0,&__stack_chk_guard,0);
+  if (param_1[7] != 0) {
+    uVar2 = 200;
+    if (*(int *)(param_1 + 8) != 0) {
+      uVar2 = 0x24;
+    }
+    //blit_screen_menu(param_1[7],uVar2,0x28,400,0x96);
+  }
+  uVar2 = 0x160;
+  if (*(int *)(param_1 + 8) == 0) {
+    uVar2 = 0x204;
+  }
+  //set_font_narrow_small();
+  sdl_print_string("Version r2.5.2.0",0xffff,0,uVar2,0xc9);
+  //set_font_wide();
+  if (*(int *)(param_1 + 8) != 0) {
+    if ((*(long *)(param_1[2] + 0x28) == 0) && (*(int *)(param_1[2] + 0x18) == 5)) {
+      local_10 = savestate_index_timestamp(*param_1,*(unsigned int *)(param_1[1] + 0x458)); // 이 함수 리턴값 없음, 32bit drastic 확인할 것
+      //set_font_narrow_small();
+      if (local_10 == 0) {
+        sdl_print_string("(No savestate)",0xffff,0,0x220,0xe9);
+        //set_font_wide();
+      }
+      else {
+        //__s = malloc(0x18000);
+        //__s_00 = malloc(0x18000);
+        pcVar1 = ctime(&local_10);
+       // memset(__s,0,0x18000);
+        //memset(__s_00,0,0x18000);
+        //load_state_index(*param_1,*(undefined4 *)(param_1[1] + 0x458),__s,__s_00,1);
+        //blit_screen_menu(__s,0x1d8,0x30,0x100,0xc0);
+        //blit_screen_menu(__s_00,0x1d8,0xf0,0x100,0xc0);
+        sdl_print_string(pcVar1,0xffff,0,0x1dc,0x19c);
+        //free(__s);
+        //free(__s_00);
+        //set_font_wide();
+      }
     }
+    else {
+      //blit_screen_menu(param_1[5],0x1d8,0x30,0x100,0xc0);
+      //blit_screen_menu(param_1[6],0x1d8,0xf0,0x100,0xc0);
+    }
+  }
+      
+}
+
+void sdl_quit(long param_1)
+{
+    nds_gamecard_close gamecard_close;
+    nds_audio_exit audio_exit;
+    nds_input_log_close input_log_close;
+    nds_uninitialize_memory uninitialize_memory;
+    nds_platform_quit platform_quit;
+    nds_save_directory_config_file save_directory_config_file;
+    
+    gamecard_close = (nds_gamecard_close)FUN_GAMECARD_CLOSE;
+    audio_exit = (nds_audio_exit)FUN_AUDIO_EXIT;
+    input_log_close = (nds_input_log_close)FUN_INPUT_LOG_CLOSE;
+    uninitialize_memory = (nds_uninitialize_memory)FUN_UNINITIALIZE_MEMORY;
+    platform_quit = (nds_platform_quit)FUN_PLATFORM_QUIT;
+    save_directory_config_file = (nds_save_directory_config_file)FUN_SAVE_DIRECTORY_CONFIG_FILE;
+    
+    printf("[trngaje]sdl_quit: param_1=0x%x\n", param_1);
+    //drastic_VideoQuit();
+  /*  
+    if (nds_system[param_1 + 0x37339a8] == '\0') {
+      cpu_print_profiler_results();
+    }
+    __printf_chk(((double)(unkuint9)(mini_hash_accesses - mini_hash_misses) * 100.0) /
+               (double)(unkuint9)mini_hash_accesses,1,
+               "%lu mini hash hits out of %lu accesses (%lf%%)\n",
+               mini_hash_accesses - mini_hash_misses);
+    __printf_chk(1,"%lu hash accesses:\n",hash_accesses);
+    __printf_chk(((double)(unkuint9)hash_hit_lengths * 100.0) / (double)(unkuint9)hash_accesses,1,
+               " %lf%% hit in one hop\n");
+    __printf_chk(((double)(unkuint9)DAT_00164018 * 100.0) / (double)(unkuint9)hash_accesses,1,
+               " %lf%% hit in two hops\n");
+    __printf_chk(((double)(unkuint9)DAT_00164020 * 100.0) / (double)(unkuint9)hash_accesses,1,
+               " %lf%% hit in three hops\n");
+    __printf_chk(((double)(unkuint9)DAT_00164028 * 100.0) / (double)(unkuint9)hash_accesses,1,
+               " %lf%% hit in four or more hops\n");
+               */
+    save_directory_config_file(param_1,"drastic.cf2");
+    if (*(char *)(param_1 + 0x8ab38) != '\0') {
+        gamecard_close(param_1 + 800);
+    }
+    audio_exit(param_1 + 0x1586000);
+    input_log_close(param_1 + 0x5528);
+    uninitialize_memory(param_1 + 0x35d3930);
+    platform_quit();
+    //fflush(_stdout);
+                    /* WARNING: Subroutine does not return */
+    exit(0);
+}
+
+// 여긴 계속 호출되고 있음
+void sdl_update_screens(void)
+{
+    // acquire a lock
+    pthread_mutex_lock(&lock);
+    
+    nds.update_screen = 1;
+    nds.menu.drastic.enable = 0;
+    pthread_cond_signal(&request_update_screen_cond);
+    
+    pthread_cond_wait(&response_update_screen_cond, &lock);
+    
+    // release lock 
+    pthread_mutex_unlock(&lock);     
+//    static int prepare_time = 30;
+    
+    
+/*
+    static int nrun=0;
+    
+    nrun++;
+    printf("[trngaje] sdl_update_screen: nrun=%d\n", nrun);
+*/    
+//    if (prepare_time) {
+ //       process_screen(); // 여기서 직접 호출 하면 화면 표시가 되지 않음. nds.update_screen = 1;로 thread에서 호출 해야 화면이 표시됨 (!이상한 점)
+//        prepare_time -= 1;
+//    }
+/*
     else if (nds.update_screen == 0) {
-#ifdef MMIYOO
-        int cc = 0;
-        int cnt = 2;
-        uint8_t hres = *((uint8_t *)VAR_SDL_SCREEN0_HRES_MODE);
-        uint32_t bpp = *((uint32_t *)VAR_SDL_SCREEN_BPP);
-        uint32_t w = hres ? NDS_Wx2 : NDS_W;
-        uint32_t h = hres ? NDS_Hx2 : NDS_H;
-        uint32_t pitch = (hres * bpp * 0x100) + (bpp * 0x100);
-        uint32_t color = ((pitch / w) == 2 ? E_MI_GFX_FMT_RGB565 : E_MI_GFX_FMT_ARGB8888);
-
-        MI_U16 u16Fence = 0;
-        MI_GFX_Opt_t opt = {0};
-        MI_GFX_Rect_t srt = {0};
-        MI_GFX_Rect_t drt = {0};
-        MI_GFX_Surface_t ssurf = {0};
-        MI_GFX_Surface_t dsurf = {0};
-
-        opt.eSrcDfbBldOp = E_MI_GFX_DFB_BLD_ONE;
-
-        ssurf.u32Width = srt.u32Width = w;
-        ssurf.u32Height = srt.u32Height = h;
-        ssurf.u32Stride = pitch;
-        ssurf.eColorFmt = color;
-
-        dsurf.u32Width = drt.u32Width = w;
-        dsurf.u32Height = drt.u32Height = h;
-        dsurf.u32Stride = pitch;
-        dsurf.eColorFmt = color;
-
-        cnt = hres ? 1 : 2;
-        for (cc = 0; cc < cnt; cc++) {
-            ssurf.phyAddr = gfx.lcd.phyAddr[cc];
-            dsurf.phyAddr = gfx.dup.phyAddr[cc];
-
-            MI_SYS_FlushInvCache(gfx.lcd.virAddr[cc], pitch * h);
-            MI_GFX_BitBlit(&ssurf, &srt, &dsurf, &drt, &opt, &u16Fence);
-            MI_GFX_WaitAllDone(FALSE, u16Fence);
-        }
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
+        //gfx.lcd.cur_sel ^= 1;
+        //*((uint64_t *)VAR_SDL_SCREEN0_PIXELS) = (uint64_t)gfx.lcd.virAddr[gfx.lcd.cur_sel][0];
+        //*((uint64_t *)VAR_SDL_SCREEN1_PIXELS) = (uint64_t)gfx.lcd.virAddr[gfx.lcd.cur_sel][1];
+#if defined(A30) || defined(RG35XXH_GL)
+        //nds.menu.drastic.enable = 0;
+#endif
 #endif
         nds.update_screen = 1;
     }
+    */
+ //   nds.update_screen = 1;
+ //   nds.menu.drastic.enable = 0;
 }
 
 void sdl_print_string(char *p, uint32_t fg, uint32_t bg, uint32_t x, uint32_t y)
@@ -1940,7 +2565,7 @@ void sdl_print_string(char *p, uint32_t fg, uint32_t bg, uint32_t x, uint32_t y)
 
 void sdl_savestate_pre(void)
 {
-#ifndef UNITTEST
+#if 0 //ndef UNITTEST
     asm volatile (
         "mov r1, %0                 \n"
         "mov r2, #1                 \n"
@@ -1954,7 +2579,7 @@ void sdl_savestate_pre(void)
 
 void sdl_savestate_post(void)
 {
-#ifndef UNITTEST
+#if 0//ndef UNITTEST
     asm volatile (
         "mov r1, %0                 \n"
         "mov r2, #0                 \n"
@@ -1991,15 +2616,154 @@ static void strip_newline(char *p)
 
 static void *video_handler(void *threadid)
 {
+    int result;
+#if defined(A30) || defined(RG35XXH_GL)
+    EGLint egl_major = 0;
+    EGLint egl_minor = 0;
+    EGLint num_configs = 0;
+    EGLint config_attribs[] = {
+        EGL_SURFACE_TYPE,    EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_RED_SIZE,   8,  
+        EGL_GREEN_SIZE, 8,
+        EGL_BLUE_SIZE,  8,  
+        EGL_ALPHA_SIZE, 8,
+        EGL_NONE
+    };
+    EGLint window_attributes[] = { 
+        EGL_RENDER_BUFFER, EGL_BACK_BUFFER,
+        EGL_NONE
+    };
+    EGLint const context_attributes[] = {
+        EGL_CONTEXT_CLIENT_VERSION, 2,
+        EGL_NONE,
+    };
+  
+    vid.eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    eglInitialize(vid.eglDisplay, &egl_major, &egl_minor);
+    eglChooseConfig(vid.eglDisplay, config_attribs, &vid.eglConfig, 1, &num_configs);
+    vid.eglSurface = eglCreateWindowSurface(vid.eglDisplay, vid.eglConfig, 0, window_attributes);
+    vid.eglContext = eglCreateContext(vid.eglDisplay, vid.eglConfig, EGL_NO_CONTEXT, context_attributes);
+    eglMakeCurrent(vid.eglDisplay, vid.eglSurface, vid.eglSurface, vid.eglContext);
+  
+    vid.vShader = glCreateShader(GL_VERTEX_SHADER);
+
+#ifdef RG35XXH_GL	
+	if (nds.display.rotate == 90)
+		 glShaderSource(vid.vShader, 1, &vShaderDegree90Src, NULL);
+	else if (nds.display.rotate == 180)
+		 glShaderSource(vid.vShader, 1, &vShaderDegree180Src, NULL);
+	else if (nds.display.rotate == 270)
+		 glShaderSource(vid.vShader, 1, &vShaderDegree270Src, NULL);
+	else
+		glShaderSource(vid.vShader, 1, &vShaderSrc, NULL);
+#else
+	glShaderSource(vid.vShader, 1, &vShaderSrc, NULL);
+#endif
+
+    glCompileShader(vid.vShader);
+  
+    vid.fShader = glCreateShader(GL_FRAGMENT_SHADER);
+    glShaderSource(vid.fShader, 1, &fShaderSrc, NULL);
+    glCompileShader(vid.fShader);
+   
+    vid.pObject = glCreateProgram();
+    glAttachShader(vid.pObject, vid.vShader);
+    glAttachShader(vid.pObject, vid.fShader);
+    glLinkProgram(vid.pObject);
+    glUseProgram(vid.pObject);
+
+    eglSwapInterval(vid.eglDisplay, 1);
+    vid.posLoc = glGetAttribLocation(vid.pObject, "a_position");
+    vid.texLoc = glGetAttribLocation(vid.pObject, "a_texCoord");
+    vid.samLoc = glGetUniformLocation(vid.pObject, "s_texture");
+    vid.alphaLoc = glGetUniformLocation(vid.pObject, "s_alpha");
+
+    glGenTextures(TEX_MAX, vid.texID);
+
+#ifdef RG35XXH_GL
+	if (nds.display.rotate == 90 || nds.display.rotate == 270)
+		glViewport(0, 0, DEF_FB_H, DEF_FB_W);
+	else 
+		glViewport(0, 0, DEF_FB_W, DEF_FB_H);
+#else
+    glViewport(0, 0, DEF_FB_H, DEF_FB_W);
+#endif
+    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+    glClear(GL_COLOR_BUFFER_BIT);
+
+    glEnableVertexAttribArray(vid.posLoc);
+    glEnableVertexAttribArray(vid.texLoc);
+    glUniform1i(vid.samLoc, 0);
+    glUniform1f(vid.alphaLoc, 0.0);
+
+    //pixel_filter = 0;
+/*
+    gfx.lcd.virAddr[0][0] = malloc(SCREEN_DMA_SIZE);
+    gfx.lcd.virAddr[0][1] = malloc(SCREEN_DMA_SIZE);
+    gfx.lcd.virAddr[1][0] = malloc(SCREEN_DMA_SIZE);
+    gfx.lcd.virAddr[1][1] = malloc(SCREEN_DMA_SIZE);
+    printf(PREFIX"Ping-pong Buffer %p\n", gfx.lcd.virAddr[0][0]);
+    printf(PREFIX"Ping-pong Buffer %p\n", gfx.lcd.virAddr[0][1]);
+    printf(PREFIX"Ping-pong Buffer %p\n", gfx.lcd.virAddr[1][0]);
+    printf(PREFIX"Ping-pong Buffer %p\n", gfx.lcd.virAddr[1][1]);
+*/
+#endif
+
+    // acquire a lock
+    pthread_mutex_lock(&lock);
+
     while (is_running) {
+#if defined(A30) || defined(RG35XXH_GL)
+        result = pthread_cond_wait(&request_update_screen_cond, &lock);
+        //result = pthread_cond_timedwait(&request_update_screen_cond, &lock, &t); // 프로그램 종료시 loop를 빠져나갈 수 있도록 추가
+        if (result != ETIMEDOUT && result != EINTR && is_running != 0) {         
+        if (nds.menu.enable) {
+            if (nds.update_menu) {
+                nds.update_menu = 0;
+                GFX_Copy(-1, cvt->pixels, cvt->clip_rect, cvt->clip_rect, cvt->pitch, 0, E_MI_GFX_ROTATE_180);
+                GFX_Flip();
+            }
+        }
+        else if (nds.menu.drastic.enable) {
+            //printf("[trngaje] nds.menu.drastic.enable:true, nds.update_menu=%d\n", nds.update_menu);
+            if (nds.update_menu) {
+                nds.update_menu = 0;
+                GFX_Copy(-1, nds.menu.drastic.main->pixels, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->clip_rect, nds.menu.drastic.main->pitch, 0, 0);
+                GFX_Flip();
+            }
+        }
+        else if (nds.update_screen) {
+#else
         if (nds.update_screen) {
+#endif
+
             process_screen();
             nds.update_screen = 0;
         }
         else {
             usleep(0);
         }
+        pthread_cond_signal(&response_update_screen_cond);
+        }
     }
+
+    // release lock 
+    pthread_mutex_unlock(&lock); 
+
+#if defined(A30) || defined(RG35XXH_GL)
+    glDeleteTextures(TEX_MAX, vid.texID);
+    eglMakeCurrent(vid.eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglDestroyContext(vid.eglDisplay, vid.eglContext);
+    eglDestroySurface(vid.eglDisplay, vid.eglSurface);
+    eglTerminate(vid.eglDisplay);
+/*
+    free(gfx.lcd.virAddr[0][0]);
+    free(gfx.lcd.virAddr[0][1]);
+    free(gfx.lcd.virAddr[1][0]);
+    free(gfx.lcd.virAddr[1][1]);
+*/
+#endif
     pthread_exit(NULL);
 }
 
@@ -2094,13 +2858,24 @@ static void lang_enum(void)
 
 static int read_config(void)
 {
-#if defined(TRIMUI) || defined(FUNKEYS) || defined(PANDORA)
+#if defined(TRIMUI) || defined(PANDORA) || defined(A30)
     int fd = -1;
 #endif
 
     struct json_object *jval = NULL;
     struct json_object *jfile = NULL;
 
+#ifdef RG35XXH
+	const char mykey_name[NUM_OF_MYKEY][20]= {
+        "up", "down", "left", "right", "a", "b", "x", "y", "l1", "r1", 
+        "l2", "r2", "l3", "r3","select", "start", "menu", "qsave", "qload", "ff", 
+		"exit", "menu_onion"
+    };
+	
+	char full_mykey_name[100];
+	int i;
+#endif
+
     jfile = json_object_from_file(nds.cfg.path);
     if (jfile == NULL) {
         printf(PREFIX"Failed to read settings from json file (%s)\n", nds.cfg.path);
@@ -2111,12 +2886,12 @@ static int read_config(void)
     if (jval) {
         nds.pen.sel = json_object_get_int(jval);
     }
-
+/*
     json_object_object_get_ex(jfile, JSON_NDS_PEN_POS, &jval);
     if (jval) {
         nds.pen.pos = json_object_get_int(jval) == 0 ? 0 : 1;
     }
-
+*/
     json_object_object_get_ex(jfile, JSON_NDS_THEME_SEL, &jval);
     if (jval) {
         nds.theme.sel = json_object_get_int(jval);
@@ -2126,7 +2901,9 @@ static int read_config(void)
     if (jval) {
         nds.dis_mode = json_object_get_int(jval);
     }
-    
+
+    nds.dis_hres_mode = (nds.dis_mode == NDS_DIS_MODE_HRES1) ? NDS_DIS_MODE_HRES1 : NDS_DIS_MODE_HRES0;
+
     json_object_object_get_ex(jfile, JSON_NDS_ALT_MODE, &jval);
     if (jval) {
         nds.alt_mode = json_object_get_int(jval);
@@ -2168,6 +2945,16 @@ static int read_config(void)
         nds.mincpu = json_object_get_int(jval);
     }
 
+    json_object_object_get_ex(jfile, JSON_NDS_MAX_CORE, &jval);
+    if (jval) {
+        nds.maxcore = json_object_get_int(jval);
+    }
+
+    json_object_object_get_ex(jfile, JSON_NDS_MIN_CORE, &jval);
+    if (jval) {
+        nds.mincore = json_object_get_int(jval);
+    }
+
     json_object_object_get_ex(jfile, JSON_NDS_OVERLAY, &jval);
     if (jval) {
         nds.overlay.sel = json_object_get_int(jval);
@@ -2188,6 +2975,18 @@ static int read_config(void)
         nds.keys_rotate = json_object_get_int(jval) % 3;
     }
 
+#ifdef A30
+    json_object_object_get_ex(jfile, JSON_NDS_JOY_MODE, &jval);
+    if (jval) {
+        nds.joy.mode = json_object_get_int(jval);
+    }
+
+    json_object_object_get_ex(jfile, JSON_NDS_JOY_DZONE, &jval);
+    if (jval) {
+        nds.joy.dzone = json_object_get_int(jval);
+    }
+#endif
+
     nds.menu.c0 = 0xffffff;
     json_object_object_get_ex(jfile, JSON_NDS_MENU_C0, &jval);
     if (jval) {
@@ -2247,7 +3046,7 @@ static int read_config(void)
         nds.fast_forward = json_object_get_int(jval);
     }
 
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     json_object_object_get_ex(jfile, JSON_NDS_STATES, &jval);
     if (jval) {
         struct stat st = {0};
@@ -2263,12 +3062,12 @@ static int read_config(void)
         }
     }
 #endif
-
+/*
     if (nds.dis_mode > NDS_DIS_MODE_LAST) {
         nds.dis_mode = NDS_DIS_MODE_VH_S0;
         nds.alt_mode = NDS_DIS_MODE_S0;
     }
-
+*/
     nds.menu.sel = 0;
     json_object_object_get_ex(jfile, JSON_NDS_MENU_BG, &jval);
     if (jval) {
@@ -2277,21 +3076,62 @@ static int read_config(void)
             nds.menu.sel = 0;
         }
     }
+	
+#ifdef RG35XXH
+	json_object_object_get_ex(jfile, "input_dev", &jval);
+	if (jval) {
+        const char *dev = json_object_get_string(jval);
+
+        strcpy(nds.input.dev, dev);		
+	}
+
+	for (i=0; i< NUM_OF_MYKEY; i++) {
+		sprintf(full_mykey_name, "input_%s", mykey_name[i]);
+		json_object_object_get_ex(jfile, full_mykey_name, &jval);
+		if (jval)
+			nds.input.key[i] = json_object_get_int(jval);
+		else
+			nds.input.key[i] =  -1; // not defined
+	}
+	
+	json_object_object_get_ex(jfile, "display_rotate", &jval);
+	if (jval)
+		nds.display.rotate = json_object_get_int(jval);
+	else 
+		nds.display.rotate = 0;
+		
+    json_object_object_get_ex(jfile, "pixel_filter", &jval);
+    if (jval) {
+        pixel_filter = json_object_get_int(jval);
+    	if (pixel_filter >= 1)
+    	    pixel_filter = 1;
+    	else
+    	    pixel_filter = 0;
+    }
+    
+#endif	
+	
     reload_menu();
 
     reload_pen();
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     reload_overlay();
 #endif
     json_object_put(jfile);
 
-#if defined(TRIMUI) || defined(FUNKEYS) || defined(PANDORA)
+#if defined(TRIMUI) || defined(PANDORA) || defined(A30)
     fd = open("/dev/dsp", O_RDWR);
     if (fd > 0) {
         close(fd);
 #endif
+
+#ifndef RG35XXH
+#ifndef A30
         snd_nds_reload_config();
-#if defined(TRIMUI) || defined(FUNKEYS) || defined(PANDORA)
+#endif
+#endif
+
+#if defined(TRIMUI) || defined(PANDORA) || defined(A30)
     }
 #endif
 
@@ -2302,13 +3142,18 @@ static int read_config(void)
     disp_resize();
 #endif
 
-#ifdef FUNKEYS
-    nds.dis_mode = NDS_DIS_MODE_S0;
-#endif
-
 #ifdef QX1000
     nds.dis_mode = NDS_DIS_MODE_H0;
 #endif
+
+#ifdef A30
+    nds.joy.max_x = 200;
+    nds.joy.zero_x = 135;
+    nds.joy.min_x = 75;
+    nds.joy.max_y = 200;
+    nds.joy.zero_y = 135;
+    nds.joy.min_y = 75;
+#endif
     return 0;
 }
 
@@ -2327,12 +3172,12 @@ static int write_config(void)
         nds.dis_mode = pre_dismode;
     }
 #endif
-
+/*
     if (nds.dis_mode > NDS_DIS_MODE_LAST) {
         nds.dis_mode = NDS_DIS_MODE_VH_S0;
         nds.alt_mode = NDS_DIS_MODE_S0;
     }
-
+*/
     json_object_object_add(jfile, JSON_NDS_PEN_SEL, json_object_new_int(nds.pen.sel));
     json_object_object_add(jfile, JSON_NDS_THEME_SEL, json_object_new_int(nds.theme.sel));
     json_object_object_add(jfile, JSON_NDS_DIS_MODE, json_object_new_int(nds.dis_mode));
@@ -2352,6 +3197,15 @@ static int write_config(void)
     json_object_object_add(jfile, JSON_NDS_MENU_CURSOR, json_object_new_int(nds.menu.show_cursor));
     json_object_object_add(jfile, JSON_NDS_FAST_FORWARD, json_object_new_int(nds.fast_forward));
 
+#ifdef RG35XXH
+    json_object_object_add(jfile, JSON_NDS_PIXEL_FILTER, json_object_new_int(pixel_filter));
+#endif
+
+#ifdef A30
+    json_object_object_add(jfile, JSON_NDS_JOY_MODE, json_object_new_int(nds.joy.mode));
+    json_object_object_add(jfile, JSON_NDS_JOY_DZONE, json_object_new_int(nds.joy.dzone));
+#endif
+
     json_object_to_file_ext(nds.cfg.path, jfile, JSON_C_TO_STRING_PRETTY);
     json_object_put(jfile);
     printf(PREFIX"Wrote changed settings back !\n");
@@ -2689,15 +3543,47 @@ int fb_quit(void)
 }
 #endif
 
-#ifdef FUNKEYS
+#if  defined(RG35XXH) //&& !defined(RG35XXH_GL)
 int fb_init(void)
 {
+#ifdef RG35XXH_GL
+    gfx.fb_dev = open("/dev/fb0", O_RDWR, 0);
+    if (gfx.fb_dev < 0) {
+        printf(PREFIX"Failed to open /dev/fb0\n");
+        return -1;
+    }
+
+    if (ioctl(gfx.fb_dev, FBIOGET_VSCREENINFO, &gfx.vinfo) < 0) {
+        printf(PREFIX"Failed to get fb info\n");
+        return -1;
+    }
+/*
+    gfx.fb.virAddr = mmap(NULL, FB_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, gfx.fb_dev, 0);
+    if (gfx.fb.virAddr == (void *)-1) {
+        close(gfx.fb_dev);
+        gfx.fb_dev = -1;
+        printf(PREFIX"Failed to mmap fb\n");
+        return -1;
+    }
+    printf(PREFIX"FB virAddr %p (size:%d)\n", gfx.fb.virAddr, FB_SIZE);
+    memset(gfx.fb.virAddr, 0 , FB_SIZE);
+*/
+    gfx.vinfo.yres_virtual = gfx.vinfo.yres * 2;
+    ioctl(gfx.fb_dev, FBIOPUT_VSCREENINFO, &gfx.vinfo);
+
+#else
     gfx.fb_dev = open("/dev/fb0", O_RDWR);
     if (gfx.fb_dev < 0) {
         printf(PREFIX"Failed to open fb0\n");
         return -1;
     }
 
+    ioctl(gfx.fb_dev, FBIOGET_FSCREENINFO, &gfx.finfo);
+    ioctl(gfx.fb_dev, FBIOGET_VSCREENINFO, &gfx.vinfo);
+    gfx.vinfo.yoffset = 0;
+    gfx.vinfo.yres_virtual = gfx.vinfo.yres * 2;
+    ioctl(gfx.fb_dev, FBIOPUT_VSCREENINFO, &gfx.vinfo);
+    
     gfx.hw.mem = mmap(NULL, FB_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, gfx.fb_dev, 0);
     if (gfx.hw.mem == (void *)-1) {
         close(gfx.fb_dev);
@@ -2705,14 +3591,37 @@ int fb_init(void)
         return -1;
     }
     memset(gfx.hw.mem, 0 , FB_SIZE);
+	
+    gfx.hw.swsurface = SDL_CreateRGBSurface(SDL_SWSURFACE, FB_W, FB_H, 32, 0, 0, 0, 0);
+#endif
     return 0;
 }
 
 int fb_quit(void)
 {
+#ifdef RG35XXH_GL
+/*
+    if (gfx.fb.virAddr) {
+        munmap(gfx.fb.virAddr, FB_SIZE);
+        gfx.fb.virAddr = NULL;
+    }
+*/
+    if (gfx.fb_dev > 0) {
+        close(gfx.fb_dev);
+        gfx.fb_dev = -1;
+    }
+#else
+    if (gfx.hw.swsurface != NULL)
+        SDL_FreeSurface(gfx.hw.swsurface);
+
+    gfx.vinfo.yoffset = 0;
+    ioctl(gfx.fb_dev, FBIOPUT_VSCREENINFO, &gfx.vinfo);
+    
     munmap(gfx.hw.mem, FB_SIZE);
     close(gfx.fb_dev);
     gfx.fb_dev = -1;
+    
+#endif
     return 0;
 }
 #endif
@@ -2873,12 +3782,168 @@ void disp_resize(void)
 }
 #endif
 
-#ifdef MMIYOO
-int fb_init(void)
+#ifdef A30
+static int get_core(int index)
+{
+    FILE *fd = NULL;
+    char buf[255] = {0};
+
+    sprintf(buf, "cat /sys/devices/system/cpu/cpu%d/online", index % 4); 
+    fd = popen(buf, "r");
+    if (fd == NULL) {
+        return -1;
+    }       
+    fgets(buf, sizeof(buf), fd);
+    pclose(fd);
+    return atoi(buf);
+}
+
+static void check_before_set(int num, int v)
+{
+    char buf[255] = {0};
+
+    if (get_core(num) != v) {
+        sprintf(buf, "echo %d > /sys/devices/system/cpu/cpu%d/online", v ? 1 : 0, num);
+        system(buf);
+    }       
+}   
+
+static void set_core(int n)
+{           
+    if (n <= 1) {
+        printf(PREFIX"New CPU Core: 1\n");
+        check_before_set(0, 1);
+        check_before_set(1, 0);
+        check_before_set(2, 0);
+        check_before_set(3, 0);
+    }       
+    else if (n == 2) {
+        printf(PREFIX"New CPU Core: 2\n");
+        check_before_set(0, 1);
+        check_before_set(1, 1);
+        check_before_set(2, 0);
+        check_before_set(3, 0);
+    }       
+    else if (n == 3) {
+        printf(PREFIX"New CPU Core: 3\n");
+        check_before_set(0, 1);
+        check_before_set(1, 1);
+        check_before_set(2, 1);
+        check_before_set(3, 0);
+    }
+    else {
+        printf(PREFIX"New CPU Core: 4\n");
+        check_before_set(0, 1);
+        check_before_set(1, 1);
+        check_before_set(2, 1);
+        check_before_set(3, 1);
+    }
+}
+
+static int set_best_match_cpu_clock(int clk)
 {
-#ifndef UNITTEST
     int cc = 0;
 
+    system("echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor");
+    for (cc = 0; cc < max_cpu_item; cc++) {
+        if (cpu_clock[cc].clk >= clk) {
+            printf(PREFIX"Set Best Match CPU %dMHz (0x%08x)\n", cpu_clock[cc].clk, cpu_clock[cc].reg);
+            *vid.cpu_ptr = cpu_clock[cc].reg;
+            return cc;
+        }
+    }
+    return -1;
+}
+
+int fb_init(void)
+{
+    gfx.fb_dev = open("/dev/fb0", O_RDWR, 0);
+    if (gfx.fb_dev < 0) {
+        printf(PREFIX"Failed to open /dev/fb0\n");
+        return -1;
+    }
+
+    if (ioctl(gfx.fb_dev, FBIOGET_VSCREENINFO, &gfx.vinfo) < 0) {
+        printf(PREFIX"Failed to get fb info\n");
+        return -1;
+    }
+
+    gfx.fb.virAddr = mmap(NULL, FB_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, gfx.fb_dev, 0);
+    if (gfx.fb.virAddr == (void *)-1) {
+        close(gfx.fb_dev);
+        gfx.fb_dev = -1;
+        printf(PREFIX"Failed to mmap fb\n");
+        return -1;
+    }
+    printf(PREFIX"FB virAddr %p (size:%d)\n", gfx.fb.virAddr, FB_SIZE);
+    memset(gfx.fb.virAddr, 0 , FB_SIZE);
+
+    gfx.vinfo.yres_virtual = gfx.vinfo.yres * 2;
+    ioctl(gfx.fb_dev, FBIOPUT_VSCREENINFO, &gfx.vinfo);
+
+    vid.mem_fd = open("/dev/mem", O_RDWR);
+    if (vid.mem_fd < 0) { 
+        printf("Failed to open /dev/mem\n");
+        return -1;
+    }    
+    vid.ccu_mem = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, vid.mem_fd, CCU_BASE);
+    if (vid.ccu_mem == MAP_FAILED) {
+        printf("Failed to map memory\n");
+        return -1;
+    }    
+    printf(PREFIX"CCU MMap %p\n", vid.ccu_mem);
+    vid.cpu_ptr = (uint32_t *)&vid.ccu_mem[0x00];
+
+    vid.dac_mem = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, vid.mem_fd, DAC_BASE);
+    if (vid.dac_mem == MAP_FAILED) {
+        printf("Failed to map memory\n");
+        return -1;
+    }    
+    printf(PREFIX"DAC MMap %p\n", vid.dac_mem);
+    vid.vol_ptr = (uint32_t *)(&vid.dac_mem[0xc00 + 0x258]);
+
+    set_best_match_cpu_clock(INIT_CPU_CLOCK);
+    set_core(INIT_CPU_CORE);
+    return 0;
+}
+
+int fb_quit(void)
+{
+    set_best_match_cpu_clock(DEINIT_CPU_CLOCK);
+    set_core(DEINIT_CPU_CORE);
+    system("echo ondemand > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor");
+
+    if (gfx.fb.virAddr) {
+        munmap(gfx.fb.virAddr, FB_SIZE);
+        gfx.fb.virAddr = NULL;
+    }
+
+    if (gfx.fb_dev > 0) {
+        close(gfx.fb_dev);
+        gfx.fb_dev = -1;
+    }
+
+    if (vid.ccu_mem != MAP_FAILED) {
+        munmap(vid.ccu_mem, 4096);
+        vid.ccu_mem = NULL;
+    }
+
+    if (vid.dac_mem != MAP_FAILED) {
+        munmap(vid.dac_mem, 4096);
+        vid.dac_mem = NULL;
+    }
+
+    if (vid.mem_fd > 0) {
+        close(vid.mem_fd);
+        vid.mem_fd = -1;
+    }
+    return 0;
+}
+#endif
+
+#ifdef MMIYOO
+int fb_init(void)
+{
     MI_SYS_Init();
     MI_GFX_Open();
 
@@ -2900,24 +3965,23 @@ int fb_init(void)
     MI_SYS_MMA_Alloc(NULL, TMP_SIZE, &gfx.overlay.phyAddr);
     MI_SYS_Mmap(gfx.overlay.phyAddr, TMP_SIZE, &gfx.overlay.virAddr, TRUE);
 
-    for (cc = 0; cc < 2; cc++) {
-        MI_SYS_MMA_Alloc(NULL, SCREEN_DMA_SIZE, &gfx.lcd.phyAddr[cc]);
-        MI_SYS_Mmap(gfx.lcd.phyAddr[cc], SCREEN_DMA_SIZE, &gfx.lcd.virAddr[cc], TRUE);
-
-        MI_SYS_MMA_Alloc(NULL, SCREEN_DMA_SIZE, &gfx.dup.phyAddr[cc]);
-        MI_SYS_Mmap(gfx.dup.phyAddr[cc], SCREEN_DMA_SIZE, &gfx.dup.virAddr[cc], TRUE);
-
-        nds.screen.pixels[cc] = gfx.dup.virAddr[cc];
-    }
-#endif
+    MI_SYS_MMA_Alloc(NULL, SCREEN_DMA_SIZE, &gfx.lcd.phyAddr[0][0]);
+    MI_SYS_MMA_Alloc(NULL, SCREEN_DMA_SIZE, &gfx.lcd.phyAddr[0][1]);
+    MI_SYS_MMA_Alloc(NULL, SCREEN_DMA_SIZE, &gfx.lcd.phyAddr[1][0]);
+    MI_SYS_MMA_Alloc(NULL, SCREEN_DMA_SIZE, &gfx.lcd.phyAddr[1][1]);
+    MI_SYS_Mmap(gfx.lcd.phyAddr[0][0], SCREEN_DMA_SIZE, &gfx.lcd.virAddr[0][0], TRUE);
+    MI_SYS_Mmap(gfx.lcd.phyAddr[0][1], SCREEN_DMA_SIZE, &gfx.lcd.virAddr[0][1], TRUE);
+    MI_SYS_Mmap(gfx.lcd.phyAddr[1][0], SCREEN_DMA_SIZE, &gfx.lcd.virAddr[1][0], TRUE);
+    MI_SYS_Mmap(gfx.lcd.phyAddr[1][1], SCREEN_DMA_SIZE, &gfx.lcd.virAddr[1][1], TRUE);
+    printf(PREFIX"Ping-pong Buffer %p\n", gfx.lcd.virAddr[0][0]);
+    printf(PREFIX"Ping-pong Buffer %p\n", gfx.lcd.virAddr[0][1]);
+    printf(PREFIX"Ping-pong Buffer %p\n", gfx.lcd.virAddr[1][0]);
+    printf(PREFIX"Ping-pong Buffer %p\n", gfx.lcd.virAddr[1][1]);
     return 0;
 }
 
 int fb_quit(void)
 {
-#ifndef UNITTEST
-    int cc = 0;
-
     MI_SYS_Munmap(gfx.fb.virAddr, TMP_SIZE);
 
     MI_SYS_Munmap(gfx.tmp.virAddr, TMP_SIZE);
@@ -2926,13 +3990,14 @@ int fb_quit(void)
     MI_SYS_Munmap(gfx.overlay.virAddr, TMP_SIZE);
     MI_SYS_MMA_Free(gfx.overlay.phyAddr);
 
-    for (cc = 0; cc < 2; cc++) {
-        MI_SYS_Munmap(gfx.lcd.virAddr[cc], SCREEN_DMA_SIZE);
-        MI_SYS_MMA_Free(gfx.lcd.phyAddr[cc]);
-
-        MI_SYS_Munmap(gfx.dup.virAddr[cc], SCREEN_DMA_SIZE);
-        MI_SYS_MMA_Free(gfx.dup.phyAddr[cc]);
-    }
+    MI_SYS_Munmap(gfx.lcd.virAddr[0][0], SCREEN_DMA_SIZE);
+    MI_SYS_Munmap(gfx.lcd.virAddr[0][1], SCREEN_DMA_SIZE);
+    MI_SYS_Munmap(gfx.lcd.virAddr[1][0], SCREEN_DMA_SIZE);
+    MI_SYS_Munmap(gfx.lcd.virAddr[1][1], SCREEN_DMA_SIZE);
+    MI_SYS_MMA_Free(gfx.lcd.phyAddr[0][0]);
+    MI_SYS_MMA_Free(gfx.lcd.phyAddr[0][1]);
+    MI_SYS_MMA_Free(gfx.lcd.phyAddr[1][0]);
+    MI_SYS_MMA_Free(gfx.lcd.phyAddr[1][1]);
 
     MI_GFX_Close();
     MI_SYS_Exit();
@@ -2941,7 +4006,6 @@ int fb_quit(void)
     ioctl(gfx.fb_dev, FBIOPUT_VSCREENINFO, &gfx.vinfo);
     close(gfx.fb_dev);
     gfx.fb_dev = -1;
-#endif
     return 0;
 }
 #endif
@@ -3084,9 +4148,20 @@ void GFX_Quit(void)
 {
     void *ret = NULL;
 
+    printf(PREFIX"Wait for video_handler exit\n");
+
+    // acquire a lock
+    pthread_mutex_lock(&lock);
     is_running = 0;
+    //pthread_cond_destory(&request_update_screen_cond);    // build error
+    pthread_cond_signal(&request_update_screen_cond);
+    
+    pthread_mutex_unlock(&lock);  
+    
     pthread_join(thread, &ret);
+
     GFX_Clear();
+    printf(PREFIX"Free FB resources\n");
     fb_quit();
 
     if (cvt) {
@@ -3097,21 +4172,18 @@ void GFX_Quit(void)
 
 void GFX_Clear(void)
 {
-#if defined(MMIYOO)
-    int cc = 0;
-
+#ifdef MMIYOO
     MI_SYS_MemsetPa(gfx.fb.phyAddr, 0, FB_SIZE);
     MI_SYS_MemsetPa(gfx.tmp.phyAddr, 0, TMP_SIZE);
-    for (cc = 0; cc < 2; cc++) {
-        MI_SYS_MemsetPa(gfx.lcd.phyAddr[cc], 0, SCREEN_DMA_SIZE);
-        MI_SYS_MemsetPa(gfx.dup.phyAddr[cc], 0, SCREEN_DMA_SIZE);
-    }
+    MI_SYS_MemsetPa(gfx.lcd.phyAddr[0][0], 0, SCREEN_DMA_SIZE);
+    MI_SYS_MemsetPa(gfx.lcd.phyAddr[0][1], 0, SCREEN_DMA_SIZE);
+    MI_SYS_MemsetPa(gfx.lcd.phyAddr[1][0], 0, SCREEN_DMA_SIZE);
+    MI_SYS_MemsetPa(gfx.lcd.phyAddr[1][1], 0, SCREEN_DMA_SIZE);
 #endif
 }
 
 int draw_pen(void *pixels, int width, int pitch)
 {
-#ifndef UNITTEST
     int c0 = 0;
     int c1 = 0;
     int w = 28;
@@ -3150,21 +4222,50 @@ int draw_pen(void *pixels, int width, int pitch)
     case PEN_LT:
         break;
     case PEN_LB:
-        y-= (h * scale);
+        y -= (h * scale);
         break;
     case PEN_RT:
-        x-= (w * scale);
+        x -= (w * scale);
         break;
     case PEN_RB:
-        x-= (w * scale);
-        y-= (h * scale);
+        x -= (w * scale);
+        y -= (h * scale);
+        break;
+    case PEN_CP:
+        x -= ((w * scale) >> 1);
+        y -= ((h * scale) >> 1);
         break;
     }
 
-    asm ("PLD [%0, #128]"::"r" (s));
+#if 0
+    vVertices[0] = ((((float)x) / NDS_W) - 0.5) * 2.0;
+    vVertices[1] = ((((float)y) / NDS_H) - 0.5) * -2.0;
+
+    vVertices[5] = vVertices[0];
+    vVertices[6] = ((((float)(y + nds.pen.img->h)) / NDS_H) - 0.5) * -2.0;
+
+    vVertices[10] = ((((float)(x + nds.pen.img->w)) / NDS_W) - 0.5) * 2.0;
+    vVertices[11] = vVertices[6];
+
+    vVertices[15] = vVertices[10];
+    vVertices[16] = vVertices[1];
+
+    glUniform1f(vid.alphaLoc, 1.0);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glEnable(GL_BLEND);
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, vid.texID[TEX_PEN]);
+    glVertexAttribPointer(vid.posLoc, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), vVertices);
+    glVertexAttribPointer(vid.texLoc, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), &vVertices[3]);
+    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices);
+    glDisable(GL_BLEND);
+    glUniform1f(vid.alphaLoc, 0.0);
+#endif
+
+    //asm ("pld [%0, #128]"::"r" (s));
     for (c1=0; c1<h; c1++) {
-        asm ("PLD [%0, #128]"::"r" (d_565));
-        asm ("PLD [%0, #128]"::"r" (d_888));
+        //asm ("pld [%0, #128]"::"r" (d_565));
+        //asm ("pld [%0, #128]"::"r" (d_888));
         for (c0=0; c0<w; c0++) {
             x0 = x1 = (c0 * scale) + x;
             y0 = y1 = (c1 * scale) + (y - sub);
@@ -3199,12 +4300,93 @@ int draw_pen(void *pixels, int width, int pitch)
             s+= 1;
         }
     }
-#endif
     return 0;
 }
 
-int GFX_Copy(const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int pitch, int alpha, int rotate)
+int GFX_Copy(int id, const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int pitch, int alpha, int rotate)
 {
+#if defined(A30) || defined(RG35XXH_GL)
+    int tex = (id >= 0) ? id : TEX_TMP;
+
+#ifdef RG35XXH_GL
+    if ((id != -1) && (nds.dis_mode == NDS_DIS_MODE_HH0)) {
+#else
+    if ((id != -1) && (nds.dis_mode == NDS_DIS_MODE_HH1)) {
+#endif
+        vVertices[5] = ((((float)dstrect.x) / 640.0) - 0.5) * 2.0;
+        vVertices[6] = ((((float)dstrect.y) / 480.0) - 0.5) * -2.0;
+
+        vVertices[10] = vVertices[5];
+        vVertices[11] = ((((float)(dstrect.y + dstrect.w)) / 480.0) - 0.5) * -2.0;
+
+        vVertices[15] = ((((float)(dstrect.x + dstrect.h)) / 640.0) - 0.5) * 2.0;
+        vVertices[16] = vVertices[11];
+
+        vVertices[0] = vVertices[15];
+        vVertices[1] = vVertices[6];
+    }
+#ifdef RG35XXH_GL
+    else if ((id != -1) && (nds.dis_mode == NDS_DIS_MODE_HH1)) {
+#else    
+    else if ((id != -1) && (nds.dis_mode == NDS_DIS_MODE_HH0)) {
+#endif
+        vVertices[15] = ((((float)dstrect.x) / 640.0) - 0.5) * 2.0;
+        vVertices[16] = ((((float)dstrect.y) / 480.0) - 0.5) * -2.0;
+
+        vVertices[0] = vVertices[15];
+        vVertices[1] = ((((float)(dstrect.y + dstrect.w)) / 480.0) - 0.5) * -2.0;
+
+        vVertices[5] = ((((float)(dstrect.x + dstrect.h)) / 640.0) - 0.5) * 2.0;
+        vVertices[6] = vVertices[1];
+
+        vVertices[10] = vVertices[5];
+        vVertices[11] = vVertices[16];
+    }
+    else {
+        vVertices[0] = ((((float)dstrect.x) / 640.0) - 0.5) * 2.0;
+        vVertices[1] = ((((float)dstrect.y) / 480.0) - 0.5) * -2.0;
+
+        vVertices[5] = vVertices[0];
+        vVertices[6] = ((((float)(dstrect.y + dstrect.h)) / 480.0) - 0.5) * -2.0;
+
+        vVertices[10] = ((((float)(dstrect.x + dstrect.w)) / 640.0) - 0.5) * 2.0;
+        vVertices[11] = vVertices[6];
+
+        vVertices[15] = vVertices[10];
+        vVertices[16] = vVertices[1];
+    }
+
+    if (tex == TEX_TMP) {
+        glBindTexture(GL_TEXTURE_2D, vid.texID[tex]);
+        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+        if (pixel_filter) {
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+        }
+        else {
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        }
+        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, srcrect.w, srcrect.h, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
+    }
+
+    if (((nds.dis_mode == NDS_DIS_MODE_VH_T0) || (nds.dis_mode == NDS_DIS_MODE_VH_T1)) && (tex == TEX_SCR0)) {
+        glUniform1f(vid.alphaLoc, 1.0 - ((float)nds.alpha.val / 10.0));
+        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+        glEnable(GL_BLEND);
+    }
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, vid.texID[tex]);
+    glVertexAttribPointer(vid.posLoc, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), vVertices);
+    glVertexAttribPointer(vid.texLoc, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), &vVertices[3]);
+    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices);
+
+    if (((nds.dis_mode == NDS_DIS_MODE_VH_T0) || (nds.dis_mode == NDS_DIS_MODE_VH_T1)) && (tex == TEX_SCR0)) {
+        glUniform1f(vid.alphaLoc, 0.0);
+        glDisable(GL_BLEND);
+    }
+#endif
+
 #ifdef QX1000
     int x = 0;
     int y = 0;
@@ -3613,59 +4795,87 @@ int GFX_Copy(const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int pitch,
         }
     }
 #endif
+#ifdef RG35XXH 
+#ifndef RG35XXH_GL
+{
+    int x = 0;
+    int y = 0;
+    const uint32_t *src = pixels;
+    //uint32_t *dst = (uint32_t *)gfx.hw.mem;
+	uint32_t *dst = (uint32_t *)gfx.hw.swsurface->pixels;
+
+	if (src != 0) {		
+		if (srcrect.w == NDS_W) {
+			if (nds.dis_mode == NDS_DIS_MODE_HH0 ||  nds.dis_mode == NDS_DIS_MODE_HH1) {
+				SDL_Surface *t = NULL;
+				t = SDL_CreateRGBSurface(SDL_SWSURFACE, NDS_H, NDS_W, 32, 0, 0, 0, 0);
+				if (nds.dis_mode == NDS_DIS_MODE_HH0) {
+					// degree 90
+					int row, col;
+
+					for (row = 0; row < srcrect.h; ++row) { 
+						src = (uint32_t *)pixels + (row * NDS_W); 
+						dst = (uint32_t *)t->pixels + (NDS_H - row - 1) ; 
+						for (col = 0; col < srcrect.w; ++col) { 
+							*dst = *src;
+							src ++; 
+							dst += NDS_H; 
+						}  
+					}  
+				}
+				else  {
+					// degree 270
+					int row, col;
+					for (row = 0; row < srcrect.h; ++row) { 
+						src = (uint32_t *)pixels + (row * NDS_W); 
+						dst = (uint32_t *)t->pixels + row + ((NDS_W-1)* NDS_H) ; 
+						for (col = 0; col < srcrect.w; ++col) { 
+							*dst = *src;
+							src ++; 
+							dst -= NDS_H; 
+						}  
+					}  				
+				}
+				
+				dst = (uint32_t *)gfx.hw.swsurface->pixels + dstrect.y  * FB_W + dstrect.x;
+				
+				scale_mat_NEON((uint32_t *)t->pixels, srcrect.h, srcrect.w, srcrect.h*4, 
+													   dst, dstrect.h, dstrect.w, FB_W*4); 
+				//scale_mat((uint32_t *)t->pixels, srcrect.h, srcrect.w, srcrect.h*4, 
+				//									   dst, dstrect.w, dstrect.h, FB_W*4); 			
+				SDL_FreeSurface(t);
+			}
+			else {
+				// degree 0 only
+				dst += dstrect.y  * FB_W + dstrect.x;
+				
+				scale_mat_NEON((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+													   dst, dstrect.w, dstrect.h, FB_W*4); 
+				//scale_mat((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+				//                                       dst, dstrect.w, dstrect.h, FB_W*4); 
+			}
+		}
+		else {
+			dst += dstrect.y  * FB_W + dstrect.x;
+			if (srcrect.w  == dstrect.w && srcrect.h == dstrect.h) {
+				for (y = 0; y < srcrect.h; y++) {
+					for (x = 0; x < srcrect.w; x++) {
+						*dst++ = *src++;
+					}
+					dst+= (FB_W - srcrect.w);
+				}
+			}
+			else {
+				scale_mat_NEON((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+													   dst, dstrect.w, dstrect.h, FB_W*4); 
+				//scale_mat((uint32_t *)pixels + srcrect.y * srcrect.w + srcrect.x , srcrect.w, srcrect.h, srcrect.w*4, 
+				//                                       dst, dstrect.w, dstrect.h, FB_W*4); 				
+			}
+	  }
+	}
 
-#ifdef FUNKEYS
-    if ((srcrect.w == NDS_W) && (srcrect.h == NDS_H)) {
-        uint16_t *dst = (uint16_t *)gfx.hw.mem + (((FB_H - NDS_H) >> 1) * FB_W);
-        uint16_t *src = (uint16_t *)pixels;
-
-        asm volatile (
-            "1:  add %0, #16            ;"
-            "    vldmia %0!, {q0-q7}    ;"
-            "    vldmia %0!, {q8-q14}   ;"
-            "    vstmia %1!, {q0-q7}    ;"
-            "    vstmia %1!, {q8-q14}   ;"
-            "    vldmia %0!, {q0-q7}    ;"
-            "    vldmia %0!, {q8-q14}   ;"
-            "    vstmia %1!, {q0-q7}    ;"
-            "    vstmia %1!, {q8-q14}   ;"
-            "    add %0, #16            ;"
-            "    subs %2, #1            ;"
-            "    bne 1b                 ;"
-            :
-            : "r"(src), "r"(dst), "r"(NDS_H)
-            : "q0", "q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9", "q10", "q11", "q12", "q13", "q14", "memory", "cc"
-        );
-    }
-    else if ((srcrect.w == FB_W) && (srcrect.h == FB_H)) {
-        int x = 0;
-        int y = 0;
-        uint32_t v = 0;
-        uint16_t *dst = (uint16_t *)gfx.hw.mem;
-        uint32_t *src = (uint32_t *)pixels;
-
-        for (y = 0; y < srcrect.h; y++) {
-            for (x = 0; x < srcrect.w; x++) {
-                v = *src++;
-                *dst++ = ((v & 0xf80000) >> 8) | ((v & 0xfc00) >> 5) | ((v & 0xf8) >> 3);
-            }
-        }
-    }
-    else {
-        int x = 0;
-        int y = 0;
-        uint32_t v = 0;
-        uint16_t *dst = (uint16_t *)gfx.hw.mem + (((FB_H - NDS_H) >> 1) * FB_W);
-        uint32_t *src = (uint32_t *)pixels;
-
-        for (y = 0; y < srcrect.h; y++) {
-            for (x = 0; x < srcrect.w; x++) {
-                v = *src++;
-                *dst++ = ((v & 0xf80000) >> 8) | ((v & 0xfc00) >> 5) | ((v & 0xf8) >> 3);
-            }
-            dst+= (FB_W - srcrect.w);
-        }
-    }
+}
+#endif
 #endif
 
 #ifdef TRIMUI
@@ -3793,7 +5003,6 @@ int GFX_Copy(const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int pitch,
 #ifdef MMIYOO
     int cc = 0;
     int copy_it = 1;
-    int is_dma_buf = -1;
     MI_U16 u16Fence = 0;
     int is_rgb565 = (pitch / srcrect.w) == 2 ? 1 : 0;
 
@@ -3801,13 +5010,6 @@ int GFX_Copy(const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int pitch,
         return -1;
     }
 
-    for (cc = 0; cc < 2; cc++) {
-        if (pixels == gfx.dup.virAddr[cc]) {
-            is_dma_buf = cc;
-            break;
-        }
-    }
-
     if (alpha != 0) {
         if (nds.alpha.val > NDS_ALPHA_MAX) {
             nds.alpha.val = 0;
@@ -4308,10 +5510,22 @@ int GFX_Copy(const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int pitch,
     }
 
     if (copy_it) {
-        if (is_dma_buf >= 0) {
-            gfx.hw.src.surf.phyAddr = gfx.dup.phyAddr[is_dma_buf];
+        int found = 0;
+
+        for (cc = 0; cc < 2; cc++) {
+            if (pixels == gfx.lcd.virAddr[cc][0]) {
+                found = 1;
+                gfx.hw.src.surf.phyAddr = gfx.lcd.phyAddr[cc][0];
+                break;
+            }
+            if (pixels == gfx.lcd.virAddr[cc][1]) {
+                found = 1;
+                gfx.hw.src.surf.phyAddr = gfx.lcd.phyAddr[cc][1];
+                break;
+            }
         }
-        else {
+
+        if (found == 0) {
             neon_memcpy(gfx.tmp.virAddr, pixels, srcrect.h * pitch);
             gfx.hw.src.surf.phyAddr = gfx.tmp.phyAddr;
             MI_SYS_FlushInvCache(gfx.tmp.virAddr, pitch * srcrect.h);
@@ -4388,6 +5602,18 @@ void GFX_Flip(void)
     gfx.vinfo.yoffset ^= FB_H;
 #endif
 
+#if defined(A30) || defined(RG35XXH_GL)
+    eglSwapBuffers(vid.eglDisplay, vid.eglSurface);
+
+    if (nds.theme.img) {
+        glActiveTexture(GL_TEXTURE0);
+        glBindTexture(GL_TEXTURE_2D, vid.texID[TEX_BG]);
+        glVertexAttribPointer(vid.posLoc, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), bgVertices);
+        glVertexAttribPointer(vid.texLoc, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), &bgVertices[3]);
+        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices);
+    }
+#endif
+
 #ifdef MMIYOO
     ioctl(gfx.fb_dev, FBIOPAN_DISPLAY, &gfx.vinfo);
     gfx.vinfo.yoffset ^= FB_H;
@@ -4401,6 +5627,21 @@ void GFX_Flip(void)
     ioctl(gfx.fb_dev, FBIO_WAITFORVSYNC, &r);
     gfx.fb.flip^= 1;
 #endif
+
+#ifdef RG35XXH
+#ifndef RG35XXH_GL
+	//neon_memcpy(gfx.hw.mem, gfx.hw.swsurface->pixels, FB_W * FB_H * 4); 
+    uint32_t *src = gfx.hw.swsurface->pixels;
+    uint32_t *dst = (uint32_t *)gfx.hw.mem;
+    int x, y;
+	
+	for (y = 0; y < FB_H; y++) {
+		for (x = 0; x < FB_W; x++) {
+			*dst++ = *src++;
+		}
+	}
+#endif
+#endif
 }
 
 int get_font_width(const char *info)
@@ -4488,7 +5729,7 @@ int draw_info(SDL_Surface *dst, const char *info, int x, int y, uint32_t fgcolor
                     rt.y = y;
                     rt.w = t2->w;
                     rt.h = t2->h;
-                    GFX_Copy(t2->pixels, t2->clip_rect, rt, t2->pitch, 0, E_MI_GFX_ROTATE_180);
+                    GFX_Copy(-1, t2->pixels, t2->clip_rect, rt, t2->pitch, 0, E_MI_GFX_ROTATE_180);
                     SDL_FreeSurface(t2);
                 }
                 SDL_FreeSurface(t1);
@@ -4523,6 +5764,27 @@ int reload_pen(void)
         if (get_file_path(nds.pen.path, nds.pen.sel, buf, 1) == 0) {
             t = IMG_Load(buf);
             if (t) {
+#if defined(A30) || defined(RG35XXH_GL)
+                int x = 0;
+                int y = 0;
+                uint32_t *p = malloc(t->pitch * t->h);
+                uint32_t *src = t->pixels;
+                uint32_t *dst = p;
+
+                for (y = 0; y < t->h; y++) {
+                    for (x = 0; x < t->w; x++) {
+                        *dst++ = *src++;
+                    }
+                }
+                glBindTexture(GL_TEXTURE_2D, vid.texID[TEX_PEN]);
+                glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, t->w, t->h, 0, GL_RGBA, GL_UNSIGNED_BYTE, p);
+                free(p);
+#endif
                 nds.pen.img = SDL_ConvertSurface(t, cvt->format, 0);
                 SDL_FreeSurface(t);
 
@@ -4535,9 +5797,12 @@ int reload_pen(void)
                 else if (strstr(buf, "_rb")) {
                     nds.pen.type = PEN_RB;
                 }
-                else {
+                else if (strstr(buf, "_lb")) {
                     nds.pen.type = PEN_LB;
                 }
+                else {
+                    nds.pen.type = PEN_CP;
+                }
             }
             else {
                 printf(PREFIX"Failed to load pen (%s)\n", buf);
@@ -4590,7 +5855,7 @@ int reload_menu(void)
         SDL_FreeSurface(t);
     }
 
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     sprintf(buf, "%s/%s", folder, DRASTIC_MENU_CURSOR_FILE);
     nds.menu.drastic.cursor = IMG_Load(buf);
 #endif
@@ -4602,10 +5867,10 @@ int reload_menu(void)
     sprintf(buf, "%s/%s", folder, DRASTIC_MENU_YES_FILE);
     t = IMG_Load(buf);
     if (t) {
-#if defined(MMIYOO) || defined(QX1000)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         SDL_Rect nrt = {0, 0, LINE_H - 2, LINE_H - 2};
 #endif
-#if defined(TRIMUI) || defined(FUNKEYS) || defined(PANDORA)
+#if defined(TRIMUI) || defined(PANDORA)
         SDL_Rect nrt = {0, 0, t->w >> 1, t->h >> 1};
 #endif
         if (nds.menu.drastic.yes) {
@@ -4621,10 +5886,10 @@ int reload_menu(void)
     sprintf(buf, "%s/%s", folder, DRASTIC_MENU_NO_FILE);
     t = IMG_Load(buf);
     if (t) {
-#if defined(MMIYOO) || defined(QX1000)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
         SDL_Rect nrt = {0, 0, LINE_H - 2, LINE_H - 2};
 #endif
-#if defined(TRIMUI) || defined(FUNKEYS) || defined(PANDORA)
+#if defined(TRIMUI) || defined(PANDORA)
         SDL_Rect nrt = {0, 0, t->w >> 1, t->h >> 1};
 #endif
         if (nds.menu.drastic.no) {
@@ -4642,15 +5907,15 @@ int reload_menu(void)
 
 int reload_bg(void)
 {
-#if !defined(QX1000)
+#if !defined(PANDORA) && !defined(QX1000)
     static int pre_sel = -1;
 #endif
 
-#if !defined(FUNKEYS) && !defined(PANDORA) && !defined(QX1000)
+#if !defined(PANDORA) && !defined(QX1000)
     static int pre_mode = -1;
 #endif
 
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
     char buf[MAX_PATH] = {0};
     SDL_Surface *t = NULL;
     SDL_Rect srt = {0, 0, IMG_W, IMG_H};
@@ -4727,7 +5992,15 @@ int reload_bg(void)
                     if (t) {
                         SDL_BlitSurface(t, NULL, nds.theme.img, NULL);
                         SDL_FreeSurface(t);
-                        GFX_Copy(nds.theme.img->pixels, nds.theme.img->clip_rect, drt, nds.theme.img->pitch, 0, E_MI_GFX_ROTATE_180);
+#if defined(A30) || defined(RG35XXH_GL)
+		        glBindTexture(GL_TEXTURE_2D, vid.texID[TEX_BG]);
+		        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+		        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, nds.theme.img->w, nds.theme.img->h, 0, GL_RGBA, GL_UNSIGNED_BYTE, nds.theme.img->pixels);
+#else
+                        GFX_Copy(-1, nds.theme.img->pixels, nds.theme.img->clip_rect, drt, nds.theme.img->pitch, 0, E_MI_GFX_ROTATE_180);
+#endif
                     }
                     else {
                         printf(PREFIX"Failed to load wallpaper (%s)\n", buf);
@@ -4737,7 +6010,15 @@ int reload_bg(void)
         }
         else {
             if (nds.theme.img) {
-                GFX_Copy(nds.theme.img->pixels, nds.theme.img->clip_rect, drt, nds.theme.img->pitch, 0, E_MI_GFX_ROTATE_180);
+#if defined(A30) || defined(RG35XXH_GL)
+                glBindTexture(GL_TEXTURE_2D, vid.texID[TEX_BG]);
+                glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, nds.theme.img->w, nds.theme.img->h, 0, GL_RGBA, GL_UNSIGNED_BYTE, nds.theme.img->pixels);
+#else
+                GFX_Copy(-1, nds.theme.img->pixels, nds.theme.img->clip_rect, drt, nds.theme.img->pitch, 0, E_MI_GFX_ROTATE_180);
+#endif
             }
         }
     }
@@ -4745,7 +6026,7 @@ int reload_bg(void)
         t = SDL_CreateRGBSurface(SDL_SWSURFACE, IMG_W, IMG_H, 32, 0, 0, 0, 0);
         if (t) {
             SDL_FillRect(t, &t->clip_rect, SDL_MapRGB(t->format, 0x00, 0x00, 0x00));
-            GFX_Copy(t->pixels, t->clip_rect, drt, t->pitch, 0, E_MI_GFX_ROTATE_180);
+            GFX_Copy(-1, t->pixels, t->clip_rect, drt, t->pitch, 0, E_MI_GFX_ROTATE_180);
             SDL_FreeSurface(t);
         }
     }
@@ -4813,56 +6094,6 @@ int reload_bg(void)
     }
 #endif
 
-#ifdef FUNKEYS
-    SDL_Surface *t = NULL;
-    char buf[MAX_PATH] = {0};
-
-    if (pre_sel != nds.theme.sel) {
-        pre_sel = nds.theme.sel;
-
-        if (nds.theme.img) {
-            SDL_FreeSurface(nds.theme.img);
-            nds.theme.img = NULL;
-        }
-
-        nds.theme.img = SDL_CreateRGBSurface(SDL_SWSURFACE, IMG_W, IMG_H, 32, 0, 0, 0, 0);
-        if (nds.theme.img) {
-            SDL_FillRect(nds.theme.img, &nds.theme.img->clip_rect, SDL_MapRGB(nds.theme.img->format, 0x00, 0x00, 0x00));
-
-            if (get_dir_path(nds.theme.path, nds.theme.sel, buf) == 0) {
-                strcat(buf, "/bg_s0.png");
-                t = IMG_Load(buf);
-                if (t) {
-                    SDL_BlitSurface(t, NULL, nds.theme.img, NULL);
-                    SDL_FreeSurface(t);
-                }
-                else {
-                    printf(PREFIX"Failed to load wallpaper (%s)\n", buf);
-                }
-            }
-        }
-    }
-
-    if (nds.theme.img) {
-        int x = 0;
-        int y = 0;
-        uint32_t v = 0;
-        uint16_t *dst = (uint16_t *)gfx.hw.mem;
-        uint32_t *src = (uint32_t *)nds.theme.img->pixels;
-
-        for (y = 0; y < FB_H; y++) {
-            src+= ((IMG_W - (FB_W << 1)) >> 1);
-            for (x = 0; x < FB_W; x++) {
-                v = *src;
-                *dst++ = ((v & 0xf80000) >> 8) | ((v & 0xfc00) >> 5) | ((v & 0xf8) >> 3);
-                src+= 2;
-            }
-            src+= ((IMG_W - (FB_W << 1)) >> 1);
-            src+= IMG_W;
-        }
-    }
-#endif
-
 #ifdef PANDORA
     SDL_Surface *t = NULL;
     char buf[MAX_PATH] = {0};
@@ -4914,7 +6145,7 @@ int reload_bg(void)
     return 0;
 }
 
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
 int reload_overlay(void)
 {
     static int pre_sel = -1;
@@ -4939,7 +6170,8 @@ int reload_overlay(void)
                 if (t) {
                     SDL_BlitSurface(t, NULL, nds.overlay.img, NULL);
                     SDL_FreeSurface(t);
-#ifndef UNITTEST
+
+#ifdef MMIYOO
                     gfx.hw.overlay.surf.phyAddr = gfx.overlay.phyAddr;
                     gfx.hw.overlay.surf.eColorFmt = E_MI_GFX_FMT_ARGB8888;
                     gfx.hw.overlay.surf.u32Width = FB_W;
@@ -4979,9 +6211,10 @@ static void MMIYOO_DeleteDevice(SDL_VideoDevice *device)
 
 int MMIYOO_CreateWindow(_THIS, SDL_Window *window)
 {
-    SDL_SetMouseFocus(window);
     vid.window = window;
-    printf(PREFIX"Width:%d, Height:%d\n", window->w, window->h);
+    SDL_SetMouseFocus(window);
+    SDL_SetKeyboardFocus(window);
+    printf(PREFIX"Window:%p, Width:%d, Height:%d\n", window, window->w, window->h);
     return 0;
 }
 
@@ -5008,44 +6241,57 @@ static SDL_VideoDevice *MMIYOO_CreateDevice(int devindex)
     device->VideoInit = MMIYOO_VideoInit;
     device->VideoQuit = MMIYOO_VideoQuit;
     device->SetDisplayMode = MMIYOO_SetDisplayMode;
-    device->PumpEvents = MMIYOO_PumpEvents;
     device->CreateSDLWindow = MMIYOO_CreateWindow;
     device->CreateSDLWindowFrom = MMIYOO_CreateWindowFrom;
     device->free = MMIYOO_DeleteDevice;
+    device->PumpEvents = MMIYOO_PumpEvents;
     return device;
 }
 
 VideoBootStrap MMIYOO_bootstrap = {MMIYOO_DRIVER_NAME, "MMIYOO VIDEO DRIVER", MMIYOO_CreateDevice};
+/*
+ typedef struct SDL_DisplayData
+ {
+   int ion_fd;
+    struct MALI_Blitter *blitter;
+    fbdev_window_s native_display;
+    int rotation;
+    unsigned long stride;
+    unsigned long w_align;
+    unsigned long h_align;
+    NativePixmapType (*egl_create_pixmap_ID_mapping)(mali_pixmap *);
+    NativePixmapType (*egl_destroy_pixmap_ID_mapping)(int id);
+ } SDL_DisplayData;
+*/
 
 int MMIYOO_VideoInit(_THIS)
 {
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(RG35XXH)
     FILE *fd = NULL;
     char buf[MAX_PATH] = {0};
 #endif
 
-    SDL_DisplayMode mode={0};
-    SDL_VideoDisplay display={0};
+    SDL_DisplayMode mode = {0};
+    SDL_VideoDisplay display = {0};
+
+#ifdef RG35XXH
+    //SDL_DisplayData *data;
+#endif
 
     printf(PREFIX"MMIYOO_VideoInit\n");
 #ifndef UNITTEST
     signal(SIGTERM, sigterm_handler);
 #endif
 
-    SDL_zero(mode);
-    mode.format = SDL_PIXELFORMAT_RGB565;
-    mode.w = 640;
-    mode.h = 480;
-    mode.refresh_rate = 60;
-    SDL_AddDisplayMode(&display, &mode);
-
+#if defined(RG35XXH)
     SDL_zero(mode);
     mode.format = SDL_PIXELFORMAT_ARGB8888;
     mode.w = 640;
     mode.h = 480;
     mode.refresh_rate = 60;
-    SDL_AddDisplayMode(&display, &mode);
 
+    SDL_AddDisplayMode(&display, &mode);
+#else
     SDL_zero(mode);
     mode.format = SDL_PIXELFORMAT_RGB565;
     mode.w = 800;
@@ -5100,7 +6346,7 @@ int MMIYOO_VideoInit(_THIS)
     mode.h = 272;
     mode.refresh_rate = 60;
     SDL_AddDisplayMode(&display, &mode);
-
+#endif
     SDL_AddVideoDisplay(&display, SDL_FALSE);
 
     LINE_H = 30;
@@ -5111,10 +6357,6 @@ int MMIYOO_VideoInit(_THIS)
     FB_SIZE = FB_W * FB_H * FB_BPP * 2;
     TMP_SIZE = FB_W * FB_H * FB_BPP;
 
-#ifdef FUNKEYS
-    FB_SIZE = FB_W * FB_H * FB_BPP;
-#endif
-
 #ifdef MMIYOO
     fd = popen("fbset | grep \"mode \"", "r");
     if (fd) {
@@ -5138,14 +6380,19 @@ int MMIYOO_VideoInit(_THIS)
     read_config();
     MMIYOO_EventInit();
 
-    detour_init(sysconf(_SC_PAGESIZE), nds.states.path);
+    detour_init(4096, nds.states.path);
     printf(PREFIX"Installed hooking for drastic functions\n");
     detour_hook(FUN_PRINT_STRING, (intptr_t)sdl_print_string);
-    detour_hook(FUN_SAVESTATE_PRE, (intptr_t)sdl_savestate_pre);
-    detour_hook(FUN_SAVESTATE_POST, (intptr_t)sdl_savestate_post);
-    detour_hook(FUN_BLIT_SCREEN_MENU, (intptr_t)sdl_blit_screen_menu);
+    //detour_hook(FUN_SAVESTATE_PRE, (intptr_t)sdl_savestate_pre);
+    //detour_hook(FUN_SAVESTATE_POST, (intptr_t)sdl_savestate_post);
+    //detour_hook(FUN_BLIT_SCREEN_MENU, (intptr_t)sdl_blit_screen_menu);
     detour_hook(FUN_UPDATE_SCREEN, (intptr_t)sdl_update_screen);
-#ifdef MMIYOO
+    detour_hook(FUN_UPDATE_SCREENS, (intptr_t)sdl_update_screens);
+    //detour_hook(FUN_RENDER_POLYGON_SETUP_PERSPECTIVE_STEPS, (intptr_t)render_polygon_setup_perspective_steps);    
+
+    detour_hook(FUN_DRAW_MENU_BG, (intptr_t)sdl_draw_menu_bg);
+
+#if defined(MMIYOO) || defined(A30)
     printf(PREFIX"Installed hooking for libc functions\n");
     detour_hook(FUN_MALLOC, (intptr_t)sdl_malloc);
     detour_hook(FUN_REALLOC, (intptr_t)sdl_realloc);
@@ -5240,7 +6487,7 @@ void MMIYOO_VideoQuit(_THIS)
     lang_unload();
 }
 
-#if defined(MMIYOO) || defined(QX1000)
+#if defined(MMIYOO) || defined(QX1000) || defined(A30) || defined(RG35XXH)
 static const char *DIS_MODE0_640[] = {
     "640*480",
     "640*480",
@@ -5325,6 +6572,12 @@ static const char *HOTKEY[] = {
     "MENU", "SELECT"
 };
 
+#ifdef A30
+static const char *JOY_MODE[] = {
+    "Disable", "D-Pad", "Stylus"
+};
+#endif
+
 static int lang_next(void)
 {
     int cc = 0;
@@ -5357,7 +6610,12 @@ static int lang_prev(void)
 
 enum {
     MENU_LANG = 0,
+#ifdef A30
+    MENU_CPU_CORE,
+    MENU_CPU_CLOCK,
+#else
     MENU_CPU,
+#endif
     MENU_OVERLAY,
     MENU_DIS,
     MENU_DIS_ALPHA,
@@ -5372,12 +6630,21 @@ enum {
     MENU_PEN_YV,
     MENU_CURSOR,
     MENU_FAST_FORWARD,
+#ifdef A30
+    MENU_JOYSTICK_MODE,
+    MENU_JOYSTICK_DZONE,
+#endif
     MENU_LAST,
 };
 
 static const char *MENU_ITEM[] = {
     "Language",
+#ifdef A30
+    "CPU Core",
+    "CPU Clock",
+#else
     "CPU",
+#endif
     "Overlay",
     "Display",
     "Alpha",
@@ -5391,15 +6658,26 @@ static const char *MENU_ITEM[] = {
     "Pen X Speed",
     "Pen Y Speed",
     "Cursor",
-    "Fast Forward"
+    "Fast Forward",
+#ifdef A30
+    "Joy Mode",
+    "Joy DZone"
+#endif
 };
 
 int handle_menu(int key)
 {
     static int pre_ff = 0;
     static int cur_sel = 0;
+#ifdef A30
+    static uint32_t cur_cpucore = INIT_CPU_CORE;
+    static uint32_t pre_cpucore = INIT_CPU_CORE;
+    static uint32_t cur_cpuclock = INIT_CPU_CLOCK;
+    static uint32_t pre_cpuclock = INIT_CPU_CLOCK;
+#else
     static uint32_t cur_cpuclock = 0;
     static uint32_t pre_cpuclock = 0;
+#endif
     static char pre_lang[LANG_FILE_LEN] = {0};
 
     const int SX = nds.enable_752x560 ? 200 : 150;
@@ -5447,11 +6725,24 @@ int handle_menu(int key)
         case MENU_LANG:
             lang_prev();
             break;
+#ifdef A30
+        case MENU_CPU_CORE:
+            if (cur_cpucore > nds.mincore) {
+                cur_cpucore-= 1;
+            }
+            break;
+        case MENU_CPU_CLOCK:
+            if (cur_cpuclock > nds.mincpu) {
+                cur_cpuclock-= 50;
+            }
+            break;
+#else
         case MENU_CPU:
             if (cur_cpuclock > nds.mincpu) {
                 cur_cpuclock-= 50;
             }
             break;
+#endif
         case MENU_HOTKEY:
             nds.hotkey = HOTKEY_BIND_MENU;
             break;
@@ -5525,6 +6816,18 @@ int handle_menu(int key)
                 nds.fast_forward -= 1;
             }
             break;
+#ifdef A30
+        case MENU_JOYSTICK_MODE:
+            if (nds.joy.mode > 0) {
+                nds.joy.mode -= 1;
+            }
+            break;
+        case MENU_JOYSTICK_DZONE:
+            if (nds.joy.dzone > 0) {
+                nds.joy.dzone -= 1;
+            }
+            break;
+#endif
         default:
             break;
         }
@@ -5534,11 +6837,24 @@ int handle_menu(int key)
         case MENU_LANG:
             lang_next();
             break;
+#ifdef A30
+        case MENU_CPU_CORE:
+            if (cur_cpucore < nds.maxcore) {
+                cur_cpucore+= 1;
+            }
+            break;
+        case MENU_CPU_CLOCK:
+            if (cur_cpuclock < nds.maxcpu) {
+                cur_cpuclock+= 50;
+            }
+            break;
+#else
         case MENU_CPU:
             if (cur_cpuclock < nds.maxcpu) {
                 cur_cpuclock+= 50;
             }
             break;
+#endif
         case MENU_HOTKEY:
             nds.hotkey = HOTKEY_BIND_SELECT;
             break;
@@ -5612,6 +6928,21 @@ int handle_menu(int key)
                 nds.fast_forward += 1;
             }
             break;
+#ifdef A30
+        case MENU_JOYSTICK_MODE:
+            if (nds.joy.mode < MYJOY_MODE_MOUSE) {
+                nds.joy.mode += 1;
+            }
+            if (evt.mode == MMIYOO_MOUSE_MODE) {
+                evt.mode = MMIYOO_KEYPAD_MODE;
+            }
+            break;
+        case MENU_JOYSTICK_DZONE:
+            if (nds.joy.dzone < 255) {
+                nds.joy.dzone += 1;
+            }
+            break;
+#endif
         default:
             break;
         }
@@ -5621,9 +6952,20 @@ int handle_menu(int key)
 #ifdef MMIYOO
             set_cpuclock(cur_cpuclock);
 #endif
+
+#ifdef A30
+            set_best_match_cpu_clock(cur_cpuclock);
+#endif
             pre_cpuclock = cur_cpuclock;
         }
 
+#ifdef A30
+        if (cur_cpucore != pre_cpucore) {
+            set_core(cur_cpucore);
+            pre_cpucore = cur_cpucore;
+        }
+#endif
+
         if (strcmp(pre_lang, nds.lang.trans[DEF_LANG_SLOT])) {
             lang_unload();
             lang_load(nds.lang.trans[DEF_LANG_SLOT]);
@@ -5631,7 +6973,7 @@ int handle_menu(int key)
         }
 
         if (pre_ff != nds.fast_forward) {
-            dtr_fastforward(nds.fast_forward);
+            //dtr_fastforward(nds.fast_forward);
             pre_ff = nds.fast_forward;
         }
         nds.menu.enable = 0;
@@ -5773,9 +7115,18 @@ int handle_menu(int key)
         case MENU_LANG:
             sprintf(buf, "%s", nds.lang.trans[DEF_LANG_SLOT]);
             break;
+#ifdef A30
+        case MENU_CPU_CORE:
+            sprintf(buf, "%d", cur_cpucore);
+            break;
+        case MENU_CPU_CLOCK:
+            sprintf(buf, "%dMHz", cur_cpuclock);
+            break;
+#else
         case MENU_CPU:
             sprintf(buf, "%dMHz", cur_cpuclock);
             break;
+#endif
         case MENU_HOTKEY:
             sprintf(buf, "%s", to_lang(HOTKEY[nds.hotkey]));
             break;
@@ -5788,7 +7139,7 @@ int handle_menu(int key)
         case MENU_OVERLAY:
             if (nds.overlay.sel < nds.overlay.max) {
                 get_file_path(nds.overlay.path, nds.overlay.sel, buf, 0);
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH)
                 reload_overlay();
 #endif
             }
@@ -5839,10 +7190,18 @@ int handle_menu(int key)
             sprintf(buf, "%s", DPAD[nds.keys_rotate % 3]);
             break;
         case MENU_PEN_XV:
+#ifdef A30
+            sprintf(buf, "%d (80000)", nds.pen.xv);
+#else
             sprintf(buf, "%d (30000)", nds.pen.xv);
+#endif
             break;
         case MENU_PEN_YV:
+#ifdef A30
+            sprintf(buf, "%d (85000)", nds.pen.yv);
+#else
             sprintf(buf, "%d (35000)", nds.pen.yv);
+#endif
             break;
         case MENU_CURSOR:
             sprintf(buf, "%s", to_lang(nds.menu.show_cursor ? "Show" : "Hide"));
@@ -5850,6 +7209,14 @@ int handle_menu(int key)
         case MENU_FAST_FORWARD:
             sprintf(buf, "%d (6)", nds.fast_forward);
             break;
+#ifdef A30
+        case MENU_JOYSTICK_MODE:
+            sprintf(buf, "%s", to_lang(JOY_MODE[nds.joy.mode]));
+            break;
+        case MENU_JOYSTICK_DZONE:
+            sprintf(buf, "%d (65)", nds.joy.dzone);
+            break;
+#endif
         }
         draw_info(cvt, buf, SSX + sx, SY + (h * idx), col1, 0);
         idx+= 1;
@@ -6052,10 +7419,10 @@ int handle_menu(int key)
             rt.y = sy;
             SDL_FillRect(cvt, &rt, SDL_MapRGB(cvt->format, 0x80, 0x00, 0x00));
             
-            rt.w = 51;
-            rt.h = 38;
-            rt.x = sx + ((128 - rt.w) / 2);
-            rt.y = sy + ((96 - rt.h) / 2);
+            rt.w = 128-77;
+            rt.h = 96-58;
+            rt.x = sx + 77;
+            rt.y = sy + 58;
             SDL_FillRect(cvt, &rt, SDL_MapRGB(cvt->format, 0x00, 0x00, 0x80));
             break;
         case NDS_DIS_MODE_VH_S2:
@@ -6067,14 +7434,14 @@ int handle_menu(int key)
             
             rt.w = 96;
             rt.h = 72;
-            rt.x = sx;
+            rt.x = sx + (128 - 96) /2;
             rt.y = sy;
             SDL_FillRect(cvt, &rt, SDL_MapRGB(cvt->format, 0x80, 0x00, 0x00));
             
             rt.w = 32;
             rt.h = 24;
             rt.x = sx + ((128 - rt.w) / 2);
-            rt.y = sy + ((96 - rt.h) / 2);
+            rt.y = sy + 72;
             SDL_FillRect(cvt, &rt, SDL_MapRGB(cvt->format, 0x00, 0x00, 0x80));
             break;
         case NDS_DIS_MODE_VH_C0:
@@ -6176,36 +7543,16 @@ int handle_menu(int key)
         }
     }
 
-    GFX_Copy(cvt->pixels, cvt->clip_rect, cvt->clip_rect, cvt->pitch, 0, E_MI_GFX_ROTATE_180);
+#if defined(A30) || defined(RG35XXH_GL)
+    nds.update_menu = 1;
+#else
+    GFX_Copy(-1, cvt->pixels, cvt->clip_rect, cvt->clip_rect, cvt->pitch, 0, E_MI_GFX_ROTATE_180);
     GFX_Flip();
+#endif
     need_reload_bg = RELOAD_BG_COUNT;
     return 0;
 }
 #endif
 
-#endif
-
-#ifdef UNITTEST
-    #include "unity_fixture.h"
-
-TEST_GROUP(sdl2_video_mmiyoo);
-
-TEST_SETUP(sdl2_video_mmiyoo)
-{
-}
-
-TEST_TEAR_DOWN(sdl2_video_mmiyoo)
-{
-}
-
-TEST(sdl2_video_mmiyoo, get_current_menu_layer)
-{
-    TEST_ASSERT_EQUAL(get_current_menu_layer(), -1);
-}
 
-TEST_GROUP_RUNNER(sdl2_video_mmiyoo)
-{
-    RUN_TEST_CASE(sdl2_video_mmiyoo, get_current_menu_layer);
-}
-#endif
 
diff --git a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h
index 36fb185..1370eeb 100644
--- a/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h
+++ b/sdl2/src/video/mmiyoo/SDL_video_mmiyoo.h
@@ -1,9 +1,9 @@
 /*
-  Customized version for Miyoo-Mini handheld.
-  Only tested under Miyoo-Mini stock OS (original firmware) with Parasyte compatible layer.
+  Special customized version for the DraStic emulator that runs on
+  Miyoo Mini (Plus), TRIMUI-SMART and Miyoo A30 handhelds.
 
   Copyright (C) 1997-2022 Sam Lantinga <slouken@libsdl.org>
-  Copyright (C) 2022-2022 Steward Fu <steward.fu@gmail.com>
+  Copyright (C) 2022-2024 Steward Fu <steward.fu@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -21,7 +21,6 @@
      misrepresented as being the original software.
   3. This notice may not be removed or altered from any source distribution.
 */
-#include "../../SDL_internal.h"
 
 #ifndef __SDL_VIDEO_MMIYOO_H__
 #define __SDL_VIDEO_MMIYOO_H__
@@ -29,14 +28,22 @@
 #include <stdint.h>
 #include <stdbool.h>
 #include <linux/fb.h>
-#if defined(PANDORA)
+#ifdef PANDORA
 #include <linux/omapfb.h>
 #endif
 
+#if defined(A30) || defined(RG35XXH_GL)
+#include <EGL/egl.h>
+#include <GLES2/gl2.h>
+#endif
+
+#include <pthread.h>
+
+#include "../../SDL_internal.h"
+#include "../../events/SDL_events_c.h"
 #include "../SDL_sysvideo.h"
 #include "../SDL_sysvideo.h"
 #include "../SDL_pixels_c.h"
-#include "../../events/SDL_events_c.h"
 
 #include "SDL_ttf.h"
 #include "SDL_image.h"
@@ -46,11 +53,28 @@
 #include "SDL_events.h"
 #include "SDL_video.h"
 #include "SDL_mouse.h"
-#include "SDL_video_mmiyoo.h"
+//#include "SDL_video_mmiyoo.h"
 #include "SDL_event_mmiyoo.h"
 
 #include "detour.h"
 
+#include "drastic.h"
+
+#ifdef A30
+#define USE_MYJOY           1
+
+#define MYJOY_MODE_DISABLE  0
+#define MYJOY_MODE_KEYPAD   1
+#define MYJOY_MODE_MOUSE    2
+#define MYJOY_SHOW_CNT      300
+#define MYJOY_MOVE_SPEED    4
+
+#define INIT_CPU_CORE       4
+#define INIT_CPU_CLOCK      1350
+#define DEINIT_CPU_CORE     2
+#define DEINIT_CPU_CLOCK    648
+#endif
+
 #if defined(MMIYOO)
 #include "mi_sys.h"
 #include "mi_gfx.h"
@@ -69,8 +93,10 @@
 
 #if !defined(MMIYOO)
     #define E_MI_GFX_ROTATE_90      0
-    #define E_MI_GFX_ROTATE_180     0
-    #define E_MI_GFX_ROTATE_270     0
+    #define E_MI_GFX_ROTATE_180     1
+    #define E_MI_GFX_ROTATE_270     2
+    #define E_MI_GFX_FMT_RGB565     0
+    #define E_MI_GFX_FMT_ARGB8888   1
 #endif
 
 #ifdef QX1000
@@ -126,6 +152,26 @@
     #define MAX_PATH                128
 #endif
 
+#ifdef RG35XXH
+    #define DEF_FB_W                640
+    #define DEF_FB_H                480
+    #define FB_BPP                  4
+    #define IMG_W                   640
+    #define IMG_H                   480
+    #define SCREEN_DMA_SIZE         (NDS_Wx2 * NDS_Hx2 * 4)
+    #define RELOAD_BG_COUNT         1
+#endif
+
+#ifdef A30
+    #define DEF_FB_W                640
+    #define DEF_FB_H                480
+    #define FB_BPP                  4
+    #define IMG_W                   640
+    #define IMG_H                   480
+    #define SCREEN_DMA_SIZE         (NDS_Wx2 * NDS_Hx2 * 4)
+    #define RELOAD_BG_COUNT         120
+#endif
+
 #ifdef MMIYOO
     #define DEF_FB_W                640
     #define DEF_FB_H                480
@@ -147,15 +193,6 @@
     #define RELOAD_BG_COUNT         1
 #endif
 
-#ifdef FUNKEYS
-    #define DEF_FB_W                240
-    #define DEF_FB_H                240
-    #define FB_BPP                  2
-    #define IMG_W                   640
-    #define IMG_H                   480
-    #define RELOAD_BG_COUNT         1
-#endif
-
 #ifdef PANDORA
     #define DEF_FB_W                800
     #define DEF_FB_H                480
@@ -177,26 +214,14 @@
 #endif
 
 #define PREFIX                      "[SDL] "
-
-#ifdef FUNKEYS
-    #define SHOT_PATH               "/mnt/Screenshots"
-#else
-    #define SHOT_PATH               "/mnt/SDCARD/Screenshots"
-#endif
-
+#define SHOT_PATH                   "/mnt/SDCARD/Screenshots"
 #define BIOS_PATH                   "system"
 #define CFG_PATH                    "resources/settings.json"
 #define THEME_PATH                  "resources/bg"
 #define PEN_PATH                    "resources/pen"
 #define LANG_PATH                   "resources/lang"
 #define OVERLAY_PATH                "resources/overlay"
-
-#if defined(FUNKEYS)
-    #define MENU_PATH               "resources/menu/240"
-#else
-    #define MENU_PATH               "resources/menu/640"
-#endif
-
+#define MENU_PATH                   "resources/menu/640"
 #define MENU_BG_FILE                "bg.png"
 #define MENU_CURSOR_FILE            "cursor.png"
 #define DRASTIC_MENU_BG0_FILE       "drastic_bg0.png"
@@ -212,24 +237,17 @@
 #define PEN_LB                      1
 #define PEN_RT                      2
 #define PEN_RB                      3
+#define PEN_CP                      4
 #define FONT_PATH                   "resources/font/font.ttf"
 
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(PANDORA) || defined(QX1000) || defined(RG35XXH)
     #define DEF_FONT_SIZE           24
 #endif
 
-#if defined(TRIMUI) || defined(FUNKEYS)
+#if defined(TRIMUI)
     #define DEF_FONT_SIZE           12
 #endif
 
-#ifdef PANDORA
-    #define DEF_FONT_SIZE           24
-#endif
-
-#ifdef QX1000
-    #define DEF_FONT_SIZE           24
-#endif
-
 #define NDS_DIS_MODE_VH_T0          0
 #define NDS_DIS_MODE_VH_T1          1
 #define NDS_DIS_MODE_S0             2
@@ -265,6 +283,8 @@
 #define JSON_NDS_ALPHA_VALUE        "alpha"
 #define JSON_NDS_ALPHA_POSITION     "position"
 #define JSON_NDS_ALPHA_BORDER       "border"
+#define JSON_NDS_MAX_CORE           "maxcore"
+#define JSON_NDS_MIN_CORE           "mincore"
 #define JSON_NDS_MAX_CPU            "maxcpu"
 #define JSON_NDS_MIN_CPU            "mincpu"
 #define JSON_NDS_OVERLAY            "overlay"
@@ -283,6 +303,9 @@
 #define JSON_NDS_MENU_BG            "menu_bg"
 #define JSON_NDS_MENU_CURSOR        "menu_cursor"
 #define JSON_NDS_FAST_FORWARD       "fast_forward"
+#define JSON_NDS_JOY_MODE           "joy_mode"
+#define JSON_NDS_JOY_DZONE          "joy_dzone"
+#define JSON_NDS_PIXEL_FILTER       "pixel_filter"
 
 #define DEF_LANG_SLOT               0
 #define DEF_LANG_LANG               "english"
@@ -311,8 +334,55 @@
 #define PEN_YV_INC                      1000
 #define PEN_YV_MAX                      500000
 
+#ifdef A30
+
+#define DAC_BASE                        0x1c22000
+#define CCU_BASE                        0x01C20000
+
+enum _TEX_TYPE {
+    TEX_SCR0 = 0,
+    TEX_SCR1,
+    TEX_BG,
+    TEX_PEN,
+    TEX_TMP,
+    TEX_MAX
+};
+#endif
+
+#ifdef RG35XXH_GL
+enum _TEX_TYPE {
+    TEX_SCR0 = 0,
+    TEX_SCR1,
+    TEX_BG,
+    TEX_PEN,
+    TEX_TMP,
+    TEX_MAX
+};
+#endif
+
 typedef struct MMIYOO_VideoInfo {
     SDL_Window *window;
+
+#if defined(A30) || defined(RG35XXH_GL)
+    EGLConfig eglConfig;
+    EGLDisplay eglDisplay;
+    EGLContext eglContext;
+    EGLSurface eglSurface;
+    GLuint vShader;
+    GLuint fShader;
+    GLuint pObject;
+    GLuint texID[TEX_MAX];
+    GLint posLoc;
+    GLint texLoc;
+    GLint samLoc;
+    GLint alphaLoc;
+
+    int mem_fd;
+    uint8_t* ccu_mem;
+    uint8_t* dac_mem;
+    uint32_t *vol_ptr;
+    uint32_t *cpu_ptr;
+#endif
 } MMIYOO_VideoInfo;
 
 typedef struct _GFX {
@@ -334,6 +404,10 @@ typedef struct _GFX {
     struct fb_fix_screeninfo finfo;
 
     struct {
+#if defined(A30) || defined(RG35XXH_GL)
+        void *virAddr;
+#endif
+
 #ifdef MMIYOO
         void *virAddr;
         MI_PHY phyAddr;
@@ -344,11 +418,14 @@ typedef struct _GFX {
 #endif
     } fb, tmp, overlay;
 
-#ifdef MMIYOO
+#if defined(MMIYOO) || defined(A30) || defined(RG35XXH_GL)
     struct {
-        void *virAddr[2];
-        MI_PHY phyAddr[2];
-    } lcd, dup;
+        int cur_sel;
+        void *virAddr[2][2];
+#ifdef MMIYOO
+        MI_PHY phyAddr[2][2];
+#endif
+    } lcd;
 #endif
 
     struct _HW {
@@ -367,10 +444,12 @@ typedef struct _GFX {
         ion_alloc_info_t ion;
 #endif
 
-#ifdef FUNKEYS
+#ifdef RG35XXH
         uint32_t *mem;
+		SDL_Surface *swsurface;
 #endif
 
+
 #ifdef PANDORA
         uint32_t *mem[2];
 #endif
@@ -378,11 +457,14 @@ typedef struct _GFX {
 } GFX;
 
 typedef struct _NDS {
+    int mincore;
+    int maxcore;
     int mincpu;
     int maxcpu;
     int volume;
     int hotkey;
     int dis_mode;
+    int dis_hres_mode; // add by trngaje
     int alt_mode;
     int hres_mode;
     int swap_l1l2;
@@ -390,6 +472,7 @@ typedef struct _NDS {
     int auto_slot;
     int auto_state;
     int keys_rotate;
+    int update_menu;
     int update_screen;
     int enable_752x560;
     int defer_update_bg;
@@ -482,6 +565,33 @@ typedef struct _NDS {
         clock_t pre_ticks;
         char path[MAX_PATH];
     } pen;
+
+#ifdef A30
+    struct _JOY {
+        int max_x;
+        int zero_x;
+        int min_x;
+
+        int max_y;
+        int zero_y;
+        int min_y;
+
+        int mode;
+        int dzone;
+        int show_cnt;
+    } joy;
+#endif
+
+#ifdef RG35XXH
+    struct _INPUT {
+	    char dev[20]; /* ex) /dev/input/event0 */
+		int key[NUM_OF_MYKEY];
+	} input;
+	
+	struct _DISPLAY {
+		int rotate; // 0, 90, 180, 270
+	} display;
+#endif
 } NDS;
 
 typedef struct _CUST_MENU_SUB {
@@ -499,13 +609,20 @@ typedef struct _CUST_MENU {
     CUST_MENU_SUB item[MAX_MENU_LINE];
 } CUST_MENU;
 
+#ifdef A30
+struct _cpu_clock {
+    int clk;
+    uint32_t reg;
+};
+#endif
+
 int snd_nds_savestate(int slot);
 void snd_nds_reload_config(void);
 void neon_memcpy(void *dest, const void *src, size_t n);
 
 void GFX_Clear(void);
 void GFX_Flip(void);
-int GFX_Copy(const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int pitch, int alpha, int rotate);
+int GFX_Copy(int id, const void *pixels, SDL_Rect srcrect, SDL_Rect dstrect, int pitch, int alpha, int rotate);
 
 int draw_pen(void *pixels, int width, int pitch);
 int draw_info(SDL_Surface *dst, const char *info, int x, int y, uint32_t fgcolor, uint32_t bgcolor);
@@ -531,5 +648,17 @@ const void* get_pixels(void *chk);
 const char *to_lang(const char *p);
 void update_wayland_res(int w, int h);
 
+void render_scanline_tiled_4bpp(void);
+void render_polygon_setup_perspective_steps(void);
+void MMIYOO_JoystickUpdate(SDL_Joystick *joystick);
+
+
+// Declaration of thread condition variable
+extern pthread_cond_t request_update_screen_cond;
+extern pthread_cond_t response_update_screen_cond;
+
+// declaring mutex
+extern pthread_mutex_t lock;
+
 #endif
 
